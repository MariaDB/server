    case MSG_ACCESS_VIOLATN:  p = "Access violation";                                        break;
    case MSG_ADD_BAD_TYPE:    p = "Array add value type mismatch (%s -> %s)";                break;
    case MSG_ALLOC_ERROR:     p = "Error allocating %s";                                     break;
    case MSG_ANSWER_TYPE:     p = "Answer of type";                                          break;
    case MSG_API_CONF_ERROR:  p = "SQL Error: API_CONFORMANCE";                              break;
    case MSG_APPL_NOT_INIT:   p = "Application not initialized";                             break;
    case MSG_ARRAY_BNDS_EXCD: p = "Array bounds exceeded";                                   break;
    case MSG_BAD_ARRAY_OPER:  p = "Arrays must be used with the IN operator";                break;
    case MSG_BAD_ARRAY_TYPE:  p = "Illegal array type %d";                                   break;
    case MSG_BAD_ARRAY_VAL:   p = "Arrays must have the same number of values";              break;
    case MSG_BAD_BIN_FMT:     p = "Invalid format %c for the %s BIN column";                 break;
    case MSG_BAD_BLK_ESTIM:   p = "Number of blocks exceeds estimate";                       break;
    case MSG_BAD_BLK_SIZE:    p = "No match in block %d size";                               break;
    case MSG_BAD_BYTE_NUM:    p = "bad number of bytes written";                             break;
    case MSG_BAD_BYTE_READ:   p = "bad number of bytes read";                                break;
    case MSG_BAD_COL_TYPE:    p = "Invalid type %s for column %s";                           break;
    case MSG_BAD_COL_XPATH:   p = "Invalid Xpath in column %s for HTML table %s";            break;
    case MSG_BAD_CONST_TYPE:  p = "Bad constant type=%d";                                    break;
    case MSG_BAD_CONV_TYPE:   p = "Invalid convert type %d";                                 break;
    case MSG_BAD_DATETIME:    p = "Invalid datetime value";                                  break;
    case MSG_BAD_DBF_FILE:    p = "DBF file %s is corrupted";                                break;
    case MSG_BAD_DBF_REC:     p = "DBF file %s corrupted at record %d";                      break;
    case MSG_BAD_DBF_TYPE:    p = "Unsupported DBF type %c for column %s";                   break;
    case MSG_BAD_DIRECTORY:   p = "Bad directory %s: %s";                                    break;
    case MSG_BAD_FIELD_RANK:  p = "Invalid field rank %d for column %s";                     break;
    case MSG_BAD_FIELD_TYPE:  p = "Bad type field %s";                                       break;
    case MSG_BAD_FILE_HANDLE: p = "Invalid File Handle: %s";                                 break;
    case MSG_BAD_FILTER:      p = "Bad filter: Opc=%d B_T=%d %d Type=%d %d";                 break;
    case MSG_BAD_FILTER_CONV: p = "Bad filter conversion, B_T=%d,%d";                        break;
    case MSG_BAD_FILTER_OP:   p = "Invalid filter operator %d";                              break;
    case MSG_BAD_FLD_FORMAT:  p = "Bad format for field %d of %s";                           break;
    case MSG_BAD_FLD_LENGTH:  p = "Field %s too long (%s --> %d) line %d of %s";             break;
    case MSG_BAD_FREQ_SET:    p = "Bad frequency setting for column %s";                     break;
    case MSG_BAD_FUNC_MODE:   p = "%s: invalid mode %d";                                     break;
    case MSG_BAD_HANDLE_VAL:  p = "Invalid handle value";                                    break;
    case MSG_BAD_HEADER:      p = "File %s: Header corrupted";                               break;
    case MSG_BAD_HEAD_END:    p = "Can't read end of header";                                break;
    case MSG_BAD_INDEX_FILE:  p = "Wrong index file %s";                                     break;
    case MSG_BAD_LINEFLD_FMT: p = "Bad format line %d field %d of %s";                       break;
    case MSG_BAD_LINE_LEN:    p = "Line length not equal to Lrecl";                          break;
    case MSG_BAD_LRECL:       p = "Table/File lrecl mismatch (%d,%hd)";                      break;
    case MSG_BAD_NODE_TYPE:   p = "Bad type %d for table node";                              break;
    case MSG_BAD_OFFSET_VAL:  p = "Invalid null offset value for a CSV table";               break;
    case MSG_BAD_OPEN_MODE:   p = "Invalid open mode %d";                                    break;
    case MSG_BAD_PARAM_TYPE:  p = "%.8s: Bad parameter type=%d";                             break;
    case MSG_BAD_PARM_COUNT:  p = "Parameter count mismatch";                                break;
    case MSG_BAD_QUOTE_FIELD: p = "Missing ending quote in %s field %d line %d";             break;
    case MSG_BAD_READ_NUMBER: p = "Wrong number %d of values read from %s";                  break;
    case MSG_BAD_RECFM:       p = "Invalid recfm type %d for DOSCOL";                        break;
    case MSG_BAD_RECFM_VAL:   p = "Bad Recfm value %d";                                      break;
    case MSG_BAD_SET_CASE:    p = "Cannot set sensitive an insensitive array";               break;
    case MSG_BAD_SET_STRING:  p = "Invalid SetValue from string";                            break;
    case MSG_BAD_SPECIAL_COL: p = "Bad special column %s";                                   break;
    case MSG_BAD_SPEC_COLUMN: p = "Special column invalid for this table type";              break;
    case MSG_BAD_TABLE_TYPE:  p = "Bad type %s for table %s";                                break;
    case MSG_BAD_TYPE_LIKE:   p = "Bad operand(%d) type=%d for LIKE";                        break;
    case MSG_BAD_VALBLK_INDX: p = "Out of range valblock index value";                       break;
    case MSG_BAD_VALBLK_TYPE: p = "Invalid value block type %d";                             break;
    case MSG_BAD_VALNODE:     p = "Bad type %d for column %s value node";                    break;
    case MSG_BAD_VALUE_TYPE:  p = "Invalid value type %d";                                   break;
    case MSG_BAD_VAL_UPDATE:  p = "Don't know which %s value to update";                     break;
    case MSG_BAS_NS_LIST:     p = "Invalid namespaces list format";                          break;
    case MSG_BIN_F_TOO_LONG:  p = "Value too long for field %s (%d --> %d)";                 break;
    case MSG_BIN_MODE_FAIL:   p = "Set binary mode failed: %s";                              break;
    case MSG_BLKTYPLEN_MISM:  p = "Non matching block types/lengths in SetValue";            break;
    case MSG_BLK_IS_NULL:     p = "Blk is NULL";                                             break;
    case MSG_BREAKPOINT:      p = "Breakpoint";                                              break;
    case MSG_BUILD_INDEX:     p = "Building index %s on %s";                                 break;
    case MSG_CANNOT_OPEN:     p = "Cannot open %s";                                          break;
    case MSG_CHSIZE_ERROR:    p = "chsize error: %s";                                        break;
    case MSG_COL_ALLOC_ERR:   p = "Cannot allocate column node";                             break;
    case MSG_COL_ISNOT_TABLE: p = "Column %s is not in table %s";                            break;
    case MSG_COL_NOT_SORTED:  p = "Column %s of table %s is not sorted";                     break;
    case MSG_COL_NUM_MISM:    p = "Number of columns mismatch";                              break;
    case MSG_COM_ERROR:       p = "Com error";                                               break;
    case MSG_CONCAT_SUBNODE:  p = "Cannot concatenate sub-nodes";                            break;
    case MSG_CONNECT_CANCEL:  p = "Connection cancelled by user";                            break;
    case MSG_CONTROL_C_EXIT:  p = "Control C exit";                                          break;
    case MSG_DATABASE_LOADED: p = "Database %s loaded";                                      break;
    case MSG_DATA_MISALIGN:   p = "Datatype misalignment";                                   break;
    case MSG_DBASE_FILE:      p = "dBASE dbf file: ";                                        break;
    case MSG_DEF_ALLOC_ERROR: p = "Error allocating %s DEF class";                           break;
    case MSG_DEL_FILE_ERR:    p = "Error deleting %s";                                       break;
    case MSG_DEL_READ_ERROR:  p = "Delete: read error req=%d len=%d";                        break;
    case MSG_DEL_WRITE_ERROR: p = "Delete: write error: %s";                                 break;
    case MSG_DEPREC_FLAG:     p = "Deprecated option Flag, use Coltype";                     break;
    case MSG_DLL_LOAD_ERROR:  p = "Error %d loading module %s";                              break;
    case MSG_DOM_NOT_SUPP:    p = "MS-DOM not supported by this version";                    break;
    case MSG_DVAL_NOTIN_LIST: p = "Value %s not found in distinct values list of column %s"; break;
    case MSG_EMPTY_DOC:       p = "Empty document";                                          break;
    case MSG_EMPTY_FILE:      p = "%s empty file %s: ";                                      break;
    case MSG_EOF_AFTER_LINE:  p = "EOF after line %d";                                       break;
    case MSG_EOF_INDEX_FILE:  p = "EOF while reading index file";                            break;
    case MSG_ERROR_IN_LSK:    p = "Error %d in lseek64";                                     break;
    case MSG_ERROR_IN_SFP:    p = "Error %d in SetFilePointer";                              break;
    case MSG_ERR_READING_REC: p = "Error reading record %d of %s";                           break;
    case MSG_FAIL_ADD_NODE:   p = "Failed to add %s table node";                             break;
    case MSG_FETCH_NO_RES:    p = "Fetch: No Result Set";                                    break;
    case MSG_FIELD_TOO_LONG:  p = "Value too long for field %d line %d";                     break;
    case MSG_FILELEN_ERROR:   p = "Error in %s for %s";                                      break;
    case MSG_FILE_IS_EMPTY:   p = "File %s is empty";                                        break;
    case MSG_FILE_MAP_ERR:    p = "File mapping error";                                      break;
    case MSG_FILE_MAP_ERROR:  p = "CreateFileMapping %s error rc=%d";                        break;
    case MSG_FILE_OPEN_YET:   p = "File %s already open";                                    break;
    case MSG_FILE_UNFOUND:    p = "File %s not found";                                       break;
    case MSG_FLD_TOO_LNG_FOR: p = "Field %d too long for %s line %d of %s";                  break;
    case MSG_FLT_BAD_RESULT:  p = "Float inexact result";                                    break;
    case MSG_FLT_DENORMAL_OP: p = "Float denormal operand";                                  break;
    case MSG_FLT_INVALID_OP:  p = "Float invalid operation";                                 break;
    case MSG_FLT_OVERFLOW:    p = "Float overflow";                                          break;
    case MSG_FLT_STACK_CHECK: p = "Float stack check";                                       break;
    case MSG_FLT_UNDERFLOW:   p = "Float underflow";                                         break;
    case MSG_FLT_ZERO_DIVIDE: p = "Float divide by zero";                                    break;
    case MSG_FMT_WRITE_NIY:   p = "Writing %s files is not implemented yet";                 break;
    case MSG_FOXPRO_FILE:     p = "FoxPro file: ";                                           break;
    case MSG_FPUTS_ERROR:     p = "fputs error: %s";                                         break;
    case MSG_FSEEK_ERROR:     p = "fseek error: %s";                                         break;
    case MSG_FSETPOS_ERROR:   p = "fseek error for i=%d";                                    break;
    case MSG_FTELL_ERROR:     p = "ftell error for recd=%d: %s";                             break;
    case MSG_FUNCTION_ERROR:  p = "%s error: %d";                                            break;
    case MSG_FUNC_ERRNO:      p = "Error %d in %s";                                          break;
    case MSG_FUNC_ERROR:      p = "Error in %s";                                             break;
    case MSG_FUNC_ERR_S:      p = "%s error: %s";                                            break;
    case MSG_FWRITE_ERROR:    p = "fwrite error: %s";                                        break;
    case MSG_GET_DIST_VALS:   p = "Retrieving distinct values from ";                        break;
    case MSG_GET_FUNC_ERR:    p = "Error getting function %s: %s";                           break;
    case MSG_GLOBAL_ERROR:    p = "Cannot allocate Global (size=%d)\n";                      break;
    case MSG_GUARD_PAGE:      p = "Guard page violation";                                    break;
    case MSG_GZOPEN_ERROR:    p = "gzopen %s error %d on %s";                                break;
    case MSG_ILLEGAL_INSTR:   p = "Illegal instruction";                                     break;
    case MSG_ILL_FILTER_CONV: p = "Filtering implies an illegal conversion";                 break;
    case MSG_INDEX_NOT_UNIQ:  p = "Index is not unique";                                     break;
    case MSG_INDEX_YET_ON:    p = "Index %s already exists on %s";                           break;
    case MSG_INDX_COL_NOTIN:  p = "Index column %s is not in table %s";                      break;
    case MSG_INDX_EXIST_YET:  p = "Index entry already exists";                              break;
    case MSG_INIT_FAILED:     p = "Failed to initialize %s processing";                      break;
    case MSG_INT_COL_ERROR:   p = "Internal error for index column %s";                      break;
    case MSG_INT_OVERFLOW:    p = "Integer overflow";                                        break;
    case MSG_INT_ZERO_DIVIDE: p = "Integer divide by zero";                                  break;
    case MSG_INVALID_DISP:    p = "Invalid disposition";                                     break;
    case MSG_INVALID_FTYPE:   p = "SBV: invalid Ftype %d";                                   break;
    case MSG_INVALID_HANDLE:  p = "Invalid handle";                                          break;
    case MSG_INVALID_OPER:    p = "Invalid operator %d for %s";                              break;
    case MSG_INV_COLUMN_TYPE: p = "Invalid type %d for column %s";                           break;
    case MSG_INV_COL_TYPE:    p = "Invalid column type %s";                                  break;
    case MSG_INV_DEF_READ:    p = "Invalid deferred Read rc=%d";                             break;
    case MSG_INV_DIRCOL_OFST: p = "Invalid DIRCOL offset %d";                                break;
    case MSG_INV_MAP_POS:     p = "Invalid map position";                                    break;
    case MSG_INV_RAND_ACC:    p = "Invalid random access to non optimized table";            break;
    case MSG_INV_REC_POS:     p = "Invalid record position";                                 break;
    case MSG_INV_RESULT_TYPE: p = "Invalid result type %s";                                  break;
    case MSG_INV_UPDT_TABLE:  p = "Table %s invalid for update";                             break;
    case MSG_IN_WITHOUT_SUB:  p = "IN or EXISTS without array or subquery";                  break;
    case MSG_KEY_ALLOC_ERR:   p = "Error allocating Key offset block";                       break;
    case MSG_KEY_ALLOC_ERROR: p = "Memory allocation error, Klen=%d n=%d";                   break;
    case MSG_LINE_TOO_LONG:   p = "New line is too long";                                    break;
    case MSG_LIST:            p = "--List--";                                                break;
    case MSG_LOADING_FAILED:  p = "Loading of %s failed";                                    break;
    case MSG_LRECL_TOO_SMALL: p = "Lrecl too small (headlen = %d)";                          break;
    case MSG_MAKE_EMPTY_FILE: p = "Making empty file %s: %s";                                break;
    case MSG_MAKING:          p = "Making";                                                  break;
    case MSG_MALLOC_ERROR:    p = "Memory allocation failed: %s returned Null";              break;
    case MSG_MAP_VIEW_ERROR:  p = "MapViewOfFile %s error rc=%d";                            break;
    case MSG_MAXSIZE_ERROR:   p = "Cannot calculate max size on open table";                 break;
    case MSG_MEM_ALLOC_ERR:   p = "Memory allocation error, %s size=%d";                     break;
    case MSG_MEM_ALLOC_ERROR: p = "Memory allocation error";                                 break;
    case MSG_MISPLACED_QUOTE: p = "Misplaced quote in line %d";                              break;
    case MSG_MISSING_ARG:     p = "Missing argument for operator %d";                        break;
    case MSG_MISSING_FIELD:   p = "Missing field %d in %s line %d";                          break;
    case MSG_MISSING_FNAME:   p = "Missing file name";                                       break;
    case MSG_MISSING_NODE:    p = "Missing %s node in %s";                                   break;
    case MSG_MISSING_ROWNODE: p = "Can't find RowNode for row %d";                           break;
    case MSG_MIS_TAG_LIST:    p = "Missing column tag list";                                 break;
    case MSG_MUL_MAKECOL_ERR: p = "Tabmul MakeCol logical error";                            break;
    case MSG_NAME_CONV_ERR:   p = "Error converting node name";                              break;
    case MSG_NEW_DOC_FAILED:  p = "Cannot create new document";                              break;
    case MSG_NEW_RETURN_NULL: p = "New returned Null in PlugEvalLike";                       break;
    case MSG_NEXT_FILE_ERROR: p = "Couldn't find next file. rc=%d";                          break;
    case MSG_NONCONT_EXCEPT:  p = "Noncontinuable exception";                                break;
    case MSG_NOP_ZLIB_INDEX:  p = "Cannot do indexing on non optimized zlib table";          break;
    case MSG_NOT_A_DBF_FILE:  p = "Not a dBASE dbf file ";                                   break;
    case MSG_NOT_FIXED_LEN:   p = "File %s is not fixed length, len=%d lrecl=%d";            break;
    case MSG_NO_0DH_HEAD:     p = "No 0Dh at end of header (dbc=%d)";                        break;
    case MSG_NO_ACTIVE_DB:    p = "No active database";                                      break;
    case MSG_NO_CHAR_FROM:    p = "Cannot return char value from type %d";                   break;
    case MSG_NO_DATE_FMT:     p = "No date format for valblock of type %d";                  break;
    case MSG_NO_DEF_FNCCOL:   p = "Cannot find default function column";                     break;
    case MSG_NO_DEF_PIVOTCOL: p = "Cannot find default pivot column";                        break;
    case MSG_NO_DIR_INDX_RD:  p = "No direct access of %s tables";                           break;
    case MSG_NO_FEAT_SUPPORT: p = "No %s support in this version";                           break;
    case MSG_NO_FLD_FORMAT:   p = "Missing format for field %d of %s";                       break;
    case MSG_NO_FORMAT_COL:   p = "Cannot format the type COLUMN";                           break;
    case MSG_NO_FORMAT_TYPE:  p = "Cannot set format from type %d";                          break;
    case MSG_NO_INDEX_READ:   p = "No indexed read for multiple tables";                     break;
    case MSG_NO_KEY_COL:      p = "No key columns found";                                    break;
    case MSG_NO_KEY_UPDATE:   p = "Cannot update key names";                                 break;
    case MSG_NO_MAP_INSERT:   p = "MAP incompatible with Insert";                            break;
    case MSG_NO_MATCHING_COL: p = "No matching column %s in %s";                             break;
    case MSG_NO_MATCH_COL:    p = "Cannot find matching column";                             break;
    case MSG_NO_MEMORY:       p = "No memory";                                               break;
    case MSG_NO_MODE_PADDED:  p = "Mode not supported for padded files";                     break;
    case MSG_NO_MUL_VCT:      p = "VCT tables cannot be multiple";                           break;
    case MSG_NO_ODBC_DELETE:  p = "Delete should not be called for ODBC tables";             break;
    case MSG_NO_ODBC_DIRECT:  p = "Direct access of ODBC tables not implemented yet";        break;
    case MSG_NO_ODBC_MUL:     p = "Multiple(2) not supported for ODBC tables";               break;
    case MSG_NO_ODBC_SPECOL:  p = "No ODBC special columns";                                 break;
    case MSG_NO_PART_DEL:     p = "No partial delete of %s files";                           break;
    case MSG_NO_PART_MAP:     p = "Partial mapping not implemented for this OS";             break;
    case MSG_NO_PAR_BLK_INS:  p = "Cannot insert partial block yet";                         break;
    case MSG_NO_PIV_DIR_ACC:  p = "No direct access to PIVOT tables";                        break;
    case MSG_NO_READ_32:      p = "Can't read 32 bytes";                                     break;
    case MSG_NO_RECOV_SPACE:  p = "Cannot recover space in index file";                      break;
    case MSG_NO_ROWID_FOR_AM: p = "Can't get RowID in direct access for tables of type %s";  break;
    case MSG_NO_ROW_NODE:     p = "Row node name is not defined";                            break;
    case MSG_NO_SECTION_NAME: p = "Missing section name";                                    break;
    case MSG_NO_SEC_UPDATE:   p = "Cannot update section names";                             break;
    case MSG_NO_SETPOS_YET:   p = "%s SetPos not implemented yet";                           break;
    case MSG_NO_SPEC_COL:     p = "No MySQL special columns";                                break;
    case MSG_NO_SUB_VAL:      p = "No sub value for array of type %d";                       break;
    case MSG_NO_TABCOL_DATA:  p = "No data found for table %s column %s";                    break;
    case MSG_NO_TABLE_DEL:    p = "Delete not enabled for %s tables   ";                     break;
    case MSG_NO_TAB_DATA:     p = "No data found for table %s";                              break;
    case MSG_NO_VCT_DELETE:   p = "Partial delete not yet implemented for VCT files";        break;
    case MSG_NO_ZIP_DELETE:   p = "Delete Zip files not implemented yet";                    break;
    case MSG_OPENING:         p = "Opening";                                                 break;
    case MSG_OPEN_EMPTY_FILE: p = "Opening empty file %s: %s";                               break;
    case MSG_OPEN_ERROR:      p = "Open error %d in mode %d on %s: ";                        break;
    case MSG_OPEN_ERROR_IS:   p = "Open error on %s: %s";                                    break;
    case MSG_OPEN_MODE_ERROR: p = "Open(%s) error %d on %s";                                 break;
    case MSG_OPEN_STRERROR:   p = "open error: %s";                                          break;
    case MSG_OPTBLK_RD_ERR:   p = "Error reading opt block values: %s";                      break;
    case MSG_OPTBLK_WR_ERR:   p = "Error writing opt block values: %s";                      break;
    case MSG_OPTIMIZING:      p = "Optimizing ";                                             break;
    case MSG_OPT_BMAP_RD_ERR: p = "Error reading opt bitmaps: %s";                           break;
    case MSG_OPT_BMAP_WR_ERR: p = "Error writing opt bitmaps: %s";                           break;
    case MSG_OPT_CANCELLED:   p = "Optimize cancelled by User";                              break;
    case MSG_OPT_DVAL_RD_ERR: p = "Error reading distinct values: %s";                       break;
    case MSG_OPT_DVAL_WR_ERR: p = "Error writing distinct values: %s";                       break;
    case MSG_OPT_HEAD_RD_ERR: p = "Error reading opt file header: %s";                       break;
    case MSG_OPT_HEAD_WR_ERR: p = "Error writing opt file header: %s";                       break;
    case MSG_OPT_LOGIC_ERR:   p = "Logical error in SetBitmap, i=%d";                        break;
    case MSG_OPT_MAX_RD_ERR:  p = "Error reading opt max values: %s";                        break;
    case MSG_OPT_MAX_WR_ERR:  p = "Error writing opt max values: %s";                        break;
    case MSG_OPT_MIN_RD_ERR:  p = "Error reading opt min values: %s";                        break;
    case MSG_OPT_MIN_WR_ERR:  p = "Error writing opt min values: %s";                        break;
    case MSG_OPT_NOT_MATCH:   p = "Non-matching opt file %s";                                break;
    case MSG_PAGE_ERROR:      p = "In page error";                                           break;
    case MSG_PARM_CNT_MISS:   p = "Parameter count mismatch";                                break;
    case MSG_PREC_VBLP_NULL:  p = "ARRAY SetPrecision: Vblp is NULL";                        break;
    case MSG_PRIV_INSTR:      p = "Privileged instruction";                                  break;
    case MSG_PROCADD_ERROR:   p = "Error %d getting address of %s";                          break;
    case MSG_QUERY_CANCELLED: p = "Query Cancelled by User";                                 break;
    case MSG_RANGE_NO_JOIN:   p = "Range is not meant for join index";                       break;
    case MSG_RC_READING:      p = "rc=%d reading table %s";                                  break;
    case MSG_READY:           p = "Ready";                                                   break;
    case MSG_READ_ERROR:      p = "Error reading %s: %s";                                    break;
    case MSG_READ_ONLY:       p = "Cannot modify this read/only protected table";            break;
    case MSG_READ_SEEK_ERROR: p = "Read seek error: %s";                                     break;
    case MSG_REGISTER_ERR:    p = "Unable to register NS with prefix='%s' and href='%s'";    break;
    case MSG_REMOVE_ERROR:    p = "Error removing %s: %s";                                   break;
    case MSG_RENAME_ERROR:    p = "Error renaming %s to %s: %s";                             break;
    case MSG_ROWID_NOT_IMPL:  p = "RowNumber not implemented for tables of type %s";         break;
    case MSG_SEC_KEY_FIRST:   p = "Section and key names must come first on Insert";         break;
    case MSG_SEC_NAME_FIRST:  p = "Section name must come first on Insert";                  break;
    case MSG_SEP_IN_FIELD:    p = "Field %d contains the separator character";               break;
    case MSG_SEQUENCE_ERROR:  p = "Sequence error on statement allocation";                  break;
    case MSG_SETEOF_ERROR:    p = "Error %d in SetEndOfFile";                                break;
    case MSG_SETRECPOS_NIY:   p = "SetRecpos not implemented for this table type";           break;
    case MSG_SET_STR_TRUNC:   p = "SetValue: String would be truncated";                     break;
    case MSG_SFP_ERROR:       p = "SetFilePointer error: %s";                                break;
    case MSG_SHARED_LIB_ERR:  p = "Error loading shared library %s: %s";                     break;
    case MSG_SINGLE_STEP:     p = "Single step";                                             break;
    case MSG_SORTING_VAL:     p = "Sorting %d values";                                       break;
    case MSG_SPCOL_READONLY:  p = "Special column %s is Read Only";                          break;
    case MSG_SQL_CONF_ERROR:  p = "SQL Error: SQL_CONFORMANCE";                              break;
    case MSG_SRCH_CLOSE_ERR:  p = "Couldn't close search handle";                            break;
    case MSG_SRC_TABLE_UNDEF: p = "Source table is not defined";                             break;
    case MSG_STACK_OVERFLOW:  p = "Stack overflow";                                          break;
    case MSG_TABDIR_READONLY: p = "DIR tables are read/only";                                break;
    case MSG_TABLE_NOT_OPT:   p = "Not an optimizable table";                                break;
    case MSG_TABLE_NO_INDEX:  p = "Table %s is not indexable";                               break;
    case MSG_TABLE_READ_ONLY: p = "%s tables are read only   ";                              break;
    case MSG_TABMUL_READONLY: p = "Multiple tables are read/only";                           break;
    case MSG_TOO_MANY_FIELDS: p = "Too many fields line %d of %s";                           break;
    case MSG_TOO_MANY_JUMPS:  p = "Too many jump levels";                                    break;
    case MSG_TOO_MANY_KEYS:   p = "Too many keys (%d)";                                      break;
    case MSG_TO_BLK_IS_NULL:  p = "To Blk is NULL";                                          break;
    case MSG_TRUNCATE_ERROR:  p = "truncate error: %s";                                      break;
    case MSG_TRUNC_BY_ESTIM:  p = "truncated by Estimate";                                   break;
    case MSG_TYPE_MISMATCH:   p = "Key and source are not of the same type";                 break;
    case MSG_TYPE_VALUE_ERR:  p = "Column %s type(%s)/value(%s) mismatch";                   break;
    case MSG_UNBALANCE_QUOTE: p = "Unbalanced quote in line %d";                             break;
    case MSG_UNDEFINED_AM:    p = "COLBLK %s: undefined Access Method";                      break;
    case MSG_UNKNOWN_EXCPT:   p = "Unknown exception";                                       break;
    case MSG_UNMATCH_FIL_ARG: p = "Unmatched filter argument";                               break;
    case MSG_UPDATE_ERROR:    p = "Error updating %s";                                       break;
    case MSG_UPD_ZIP_NOT_IMP: p = "Updating ZDOS tables not implemented yet";                break;
    case MSG_VALSTR_TOO_LONG: p = "Value %s too long for string of length %d";               break;
    case MSG_VALTYPE_NOMATCH: p = "Non matching Value types";                                break;
    case MSG_VALUE_ERROR:     p = "Column %s: value is null";                                break;
    case MSG_VALUE_TOO_BIG:   p = "Value %lld too big for column %s";                        break;
    case MSG_VALUE_TOO_LONG:  p = "Value %s too long for column %s of length %d";            break;
    case MSG_VAL_ALLOC_ERR:   p = "Cannot allocate value node";                              break;
    case MSG_VIR_NO_DELETE:   p = "Delete not allowed for %s tables";                        break;
    case MSG_VIR_READ_ONLY:   p = "Virtual %s tables are read only";                         break;
    case MSG_VOID_FIRST_ARG:  p = "First argument should not be void";                       break;
    case MSG_WORK_AREA:       p = "Work area: %s";                                           break;
    case MSG_WRITE_SEEK_ERR:  p = "Write seek error: %s";                                    break;
    case MSG_WRITE_STRERROR:  p = "Error writing %s: %s";                                    break;
    case MSG_WRITING:         p = "Writing";                                                 break;
    case MSG_WRITING_ERROR:   p = "Error writing to %s: %s";                                 break;
    case MSG_WS_CONV_ERR:     p = "Error converting %s to WS";                               break;
    case MSG_XCOL_MISMATCH:   p = "Column %s mismatch in index";                             break;
    case MSG_XFILE_READERR:   p = "Error %d reading index file";                             break;
    case MSG_XFILE_WRITERR:   p = "Error writing index file: %s";                            break;
    case MSG_XMLTAB_INIT_ERR: p = "Error initializing XML table";                            break;
    case MSG_XML_INIT_ERROR:  p = "Error initializing new XML file";                         break;
    case MSG_XPATH_CNTX_ERR:  p = "Unable to create new XPath context";                      break;
    case MSG_XPATH_EVAL_ERR:  p = "Unable to evaluate xpath location '%s'";                  break;
    case MSG_XPATH_NOT_SUPP:  p = "Unsupported Xpath for column %s";                         break;
    case MSG_ARG_IS_NULL:     p = "Argument is NULL";                                        break;
