/* The non-ASCII literal strings in this file are encoded in the iso-8859-1 / latin-1 character set
 * (https://en.wikipedia.org/wiki/ISO/IEC_8859-1) */
    case MSG_ACCESS_VIOLATN:  p = "Violation acc\xe8s m\xe9moire";                                                    break;
    case MSG_ADD_BAD_TYPE:    p = "Ajout d'une valeur de type %s non conforme dans un tableau %s";                    break;
    case MSG_ALLOC_ERROR:     p = "Erreur d'allocation de %s";                                                        break;
    case MSG_ANSWER_TYPE:     p = "R\xe9ponse de type";                                                               break;
    case MSG_API_CONF_ERROR:  p = "Erreur SQL: API_CONFORMANCE";                                                      break;
    case MSG_APPL_NOT_INIT:   p = "Application non initialis\xe9""e";                                                 break;
    case MSG_ARRAY_BNDS_EXCD: p = "Hors limite de tableau";                                                           break;
    case MSG_BAD_ARRAY_OPER:  p = "Les tableaux doivent utiliser l'op\xe9rateur IN";                                  break;
    case MSG_BAD_ARRAY_TYPE:  p = "Type=%d invalide pour un tableau";                                                 break;
    case MSG_BAD_ARRAY_VAL:   p = "Les tableaux doivent avoir le m\xeame nombre de valeurs";                          break;
    case MSG_BAD_BIN_FMT:     p = "Format invalide %c pour la colonne BIN %s";                                        break;
    case MSG_BAD_BLK_ESTIM:   p = "Nombre de blocs sup\xe9rieur \xe0 l'estimation";                                   break;
    case MSG_BAD_BLK_SIZE:    p = "Taille du bloc %d non conforme";                                                   break;
    case MSG_BAD_BYTE_NUM:    p = "Le nombre d'octets \xe9""crits est faux";                                          break;
    case MSG_BAD_BYTE_READ:   p = "Le nombre d'octets lus est faux";                                                  break;
    case MSG_BAD_COL_TYPE:    p = "Type invalide %s pour la colonne %s";                                              break;
    case MSG_BAD_COL_XPATH:   p = "Xpath invalide colonne %s de la table HTML %s";                                    break;
    case MSG_BAD_CONST_TYPE:  p = "Type=%d invalide pour une constante";                                              break;
    case MSG_BAD_CONV_TYPE:   p = "Convertion de type invalide %d";                                                   break;
    case MSG_BAD_DATETIME:    p = "Valeur date/temps invalide";                                                       break;
    case MSG_BAD_DBF_FILE:    p = "Le fichier DBF %s est alt\xe9r\xe9";                                               break;
    case MSG_BAD_DBF_REC:     p = "Fichier DBF %s alt\xe9r\xe9 enregistrement %d";                                    break;
    case MSG_BAD_DBF_TYPE:    p = "Type DBF %c non support\xe9 colonne %s";                                           break;
    case MSG_BAD_DIRECTORY:   p = "R\xe9pertoire invalide %s: %s";                                                    break;
    case MSG_BAD_FIELD_RANK:  p = "Rang %d invalide pour la colonne %s";                                              break;
    case MSG_BAD_FIELD_TYPE:  p = "Mauvais type de champ %s";                                                         break;
    case MSG_BAD_FILE_HANDLE: p = "Handle de fichier invalide: %s";                                                   break;
    case MSG_BAD_FILTER:      p = "Mauvais filtre: Opc=%d B_T=%d %d Type=%d %d";                                      break;
    case MSG_BAD_FILTER_CONV: p = "Conversion filtre incorrecte, B_T=%d,%d";                                          break;
    case MSG_BAD_FILTER_OP:   p = "Op\xe9rateur de filtre invalide %d";                                               break;
    case MSG_BAD_FLD_FORMAT:  p = "Format invalide pour le champs %d de %s";                                          break;
    case MSG_BAD_FLD_LENGTH:  p = "Champs %s trop long (%s --> %d) ligne %d de %s";                                   break;
    case MSG_BAD_FREQ_SET:    p = "Sp\xe9""cification erronn\xe9""e de Freq pour la colonne %s";                      break;
    case MSG_BAD_FUNC_MODE:   p = "%s: mode invalide %d";                                                             break;
    case MSG_BAD_HANDLE_VAL:  p = "Valeur Handle invalide";                                                           break;
    case MSG_BAD_HEADER:      p = "Fichier %s: bloc en-t\xeate alt\xe9r\xe9";                                         break;
    case MSG_BAD_HEAD_END:    p = "Lecture fin d'en-t\xeate impossible";                                              break;
    case MSG_BAD_INDEX_FILE:  p = "Fichier index %s corrompu";                                                        break;
    case MSG_BAD_LINEFLD_FMT: p = "Format invalide ligne %d champs %d de %s";                                         break;
    case MSG_BAD_LINE_LEN:    p = "Longueur ligne non \xe9gale \xe0 Lrecl";                                           break;
    case MSG_BAD_LRECL:       p = "Disparit\xe9 lrecl table/fichier (%d,%hd)";                                        break;
    case MSG_BAD_NODE_TYPE:   p = "Type noeud erron\xe9 pour la table";                                               break;
    case MSG_BAD_OFFSET_VAL:  p = "Nul offset invalide pour une table CSV";                                           break;
    case MSG_BAD_OPEN_MODE:   p = "Mode d'ouverture invalide %d";                                                     break;
    case MSG_BAD_PARAM_TYPE:  p = "%.8s: Param\xe8tre de type=%d invalide";                                           break;
    case MSG_BAD_PARM_COUNT:  p = "Nombre de param\xe8tres incoh\xe9rent";                                            break;
    case MSG_BAD_QUOTE_FIELD: p = "Quote manquante dans %s champs %d ligne %d";                                       break;
    case MSG_BAD_READ_NUMBER: p = "Mauvais nombre %d de valeurs lues dans %s";                                        break;
    case MSG_BAD_RECFM:       p = "Recfm type %d invalide pour DOSCOL";                                               break;
    case MSG_BAD_RECFM_VAL:   p = "Valeur invalide %d de Recfm";                                                      break;
    case MSG_BAD_SET_CASE:    p = "La casse d'un tableau ne peut pas passer de non respect \xe0 respecter";           break;
    case MSG_BAD_SET_STRING:  p = "SetValue: appel invalide pour STRING";                                             break;
    case MSG_BAD_SPECIAL_COL: p = "Colonne sp\xe9""ciale invalide %s";                                                break;
    case MSG_BAD_SPEC_COLUMN: p = "Colonne sp\xe9""ciale invalide pour ce type de table";                             break;
    case MSG_BAD_TABLE_TYPE:  p = "Type invalide %s pour la table %s";                                                break;
    case MSG_BAD_TYPE_LIKE:   p = "Type(%d)= %d invalide pour LIKE";                                                  break;
    case MSG_BAD_VALBLK_INDX: p = "Valeur hors limites de l'index du bloc de valeurs";                                break;
    case MSG_BAD_VALBLK_TYPE: p = "Type=%d invalide pour un bloc de valeurs";                                         break;
    case MSG_BAD_VALNODE:     p = "Type %d invalide pour le noeud valeur colonne %s";                                 break;
    case MSG_BAD_VALUE_TYPE:  p = "Type de valeur invalide %d";                                                       break;
    case MSG_BAD_VAL_UPDATE:  p = "Impossible de d\xe9terminer quelle valeur %s doit \xeatre mise \xe0 jour";         break;
    case MSG_BAS_NS_LIST:     p = "Format invalide de la liste des espace-noms";                                      break;
    case MSG_BIN_F_TOO_LONG:  p = "Valeur trop longue pour le champ %s (%d --> %d)";                                  break;
    case MSG_BIN_MODE_FAIL:   p = "Echec mode binaire: %s";                                                           break;
    case MSG_BLKTYPLEN_MISM:  p = "Disparit\xe9 types/longueurs de bloc dans SetValue";                               break;
    case MSG_BLK_IS_NULL:     p = "Blk est nul";                                                                      break;
    case MSG_BREAKPOINT:      p = "Point de contr\xf4le";                                                             break;
    case MSG_BUILD_INDEX:     p = "Construction index %s sur %s";                                                     break;
    case MSG_CANNOT_OPEN:     p = "Ouverture impossible de %s";                                                       break;
    case MSG_CHSIZE_ERROR:    p = "Erreur dans chsize: %s";                                                           break;
    case MSG_COL_ALLOC_ERR:   p = "Allocation impossible du noeud colonne";                                           break;
    case MSG_COL_ISNOT_TABLE: p = "La colonne %s n'est pas dans la table %s";                                         break;
    case MSG_COL_NOT_SORTED:  p = "La colonne %s de la table %s n'est pas tri\xe9""e";                                break;
    case MSG_COL_NUM_MISM:    p = "Disparit\xe9 du nombre de colonnes";                                               break;
    case MSG_COM_ERROR:       p = "Erreur Com";                                                                       break;
    case MSG_CONCAT_SUBNODE:  p = "Concat\xe9nation de sous-noeuds impossible";                                       break;
    case MSG_CONNECT_CANCEL:  p = "Connection interrompue par l'utilisateur";                                         break;
    case MSG_CONTROL_C_EXIT:  p = "Exit par Ctrl-C";                                                                  break;
    case MSG_DATABASE_LOADED: p = "Base de donn\xe9""es %s charg\xe9""e";                                             break;
    case MSG_DATA_MISALIGN:   p = "Mauvais alignement pour ce type de donn\xe9""es";                                  break;
    case MSG_DBASE_FILE:      p = "Fichier dBASE dbf: ";                                                              break;
    case MSG_DEF_ALLOC_ERROR: p = "Erreur d'allocation de la classe DEF %s";                                          break;
    case MSG_DEL_FILE_ERR:    p = "Erreur \xe0 l'effacement de %s";                                                   break;
    case MSG_DEL_READ_ERROR:  p = "Delete: erreur en lecture req=%d len=%d";                                          break;
    case MSG_DEL_WRITE_ERROR: p = "Delete: erreur en \xe9""criture: %s";                                              break;
    case MSG_DEPREC_FLAG:     p = "Option Flag p\xe9rim\xe9""e, utiliser Coltype";                                    break;
    case MSG_DLL_LOAD_ERROR:  p = "Erreur %d au chargement du module %s";                                             break;
    case MSG_DOM_NOT_SUPP:    p = "MS-DOM non support\xe9 par cette version";                                         break;
    case MSG_DVAL_NOTIN_LIST: p = "Valeur %s non trouv\xe9""e dans la liste des valeurs distinctes de la colonne %s"; break;
    case MSG_EMPTY_DOC:       p = "Document vide";                                                                    break;
    case MSG_EMPTY_FILE:      p = "%s du fichier vide %s: ";                                                          break;
    case MSG_EOF_AFTER_LINE:  p = "Fin de fichier apr\xe8s la ligne %d";                                              break;
    case MSG_EOF_INDEX_FILE:  p = "EOF lisant le fichier index";                                                      break;
    case MSG_ERROR_IN_LSK:    p = "Erreur %d dans lseek64";                                                           break;
    case MSG_ERROR_IN_SFP:    p = "Erreur %d dans SetFilePointer";                                                    break;
    case MSG_ERR_READING_REC: p = "Erreur lisant l'enregistrement %d de %s";                                          break;
    case MSG_FAIL_ADD_NODE:   p = "L'ajout du noeud %s dans la table a \xe9""chou\xe9";                               break;
    case MSG_FETCH_NO_RES:    p = "Fetch: Pas de R\xe9sultats";                                                       break;
    case MSG_FIELD_TOO_LONG:  p = "Valeur trop longue pour le champs %d ligne %d";                                    break;
    case MSG_FILELEN_ERROR:   p = "Erreur dans %s pour %s";                                                           break;
    case MSG_FILE_IS_EMPTY:   p = "Le fichier %s est vide";                                                           break;
    case MSG_FILE_MAP_ERR:    p = "Erreur de File mapping";                                                           break;
    case MSG_FILE_MAP_ERROR:  p = "CreateFileMapping %s erreur rc=%d";                                                break;
    case MSG_FILE_OPEN_YET:   p = "Fichier %s d\xe9j\xe0 ouvert";                                                     break;
    case MSG_FILE_UNFOUND:    p = "Fichier %s non trouv\xe9";                                                         break;
    case MSG_FLD_TOO_LNG_FOR: p = "Champs %d trop long pour %s ligne %d de %s";                                       break;
    case MSG_FLT_BAD_RESULT:  p = "Virgule flottante: r\xe9sultat inexacte";                                          break;
    case MSG_FLT_DENORMAL_OP: p = "Op\xe9rande virgule flottante non normalis\xe9";                                   break;
    case MSG_FLT_INVALID_OP:  p = "Op\xe9ration virgule flottante invalide";                                          break;
    case MSG_FLT_OVERFLOW:    p = "D\xe9passement de capacit\xe9 virgule flottante";                                  break;
    case MSG_FLT_STACK_CHECK: p = "Virgule flottante: Erreur de la pile";                                             break;
    case MSG_FLT_UNDERFLOW:   p = "Sous-d\xe9passement de capacit\xe9 virgule flottante";                             break;
    case MSG_FLT_ZERO_DIVIDE: p = "Virgule flottante: division par z\xe9ro";                                          break;
    case MSG_FMT_WRITE_NIY:   p = "L'\xe9""criture des fichiers %s n'est pas encore impl\xe9ment\xe9""e";             break;
    case MSG_FOXPRO_FILE:     p = "Fichier FoxPro: ";                                                                 break;
    case MSG_FPUTS_ERROR:     p = "Erreur dans fputs: %s";                                                            break;
    case MSG_FSEEK_ERROR:     p = "Erreur dans fseek: %s";                                                            break;
    case MSG_FSETPOS_ERROR:   p = "Erreur dans fseek pour i=%d";                                                      break;
    case MSG_FTELL_ERROR:     p = "Erreur dans ftell enregistrement=%d: %s";                                          break;
    case MSG_FUNCTION_ERROR:  p = "Erreur dans %s: %d";                                                               break;
    case MSG_FUNC_ERRNO:      p = "Erreur %d dans %s";                                                                break;
    case MSG_FUNC_ERROR:      p = "Erreur dans %s";                                                                   break;
    case MSG_FUNC_ERR_S:      p = "Erreur dans %s: %s";                                                               break;
    case MSG_FWRITE_ERROR:    p = "Erreur dans fwrite: %s";                                                           break;
    case MSG_GET_DIST_VALS:   p = "R\xe9""cup\xe9ration des valeurs distinctes de ";                                 break;
    case MSG_GET_FUNC_ERR:    p = "Erreur en recherche de la fonction %s: %s";                                        break;
    case MSG_GLOBAL_ERROR:    p = "Erreur d'allocation de Global (taille=%d)\n";                                      break;
    case MSG_GUARD_PAGE:      p = "Violation de page de garde";                                                       break;
    case MSG_GZOPEN_ERROR:    p = "gzopen %s: erreur %d sur %s";                                                      break;
    case MSG_ILLEGAL_INSTR:   p = "Instruction ill\xe9gale";                                                          break;
    case MSG_ILL_FILTER_CONV: p = "Conversion implicite ill\xe9gale dans un filtre";                                  break;
    case MSG_INDEX_NOT_UNIQ:  p = "L'index n'est pas Unique";                                                         break;
    case MSG_INDEX_YET_ON:    p = "L'index %s existe d\xe9j\xe0 sur %s";                                              break;
    case MSG_INDX_COL_NOTIN:  p = "La colonne index %s n'existe pas dans la table %s";                                break;
    case MSG_INDX_EXIST_YET:  p = "L'entr\xe9""e index existe d\xe9j\xe0";                                            break;
    case MSG_INIT_FAILED:     p = "L'initialisation de %s a \xe9""chou\xe9";                                          break;
    case MSG_INT_COL_ERROR:   p = "Erreur interne sur la colonne index %s";                                           break;
    case MSG_INT_OVERFLOW:    p = "D\xe9passement de capacit\xe9 sur entier";                                         break;
    case MSG_INT_ZERO_DIVIDE: p = "Division enti\xe8re par z\xe9ro";                                                  break;
    case MSG_INVALID_DISP:    p = "Disposition invalide";                                                             break;
    case MSG_INVALID_FTYPE:   p = "SBV: Ftype %d invalide";                                                           break;
    case MSG_INVALID_HANDLE:  p = "Poign\xe9""e invalide";                                                            break;
    case MSG_INVALID_OPER:    p = "Op\xe9rateur invalide %d pour %s";                                                 break;
    case MSG_INV_COLUMN_TYPE: p = "Type %d Invalide pour la colonne %s";                                              break;
    case MSG_INV_COL_TYPE:    p = "Type de colonne %s invalide";                                                      break;
    case MSG_INV_DEF_READ:    p = "Lecture diff\xe9r\xe9""e invalide rc=%d";                                          break;
    case MSG_INV_DIRCOL_OFST: p = "Offset invalide pour une colonne DIR";                                             break;
    case MSG_INV_MAP_POS:     p = "Position m\xe9moire invalide";                                                     break;
    case MSG_INV_RAND_ACC:    p = "L'acc\xe8s al\xe9""atoire d'une table non optimis\xe9""e est impossible";          break;
    case MSG_INV_REC_POS:     p = "Position d'enregistrement invalide";                                               break;
    case MSG_INV_RESULT_TYPE: p = "Type de r\xe9sultat invalide %s";                                                  break;
    case MSG_INV_UPDT_TABLE:  p = "Table %s invalide pour Update";                                                    break;
    case MSG_IN_WITHOUT_SUB:  p = "IN ou EXISTS sans tableau ou subquery";                                            break;
    case MSG_KEY_ALLOC_ERR:   p = "Erreur d'allocation d'un bloc offset cl\xe9";                                      break;
    case MSG_KEY_ALLOC_ERROR: p = "Erreur d'allocation m\xe9moire, Klen=%d n=%d";                                     break;
    case MSG_LINE_TOO_LONG:   p = "La nouvelle ligne est trop longue";                                                break;
    case MSG_LIST:            p = "--Liste--";                                                                        break;
    case MSG_LOADING_FAILED:  p = "Le chargement de %s a \xe9""chou\xe9";                                             break;
    case MSG_LRECL_TOO_SMALL: p = "Lrecl trop petit (longueur en-t\xeate = %d)";                                      break;
    case MSG_MAKE_EMPTY_FILE: p = "G\xe9n\xe9ration du fichier vide %s: %s";                                          break;
    case MSG_MAKING:          p = "G\xe9n\xe9ration";                                                                 break;
    case MSG_MALLOC_ERROR:    p = "Allocation m\xe9moire impossible par %s";                                          break;
    case MSG_MAP_VIEW_ERROR:  p = "MapViewOfFile %s erreur rc=%d";                                                    break;
    case MSG_MAXSIZE_ERROR:   p = "Maxsize incalculable sur table ouverte";                                           break;
    case MSG_MEM_ALLOC_ERR:   p = "Erreur d'allocation m\xe9moire, taille %s = %d";                                   break;
    case MSG_MEM_ALLOC_ERROR: p = "Erreur d'allocation m\xe9moire";                                                   break;
    case MSG_MISPLACED_QUOTE: p = "Appostrophe mal plac\xe9""e ligne %d";                                             break;
    case MSG_MISSING_ARG:     p = "Argument manquant pour l'op\xe9rateur %d";                                         break;
    case MSG_MISSING_FIELD:   p = "Champs %d manquant dans %s ligne %d";                                              break;
    case MSG_MISSING_FNAME:   p = "Nom du fichier manquant";                                                          break;
    case MSG_MISSING_NODE:    p = "Noeud %s manquant dans %s";                                                        break;
    case MSG_MISSING_ROWNODE: p = "Impossible de trouver le noeud de la ligne %d";                                    break;
    case MSG_MIS_TAG_LIST:    p = "Liste des balises colonne manquante";                                              break;
    case MSG_MUL_MAKECOL_ERR: p = "Erreur logique dans TABMUL::MakeCol";                                              break;
    case MSG_NAME_CONV_ERR:   p = "Erreur de convertion du nom de noeud";                                             break;
    case MSG_NEW_DOC_FAILED:  p = "Impossible de cr\xe9""er le nouveau document";                                     break;
    case MSG_NEW_RETURN_NULL: p = "NULL renvoy\xe9 par New dans PlugEvalLike";                                        break;
    case MSG_NEXT_FILE_ERROR: p = "Erreur en recherche du fichier suivant. rc=%s";                                    break;
    case MSG_NONCONT_EXCEPT:  p = "Exception non-continuable";                                                        break;
    case MSG_NOP_ZLIB_INDEX:  p = "L'indexage d'une table zlib non optimis\xe9""e est impossible";                    break;
    case MSG_NOT_A_DBF_FILE:  p = "Le fichier n'a pas le format dBASE dbf ";                                          break;
    case MSG_NOT_FIXED_LEN:   p = "Fichier %s non fixe, len=%d lrecl=%d";                                             break;
    case MSG_NO_0DH_HEAD:     p = "0DH manquant en fin d'en-t\xeate (dbc=%d)";                                        break;
    case MSG_NO_ACTIVE_DB:    p = "Pas de base de donn\xe9""es active";                                               break;
    case MSG_NO_CHAR_FROM:    p = "Conversion de type %d en caract\xe8res impossible";                                break;
    case MSG_NO_DATE_FMT:     p = "Pas de format date pour le valblock de type %d";                                   break;
    case MSG_NO_DEF_FNCCOL:   p = "Colonne fonction par d\xe9""faut introuvable";                                     break;
    case MSG_NO_DEF_PIVOTCOL: p = "Colonne pivot par d\xe9""faut introuvable";                                        break;
    case MSG_NO_DIR_INDX_RD:  p = "Pas d'acc\xe8s directe des tables %s";                                             break;
    case MSG_NO_FEAT_SUPPORT: p = "%s non support\xe9 dans cette version";                                            break;
    case MSG_NO_FLD_FORMAT:   p = "Format absent pour le champs %d de %s";                                            break;
    case MSG_NO_FORMAT_COL:   p = "Type COLUMN informattable";                                                        break;
    case MSG_NO_FORMAT_TYPE:  p = "Le format ne peut pas \xeatre d\xe9""fini \xe0 partir du type %d";                 break;
    case MSG_NO_INDEX_READ:   p = "Pas d'acc\xe8s directe des tables multiples";                                      break;
    case MSG_NO_KEY_COL:      p = "Pas de colonne cl\xe9 trouv\xe9""e";                                               break;
    case MSG_NO_KEY_UPDATE:   p = "Le nom des cl\xe9s ne peut pas \xeatre modifi\xe9";                                break;
    case MSG_NO_MAP_INSERT:   p = "MAP incompatible avec Insert";                                                     break;
    case MSG_NO_MATCHING_COL: p = "Pas de colonne correspondant \xe0 %s dans %s";                                     break;
    case MSG_NO_MATCH_COL:    p = "Colonne correspondante introuvable";                                               break;
    case MSG_NO_MEMORY:       p = "M\xe9moire pleine";                                                                break;
    case MSG_NO_MODE_PADDED:  p = "Mode non support\xe9 pour les fichiers 'padded'";                                  break;
    case MSG_NO_MUL_VCT:      p = "Les tables VCT ne peuvent pas \xeatre multiples";                                  break;
    case MSG_NO_ODBC_DELETE:  p = "Delete ne devrait pas \xeatre appel\xe9 pour les tables ODBC";                     break;
    case MSG_NO_ODBC_DIRECT:  p = "Acc\xe8s directe des tables ODBC non encore impl\xe9ment\xe9";                     break;
    case MSG_NO_ODBC_MUL:     p = "Multiple(2) non support\xe9 pour les tables ODBC";                                 break;
    case MSG_NO_ODBC_SPECOL:  p = "Pas de colonne sp\xe9""ciale ODBC";                                                  break;
    case MSG_NO_PART_DEL:     p = "Delete partiel des fichier %s impossible";                                         break;
    case MSG_NO_PART_MAP:     p = "Mapping partiel non impl\xe9ment\xe9 pour cet OS";                                 break;
    case MSG_NO_PAR_BLK_INS:  p = "Insertion de bloc partiel impossible";                                             break;
    case MSG_NO_PIV_DIR_ACC:  p = "Pas d'acc\xe8s directe aux tables PIVOT";                                          break;
    case MSG_NO_READ_32:      p = "Lecture de 32 octets impossible";                                                  break;
    case MSG_NO_RECOV_SPACE:  p = "Espace non recouvrable dans le fichier index";                                     break;
    case MSG_NO_ROWID_FOR_AM: p = "Acc\xe8s direct impossible de ROWID pour les tables de type %s";                   break;
    case MSG_NO_ROW_NODE:     p = "Le nom du Rownode n'est pas d\xe9""fini";                                          break;
    case MSG_NO_SECTION_NAME: p = "Nom de section manquant";                                                          break;
    case MSG_NO_SEC_UPDATE:   p = "Les noms de section ne peuvent pas \xeatre modifi\xe9s";                           break;
    case MSG_NO_SETPOS_YET:   p = "SetPos pas encore impl\xe9ment\xe9 pour les fichier %s";                           break;
    case MSG_NO_SPEC_COL:     p = "Pas de colonne sp\xe9""ciales MYSQL";                                              break;
    case MSG_NO_SUB_VAL:      p = "Pas de sous-value d'un tableau de type %d";                                        break;
    case MSG_NO_TABCOL_DATA:  p = "Pas de donn\xe9""es pour la table %s colonne %s";                                  break;
    case MSG_NO_TABLE_DEL:    p = "Delete non autoris\xe9 pour les tables %s   ";                                     break;
    case MSG_NO_TAB_DATA:     p = "Pas de donn\xe9""es pour la table %s";                                             break;
    case MSG_NO_VCT_DELETE:   p = "D\xe9l\xe9tion Partielle non impl\xe9ment\xe9""e pour les fichiers VCT";           break;
    case MSG_NO_ZIP_DELETE:   p = "Delete sur fichier Zip non encore implement\xe9";                                  break;
    case MSG_OPENING:         p = "Ouverture";                                                                        break;
    case MSG_OPEN_EMPTY_FILE: p = "Ouverture du fichier vide %s: %s";                                                 break;
    case MSG_OPEN_ERROR:      p = "Erreur d'ouverture %d en mode %d sur %s: ";                                        break;
    case MSG_OPEN_ERROR_IS:   p = "Erreur \xe0 l'ouverture de %s: %s";                                                break;
    case MSG_OPEN_MODE_ERROR: p = "Erreur d'ouverture(%s) %d sur %s";                                                 break;
    case MSG_OPEN_STRERROR:   p = "Erreur \xe0 l'ouverture: %s";                                                      break;
    case MSG_OPTBLK_RD_ERR:   p = "Erreur \xe0 la lecture d'un bloc optimisation: %s";                                break;
    case MSG_OPTBLK_WR_ERR:   p = "Erreur \xe0 l'\xe9""criture d'un bloc optimisation: %s";                           break;
    case MSG_OPTIMIZING:      p = "Optimisation de ";                                                                 break;
    case MSG_OPT_BMAP_RD_ERR: p = "Erreur en lecture des bitmaps d'optimisation: %s";                                 break;
    case MSG_OPT_BMAP_WR_ERR: p = "Erreur en \xe9""criture des bitmaps d'optimisation: %s";                           break;
    case MSG_OPT_CANCELLED:   p = "Optimisation interrompue par l'utilisateur";                                       break;
    case MSG_OPT_DVAL_RD_ERR: p = "Erreur en lecture des valeurs distinctes: %s";                                     break;
    case MSG_OPT_DVAL_WR_ERR: p = "Erreur en \xe9""criture des valeurs distinctes: %s";                               break;
    case MSG_OPT_HEAD_RD_ERR: p = "Erreur en lecture de l'ent\xeate du fichier opt: %s";                              break;
    case MSG_OPT_HEAD_WR_ERR: p = "Erreur en \xe9""criture de l'ent\xeate du fichier opt: %s";                        break;
    case MSG_OPT_LOGIC_ERR:   p = "Erreur logique dans SetBitmap, i=%d";                                              break;
    case MSG_OPT_MAX_RD_ERR:  p = "Erreur en lecture des valeurs maxi: %s";                                           break;
    case MSG_OPT_MAX_WR_ERR:  p = "Erreur en \xe9""criture des valeurs maxi: %s";                                     break;
    case MSG_OPT_MIN_RD_ERR:  p = "Erreur en lecture des valeurs mini: %s";                                           break;
    case MSG_OPT_MIN_WR_ERR:  p = "Erreur en \xe9""criture des valeurs mini: %s";                                     break;
    case MSG_OPT_NOT_MATCH:   p = "Le fichier opt %s n'est pas \xe0 jour";                                            break;
    case MSG_PAGE_ERROR:      p = "Erreur de pagination";                                                             break;
    case MSG_PARM_CNT_MISS:   p = "Disparit\xe9 du nombre de Param\xe8tres";                                          break;
    case MSG_PREC_VBLP_NULL:  p = "ARRAY SetPrecision: Vblp est NULL";                                                break;
    case MSG_PRIV_INSTR:      p = "Instruction privil\xe9gi\xe9""e";                                                  break;
    case MSG_PROCADD_ERROR:   p = "Erreur %d sur l'adresse de %s";                                                    break;
    case MSG_QUERY_CANCELLED: p = "Requ\xeate interrompue par l'utilisateur";                                         break;
    case MSG_RANGE_NO_JOIN:   p = "Range non compatible avec les index de jointure";                                  break;
    case MSG_RC_READING:      p = "rc=%d en lecture de la table %s";                                                  break;
    case MSG_READY:           p = "Pr\xeat";                                                                          break;
    case MSG_READ_ERROR:      p = "Erreur en lecture sur %s: %s";                                                     break;
    case MSG_READ_ONLY:       p = "Cette table prot\xe9g\xe9""e en lecture seule ne peut \xeatre modifi\xe9""e";      break;
    case MSG_READ_SEEK_ERROR: p = "Erreur de recherche en lecture: %s";                                               break;
    case MSG_REGISTER_ERR:    p = "Enregistrement NS impossible, pr\xe9""fix='%s' et href='%s'";                      break;
    case MSG_REMOVE_ERROR:    p = "Erreur en supprimant %s: %s";                                                      break;
    case MSG_RENAME_ERROR:    p = "Erreur renommant %s en %s: %s";                                                    break;
    case MSG_ROWID_NOT_IMPL:  p = "RowNumber non impl\xe9ment\xe9 pour les tables de type %s";                        break;
    case MSG_SEC_KEY_FIRST:   p = "Les sections et cl\xe9s doivent \xeatre ins\xe9r\xe9""es en premier";              break;
    case MSG_SEC_NAME_FIRST:  p = "Le nom de section doit \xeatre en t\xeate de liste en insertion";                  break;
    case MSG_SEP_IN_FIELD:    p = "Le champ %d contient le caract\xe8re s\xe9parateur";                               break;
    case MSG_SEQUENCE_ERROR:  p = "HSTMT: Allocation hors s\xe9quence";                                               break;
    case MSG_SETEOF_ERROR:    p = "Erreur %d dans SetEndOfFile";                                                      break;
    case MSG_SETRECPOS_NIY:   p = "SetRecpos non impl\xe9ment\xe9 pour ce type de table";                             break;
    case MSG_SET_STR_TRUNC:   p = "SetValue: Cha\xeene de caract\xe8res tronqu\xe9""e";                               break;
    case MSG_SFP_ERROR:       p = "Erreur sur SetFilePointer: %s";                                                    break;
    case MSG_SHARED_LIB_ERR:  p = "Erreur au chargement de la librairie partag\xe9""e %s: %s";                        break;
    case MSG_SINGLE_STEP:     p = "Pas \xe0 pas";                                                                     break;
    case MSG_SORTING_VAL:     p = "Tri de %d valeurs";                                                                break;
    case MSG_SPCOL_READONLY:  p = "La colonne sp\xe9""ciale %s est en lecture seulement";                             break;
    case MSG_SQL_CONF_ERROR:  p = "Erreur SQL: SQL_CONFORMANCE";                                                      break;
    case MSG_SRCH_CLOSE_ERR:  p = "Erreur \xe0 la fermeture de l'Handle de recherche";                                break;
    case MSG_SRC_TABLE_UNDEF: p = "La table source n'est pas d\xe9""finie";                                           break;
    case MSG_STACK_OVERFLOW:  p = "D\xe9passement de capacit\xe9 de la pile";                                         break;
    case MSG_TABDIR_READONLY: p = "Les tables DIR sont en lecture seulement";                                         break;
    case MSG_TABLE_NOT_OPT:   p = "Table non optimisable";                                                            break;
    case MSG_TABLE_NO_INDEX:  p = "La table %s n'est pas indexable";                                                  break;
    case MSG_TABLE_READ_ONLY: p = "Les tables %s sont en lecture seulement   ";                                       break;
    case MSG_TABMUL_READONLY: p = "Les tables multiples sont en lecture seulement";                                   break;
    case MSG_TOO_MANY_FIELDS: p = "Trop de champs ligne %d de %s";                                                    break;
    case MSG_TOO_MANY_JUMPS:  p = "Trop de niveaux de saut";                                                          break;
    case MSG_TOO_MANY_KEYS:   p = "Trop de cl\xe9s (%d)";                                                             break;
    case MSG_TO_BLK_IS_NULL:  p = "To Blk est nul";                                                                   break;
    case MSG_TRUNCATE_ERROR:  p = "Erreur en troncation: %s";                                                         break;
    case MSG_TRUNC_BY_ESTIM:  p = "Tronqu\xe9 par l'option Estimate";                                                 break;
    case MSG_TYPE_MISMATCH:   p = "Cl\xe9 et source ne sont pas du m\xeame type";                                     break;
    case MSG_TYPE_VALUE_ERR:  p = "Colonne %s: disparit\xe9 type(%s)/valeur(%s)";                                     break;
    case MSG_UNBALANCE_QUOTE: p = "Appostrophe en trop ligne %d";                                                     break;
    case MSG_UNDEFINED_AM:    p = "COLBLK %s: m\xe9thode d'acc\xe8s ind\xe9""finie";                                  break;
    case MSG_UNKNOWN_EXCPT:   p = "Exception non r\xe9pertori\xe9""e";                                                break;
    case MSG_UNMATCH_FIL_ARG: p = "Argument de filtre d\xe9pareill\xe9";                                              break;
    case MSG_UPDATE_ERROR:    p = "Erreur en Update sur %s";                                                          break;
    case MSG_UPD_ZIP_NOT_IMP: p = "Mise \xe0 jour des tables ZDOS non encore implement\xe9";                          break;
    case MSG_VALSTR_TOO_LONG: p = "Valeur %s trop longue pour une cha\xeene de longueur %d";                          break;
    case MSG_VALTYPE_NOMATCH: p = "Disparit\xe9 types de valeur";                                                     break;
    case MSG_VALUE_ERROR:     p = "Colonne %s: bloc valeur nul";                                                      break;
    case MSG_VALUE_TOO_BIG:   p = "Valeur %lld trop grande pour la colonne %s";                                       break;
    case MSG_VALUE_TOO_LONG:  p = "Valeur %s trop longue pour la colonne %s de longueur %d";                          break;
    case MSG_VAL_ALLOC_ERR:   p = "Allocation impossible du noeud valeur";                                            break;
    case MSG_VIR_NO_DELETE:   p = "Delete impossible sur les tables %s";                                              break;
    case MSG_VIR_READ_ONLY:   p = "Les tables virtuelles %s sont en lecture seulement";                               break;
    case MSG_VOID_FIRST_ARG:  p = "Le premier argument ne doit pas \xeatre vide";                                     break;
    case MSG_WORK_AREA:       p = "Espace de travail: %s";                                                            break;
    case MSG_WRITE_SEEK_ERR:  p = "Erreur de recherche en \xe9""criture: %s";                                         break;
    case MSG_WRITE_STRERROR:  p = "Erreur en \xe9""criture sur %s: %s";                                               break;
    case MSG_WRITING:         p = "Ecriture";                                                                         break;
    case MSG_WRITING_ERROR:   p = "Erreur \xe0 l'\xe9""criture de %s: %s";                                            break;
    case MSG_WS_CONV_ERR:     p = "Erreur de convertion de %s en WS";                                                 break;
    case MSG_XCOL_MISMATCH:   p = "La colonne %s ne correspond pas \xe0 l'index";                                     break;
    case MSG_XFILE_READERR:   p = "Erreur %d en lisant le fichier index";                                             break;
    case MSG_XFILE_WRITERR:   p = "Erreur en \xe9""crivant le fichier index: %s";                                     break;
    case MSG_XMLTAB_INIT_ERR: p = "Erreur d'initialisation de la table XML";                                          break;
    case MSG_XML_INIT_ERROR:  p = "Erreur d'initialisation du nouveau fichier XML";                                   break;
    case MSG_XPATH_CNTX_ERR:  p = "Le nouveau contexte XPath ne peut \xeatre cr\xe9\xe9";                             break;
    case MSG_XPATH_EVAL_ERR:  p = "Impossible d'\xe9valuer l'emplacement xpath '%s'";                                 break;
    case MSG_XPATH_NOT_SUPP:  p = "Xpath non support\xe9 colonne %s";                                                 break;
