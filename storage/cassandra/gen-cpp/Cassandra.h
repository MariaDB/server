/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Cassandra_H
#define Cassandra_H

#include <thrift/TProcessor.h>
#include "cassandra_types.h"

namespace org { namespace apache { namespace cassandra {

class CassandraIf {
 public:
  virtual ~CassandraIf() {}
  virtual void login(const AuthenticationRequest& auth_request) = 0;
  virtual void set_keyspace(const std::string& keyspace) = 0;
  virtual void get(ColumnOrSuperColumn& _return, const std::string& key, const ColumnPath& column_path, const ConsistencyLevel::type consistency_level) = 0;
  virtual void get_slice(std::vector<ColumnOrSuperColumn> & _return, const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) = 0;
  virtual int32_t get_count(const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) = 0;
  virtual void multiget_slice(std::map<std::string, std::vector<ColumnOrSuperColumn> > & _return, const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) = 0;
  virtual void multiget_count(std::map<std::string, int32_t> & _return, const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) = 0;
  virtual void get_range_slices(std::vector<KeySlice> & _return, const ColumnParent& column_parent, const SlicePredicate& predicate, const KeyRange& range, const ConsistencyLevel::type consistency_level) = 0;
  virtual void get_paged_slice(std::vector<KeySlice> & _return, const std::string& column_family, const KeyRange& range, const std::string& start_column, const ConsistencyLevel::type consistency_level) = 0;
  virtual void get_indexed_slices(std::vector<KeySlice> & _return, const ColumnParent& column_parent, const IndexClause& index_clause, const SlicePredicate& column_predicate, const ConsistencyLevel::type consistency_level) = 0;
  virtual void insert(const std::string& key, const ColumnParent& column_parent, const Column& column, const ConsistencyLevel::type consistency_level) = 0;
  virtual void add(const std::string& key, const ColumnParent& column_parent, const CounterColumn& column, const ConsistencyLevel::type consistency_level) = 0;
  virtual void remove(const std::string& key, const ColumnPath& column_path, const int64_t timestamp, const ConsistencyLevel::type consistency_level) = 0;
  virtual void remove_counter(const std::string& key, const ColumnPath& path, const ConsistencyLevel::type consistency_level) = 0;
  virtual void batch_mutate(const std::map<std::string, std::map<std::string, std::vector<Mutation> > > & mutation_map, const ConsistencyLevel::type consistency_level) = 0;
  virtual void truncate(const std::string& cfname) = 0;
  virtual void describe_schema_versions(std::map<std::string, std::vector<std::string> > & _return) = 0;
  virtual void describe_keyspaces(std::vector<KsDef> & _return) = 0;
  virtual void describe_cluster_name(std::string& _return) = 0;
  virtual void describe_version(std::string& _return) = 0;
  virtual void describe_ring(std::vector<TokenRange> & _return, const std::string& keyspace) = 0;
  virtual void describe_token_map(std::map<std::string, std::string> & _return) = 0;
  virtual void describe_partitioner(std::string& _return) = 0;
  virtual void describe_snitch(std::string& _return) = 0;
  virtual void describe_keyspace(KsDef& _return, const std::string& keyspace) = 0;
  virtual void describe_splits(std::vector<std::string> & _return, const std::string& cfName, const std::string& start_token, const std::string& end_token, const int32_t keys_per_split) = 0;
  virtual void system_add_column_family(std::string& _return, const CfDef& cf_def) = 0;
  virtual void system_drop_column_family(std::string& _return, const std::string& column_family) = 0;
  virtual void system_add_keyspace(std::string& _return, const KsDef& ks_def) = 0;
  virtual void system_drop_keyspace(std::string& _return, const std::string& keyspace) = 0;
  virtual void system_update_keyspace(std::string& _return, const KsDef& ks_def) = 0;
  virtual void system_update_column_family(std::string& _return, const CfDef& cf_def) = 0;
  virtual void execute_cql_query(CqlResult& _return, const std::string& query, const Compression::type compression) = 0;
  virtual void prepare_cql_query(CqlPreparedResult& _return, const std::string& query, const Compression::type compression) = 0;
  virtual void execute_prepared_cql_query(CqlResult& _return, const int32_t itemId, const std::vector<std::string> & values) = 0;
  virtual void set_cql_version(const std::string& version) = 0;
};

class CassandraIfFactory {
 public:
  typedef CassandraIf Handler;

  virtual ~CassandraIfFactory() {}

  virtual CassandraIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(CassandraIf* /* handler */) = 0;
};

class CassandraIfSingletonFactory : virtual public CassandraIfFactory {
 public:
  CassandraIfSingletonFactory(const boost::shared_ptr<CassandraIf>& iface) : iface_(iface) {}
  virtual ~CassandraIfSingletonFactory() {}

  virtual CassandraIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(CassandraIf* /* handler */) {}

 protected:
  boost::shared_ptr<CassandraIf> iface_;
};

class CassandraNull : virtual public CassandraIf {
 public:
  virtual ~CassandraNull() {}
  void login(const AuthenticationRequest& /* auth_request */) {
    return;
  }
  void set_keyspace(const std::string& /* keyspace */) {
    return;
  }
  void get(ColumnOrSuperColumn& /* _return */, const std::string& /* key */, const ColumnPath& /* column_path */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void get_slice(std::vector<ColumnOrSuperColumn> & /* _return */, const std::string& /* key */, const ColumnParent& /* column_parent */, const SlicePredicate& /* predicate */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  int32_t get_count(const std::string& /* key */, const ColumnParent& /* column_parent */, const SlicePredicate& /* predicate */, const ConsistencyLevel::type /* consistency_level */) {
    int32_t _return = 0;
    return _return;
  }
  void multiget_slice(std::map<std::string, std::vector<ColumnOrSuperColumn> > & /* _return */, const std::vector<std::string> & /* keys */, const ColumnParent& /* column_parent */, const SlicePredicate& /* predicate */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void multiget_count(std::map<std::string, int32_t> & /* _return */, const std::vector<std::string> & /* keys */, const ColumnParent& /* column_parent */, const SlicePredicate& /* predicate */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void get_range_slices(std::vector<KeySlice> & /* _return */, const ColumnParent& /* column_parent */, const SlicePredicate& /* predicate */, const KeyRange& /* range */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void get_paged_slice(std::vector<KeySlice> & /* _return */, const std::string& /* column_family */, const KeyRange& /* range */, const std::string& /* start_column */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void get_indexed_slices(std::vector<KeySlice> & /* _return */, const ColumnParent& /* column_parent */, const IndexClause& /* index_clause */, const SlicePredicate& /* column_predicate */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void insert(const std::string& /* key */, const ColumnParent& /* column_parent */, const Column& /* column */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void add(const std::string& /* key */, const ColumnParent& /* column_parent */, const CounterColumn& /* column */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void remove(const std::string& /* key */, const ColumnPath& /* column_path */, const int64_t /* timestamp */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void remove_counter(const std::string& /* key */, const ColumnPath& /* path */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void batch_mutate(const std::map<std::string, std::map<std::string, std::vector<Mutation> > > & /* mutation_map */, const ConsistencyLevel::type /* consistency_level */) {
    return;
  }
  void truncate(const std::string& /* cfname */) {
    return;
  }
  void describe_schema_versions(std::map<std::string, std::vector<std::string> > & /* _return */) {
    return;
  }
  void describe_keyspaces(std::vector<KsDef> & /* _return */) {
    return;
  }
  void describe_cluster_name(std::string& /* _return */) {
    return;
  }
  void describe_version(std::string& /* _return */) {
    return;
  }
  void describe_ring(std::vector<TokenRange> & /* _return */, const std::string& /* keyspace */) {
    return;
  }
  void describe_token_map(std::map<std::string, std::string> & /* _return */) {
    return;
  }
  void describe_partitioner(std::string& /* _return */) {
    return;
  }
  void describe_snitch(std::string& /* _return */) {
    return;
  }
  void describe_keyspace(KsDef& /* _return */, const std::string& /* keyspace */) {
    return;
  }
  void describe_splits(std::vector<std::string> & /* _return */, const std::string& /* cfName */, const std::string& /* start_token */, const std::string& /* end_token */, const int32_t /* keys_per_split */) {
    return;
  }
  void system_add_column_family(std::string& /* _return */, const CfDef& /* cf_def */) {
    return;
  }
  void system_drop_column_family(std::string& /* _return */, const std::string& /* column_family */) {
    return;
  }
  void system_add_keyspace(std::string& /* _return */, const KsDef& /* ks_def */) {
    return;
  }
  void system_drop_keyspace(std::string& /* _return */, const std::string& /* keyspace */) {
    return;
  }
  void system_update_keyspace(std::string& /* _return */, const KsDef& /* ks_def */) {
    return;
  }
  void system_update_column_family(std::string& /* _return */, const CfDef& /* cf_def */) {
    return;
  }
  void execute_cql_query(CqlResult& /* _return */, const std::string& /* query */, const Compression::type /* compression */) {
    return;
  }
  void prepare_cql_query(CqlPreparedResult& /* _return */, const std::string& /* query */, const Compression::type /* compression */) {
    return;
  }
  void execute_prepared_cql_query(CqlResult& /* _return */, const int32_t /* itemId */, const std::vector<std::string> & /* values */) {
    return;
  }
  void set_cql_version(const std::string& /* version */) {
    return;
  }
};


class Cassandra_login_args {
 public:

  Cassandra_login_args() {
  }

  virtual ~Cassandra_login_args() throw() {}

  AuthenticationRequest auth_request;

  void __set_auth_request(const AuthenticationRequest& val) {
    auth_request = val;
  }

  bool operator == (const Cassandra_login_args & rhs) const
  {
    if (!(auth_request == rhs.auth_request))
      return false;
    return true;
  }
  bool operator != (const Cassandra_login_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_login_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_login_pargs {
 public:


  virtual ~Cassandra_login_pargs() throw() {}

  const AuthenticationRequest* auth_request;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_login_result__isset {
  _Cassandra_login_result__isset() : authnx(false), authzx(false) {}
  bool authnx;
  bool authzx;
} _Cassandra_login_result__isset;

class Cassandra_login_result {
 public:

  Cassandra_login_result() {
  }

  virtual ~Cassandra_login_result() throw() {}

  AuthenticationException authnx;
  AuthorizationException authzx;

  _Cassandra_login_result__isset __isset;

  void __set_authnx(const AuthenticationException& val) {
    authnx = val;
  }

  void __set_authzx(const AuthorizationException& val) {
    authzx = val;
  }

  bool operator == (const Cassandra_login_result & rhs) const
  {
    if (!(authnx == rhs.authnx))
      return false;
    if (!(authzx == rhs.authzx))
      return false;
    return true;
  }
  bool operator != (const Cassandra_login_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_login_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_login_presult__isset {
  _Cassandra_login_presult__isset() : authnx(false), authzx(false) {}
  bool authnx;
  bool authzx;
} _Cassandra_login_presult__isset;

class Cassandra_login_presult {
 public:


  virtual ~Cassandra_login_presult() throw() {}

  AuthenticationException authnx;
  AuthorizationException authzx;

  _Cassandra_login_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_set_keyspace_args {
 public:

  Cassandra_set_keyspace_args() : keyspace("") {
  }

  virtual ~Cassandra_set_keyspace_args() throw() {}

  std::string keyspace;

  void __set_keyspace(const std::string& val) {
    keyspace = val;
  }

  bool operator == (const Cassandra_set_keyspace_args & rhs) const
  {
    if (!(keyspace == rhs.keyspace))
      return false;
    return true;
  }
  bool operator != (const Cassandra_set_keyspace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_set_keyspace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_set_keyspace_pargs {
 public:


  virtual ~Cassandra_set_keyspace_pargs() throw() {}

  const std::string* keyspace;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_set_keyspace_result__isset {
  _Cassandra_set_keyspace_result__isset() : ire(false) {}
  bool ire;
} _Cassandra_set_keyspace_result__isset;

class Cassandra_set_keyspace_result {
 public:

  Cassandra_set_keyspace_result() {
  }

  virtual ~Cassandra_set_keyspace_result() throw() {}

  InvalidRequestException ire;

  _Cassandra_set_keyspace_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_set_keyspace_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_set_keyspace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_set_keyspace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_set_keyspace_presult__isset {
  _Cassandra_set_keyspace_presult__isset() : ire(false) {}
  bool ire;
} _Cassandra_set_keyspace_presult__isset;

class Cassandra_set_keyspace_presult {
 public:


  virtual ~Cassandra_set_keyspace_presult() throw() {}

  InvalidRequestException ire;

  _Cassandra_set_keyspace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_get_args {
 public:

  Cassandra_get_args() : key(""), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_get_args() throw() {}

  std::string key;
  ColumnPath column_path;
  ConsistencyLevel::type consistency_level;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_column_path(const ColumnPath& val) {
    column_path = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_get_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(column_path == rhs.column_path))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_get_pargs {
 public:


  virtual ~Cassandra_get_pargs() throw() {}

  const std::string* key;
  const ColumnPath* column_path;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_result__isset {
  _Cassandra_get_result__isset() : success(false), ire(false), nfe(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool nfe;
  bool ue;
  bool te;
} _Cassandra_get_result__isset;

class Cassandra_get_result {
 public:

  Cassandra_get_result() {
  }

  virtual ~Cassandra_get_result() throw() {}

  ColumnOrSuperColumn success;
  InvalidRequestException ire;
  NotFoundException nfe;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_result__isset __isset;

  void __set_success(const ColumnOrSuperColumn& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_nfe(const NotFoundException& val) {
    nfe = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_get_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(nfe == rhs.nfe))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_presult__isset {
  _Cassandra_get_presult__isset() : success(false), ire(false), nfe(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool nfe;
  bool ue;
  bool te;
} _Cassandra_get_presult__isset;

class Cassandra_get_presult {
 public:


  virtual ~Cassandra_get_presult() throw() {}

  ColumnOrSuperColumn* success;
  InvalidRequestException ire;
  NotFoundException nfe;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_get_slice_args {
 public:

  Cassandra_get_slice_args() : key(""), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_get_slice_args() throw() {}

  std::string key;
  ColumnParent column_parent;
  SlicePredicate predicate;
  ConsistencyLevel::type consistency_level;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_predicate(const SlicePredicate& val) {
    predicate = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_get_slice_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(predicate == rhs.predicate))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_slice_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_slice_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_get_slice_pargs {
 public:


  virtual ~Cassandra_get_slice_pargs() throw() {}

  const std::string* key;
  const ColumnParent* column_parent;
  const SlicePredicate* predicate;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_slice_result__isset {
  _Cassandra_get_slice_result__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_slice_result__isset;

class Cassandra_get_slice_result {
 public:

  Cassandra_get_slice_result() {
  }

  virtual ~Cassandra_get_slice_result() throw() {}

  std::vector<ColumnOrSuperColumn>  success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_slice_result__isset __isset;

  void __set_success(const std::vector<ColumnOrSuperColumn> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_get_slice_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_slice_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_slice_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_slice_presult__isset {
  _Cassandra_get_slice_presult__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_slice_presult__isset;

class Cassandra_get_slice_presult {
 public:


  virtual ~Cassandra_get_slice_presult() throw() {}

  std::vector<ColumnOrSuperColumn> * success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_slice_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_get_count_args {
 public:

  Cassandra_get_count_args() : key(""), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_get_count_args() throw() {}

  std::string key;
  ColumnParent column_parent;
  SlicePredicate predicate;
  ConsistencyLevel::type consistency_level;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_predicate(const SlicePredicate& val) {
    predicate = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_get_count_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(predicate == rhs.predicate))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_count_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_count_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_get_count_pargs {
 public:


  virtual ~Cassandra_get_count_pargs() throw() {}

  const std::string* key;
  const ColumnParent* column_parent;
  const SlicePredicate* predicate;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_count_result__isset {
  _Cassandra_get_count_result__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_count_result__isset;

class Cassandra_get_count_result {
 public:

  Cassandra_get_count_result() : success(0) {
  }

  virtual ~Cassandra_get_count_result() throw() {}

  int32_t success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_count_result__isset __isset;

  void __set_success(const int32_t val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_get_count_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_count_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_count_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_count_presult__isset {
  _Cassandra_get_count_presult__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_count_presult__isset;

class Cassandra_get_count_presult {
 public:


  virtual ~Cassandra_get_count_presult() throw() {}

  int32_t* success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_count_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_multiget_slice_args {
 public:

  Cassandra_multiget_slice_args() : consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_multiget_slice_args() throw() {}

  std::vector<std::string>  keys;
  ColumnParent column_parent;
  SlicePredicate predicate;
  ConsistencyLevel::type consistency_level;

  void __set_keys(const std::vector<std::string> & val) {
    keys = val;
  }

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_predicate(const SlicePredicate& val) {
    predicate = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_multiget_slice_args & rhs) const
  {
    if (!(keys == rhs.keys))
      return false;
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(predicate == rhs.predicate))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_multiget_slice_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_multiget_slice_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_multiget_slice_pargs {
 public:


  virtual ~Cassandra_multiget_slice_pargs() throw() {}

  const std::vector<std::string> * keys;
  const ColumnParent* column_parent;
  const SlicePredicate* predicate;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_multiget_slice_result__isset {
  _Cassandra_multiget_slice_result__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_multiget_slice_result__isset;

class Cassandra_multiget_slice_result {
 public:

  Cassandra_multiget_slice_result() {
  }

  virtual ~Cassandra_multiget_slice_result() throw() {}

  std::map<std::string, std::vector<ColumnOrSuperColumn> >  success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_multiget_slice_result__isset __isset;

  void __set_success(const std::map<std::string, std::vector<ColumnOrSuperColumn> > & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_multiget_slice_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_multiget_slice_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_multiget_slice_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_multiget_slice_presult__isset {
  _Cassandra_multiget_slice_presult__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_multiget_slice_presult__isset;

class Cassandra_multiget_slice_presult {
 public:


  virtual ~Cassandra_multiget_slice_presult() throw() {}

  std::map<std::string, std::vector<ColumnOrSuperColumn> > * success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_multiget_slice_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_multiget_count_args {
 public:

  Cassandra_multiget_count_args() : consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_multiget_count_args() throw() {}

  std::vector<std::string>  keys;
  ColumnParent column_parent;
  SlicePredicate predicate;
  ConsistencyLevel::type consistency_level;

  void __set_keys(const std::vector<std::string> & val) {
    keys = val;
  }

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_predicate(const SlicePredicate& val) {
    predicate = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_multiget_count_args & rhs) const
  {
    if (!(keys == rhs.keys))
      return false;
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(predicate == rhs.predicate))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_multiget_count_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_multiget_count_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_multiget_count_pargs {
 public:


  virtual ~Cassandra_multiget_count_pargs() throw() {}

  const std::vector<std::string> * keys;
  const ColumnParent* column_parent;
  const SlicePredicate* predicate;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_multiget_count_result__isset {
  _Cassandra_multiget_count_result__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_multiget_count_result__isset;

class Cassandra_multiget_count_result {
 public:

  Cassandra_multiget_count_result() {
  }

  virtual ~Cassandra_multiget_count_result() throw() {}

  std::map<std::string, int32_t>  success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_multiget_count_result__isset __isset;

  void __set_success(const std::map<std::string, int32_t> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_multiget_count_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_multiget_count_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_multiget_count_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_multiget_count_presult__isset {
  _Cassandra_multiget_count_presult__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_multiget_count_presult__isset;

class Cassandra_multiget_count_presult {
 public:


  virtual ~Cassandra_multiget_count_presult() throw() {}

  std::map<std::string, int32_t> * success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_multiget_count_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_get_range_slices_args {
 public:

  Cassandra_get_range_slices_args() : consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_get_range_slices_args() throw() {}

  ColumnParent column_parent;
  SlicePredicate predicate;
  KeyRange range;
  ConsistencyLevel::type consistency_level;

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_predicate(const SlicePredicate& val) {
    predicate = val;
  }

  void __set_range(const KeyRange& val) {
    range = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_get_range_slices_args & rhs) const
  {
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(predicate == rhs.predicate))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_range_slices_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_range_slices_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_get_range_slices_pargs {
 public:


  virtual ~Cassandra_get_range_slices_pargs() throw() {}

  const ColumnParent* column_parent;
  const SlicePredicate* predicate;
  const KeyRange* range;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_range_slices_result__isset {
  _Cassandra_get_range_slices_result__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_range_slices_result__isset;

class Cassandra_get_range_slices_result {
 public:

  Cassandra_get_range_slices_result() {
  }

  virtual ~Cassandra_get_range_slices_result() throw() {}

  std::vector<KeySlice>  success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_range_slices_result__isset __isset;

  void __set_success(const std::vector<KeySlice> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_get_range_slices_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_range_slices_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_range_slices_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_range_slices_presult__isset {
  _Cassandra_get_range_slices_presult__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_range_slices_presult__isset;

class Cassandra_get_range_slices_presult {
 public:


  virtual ~Cassandra_get_range_slices_presult() throw() {}

  std::vector<KeySlice> * success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_range_slices_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_get_paged_slice_args {
 public:

  Cassandra_get_paged_slice_args() : column_family(""), start_column(""), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_get_paged_slice_args() throw() {}

  std::string column_family;
  KeyRange range;
  std::string start_column;
  ConsistencyLevel::type consistency_level;

  void __set_column_family(const std::string& val) {
    column_family = val;
  }

  void __set_range(const KeyRange& val) {
    range = val;
  }

  void __set_start_column(const std::string& val) {
    start_column = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_get_paged_slice_args & rhs) const
  {
    if (!(column_family == rhs.column_family))
      return false;
    if (!(range == rhs.range))
      return false;
    if (!(start_column == rhs.start_column))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_paged_slice_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_paged_slice_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_get_paged_slice_pargs {
 public:


  virtual ~Cassandra_get_paged_slice_pargs() throw() {}

  const std::string* column_family;
  const KeyRange* range;
  const std::string* start_column;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_paged_slice_result__isset {
  _Cassandra_get_paged_slice_result__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_paged_slice_result__isset;

class Cassandra_get_paged_slice_result {
 public:

  Cassandra_get_paged_slice_result() {
  }

  virtual ~Cassandra_get_paged_slice_result() throw() {}

  std::vector<KeySlice>  success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_paged_slice_result__isset __isset;

  void __set_success(const std::vector<KeySlice> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_get_paged_slice_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_paged_slice_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_paged_slice_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_paged_slice_presult__isset {
  _Cassandra_get_paged_slice_presult__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_paged_slice_presult__isset;

class Cassandra_get_paged_slice_presult {
 public:


  virtual ~Cassandra_get_paged_slice_presult() throw() {}

  std::vector<KeySlice> * success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_paged_slice_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_get_indexed_slices_args {
 public:

  Cassandra_get_indexed_slices_args() : consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_get_indexed_slices_args() throw() {}

  ColumnParent column_parent;
  IndexClause index_clause;
  SlicePredicate column_predicate;
  ConsistencyLevel::type consistency_level;

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_index_clause(const IndexClause& val) {
    index_clause = val;
  }

  void __set_column_predicate(const SlicePredicate& val) {
    column_predicate = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_get_indexed_slices_args & rhs) const
  {
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(index_clause == rhs.index_clause))
      return false;
    if (!(column_predicate == rhs.column_predicate))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_indexed_slices_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_indexed_slices_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_get_indexed_slices_pargs {
 public:


  virtual ~Cassandra_get_indexed_slices_pargs() throw() {}

  const ColumnParent* column_parent;
  const IndexClause* index_clause;
  const SlicePredicate* column_predicate;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_indexed_slices_result__isset {
  _Cassandra_get_indexed_slices_result__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_indexed_slices_result__isset;

class Cassandra_get_indexed_slices_result {
 public:

  Cassandra_get_indexed_slices_result() {
  }

  virtual ~Cassandra_get_indexed_slices_result() throw() {}

  std::vector<KeySlice>  success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_indexed_slices_result__isset __isset;

  void __set_success(const std::vector<KeySlice> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_get_indexed_slices_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_get_indexed_slices_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_get_indexed_slices_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_get_indexed_slices_presult__isset {
  _Cassandra_get_indexed_slices_presult__isset() : success(false), ire(false), ue(false), te(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
} _Cassandra_get_indexed_slices_presult__isset;

class Cassandra_get_indexed_slices_presult {
 public:


  virtual ~Cassandra_get_indexed_slices_presult() throw() {}

  std::vector<KeySlice> * success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_get_indexed_slices_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_insert_args {
 public:

  Cassandra_insert_args() : key(""), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_insert_args() throw() {}

  std::string key;
  ColumnParent column_parent;
  Column column;
  ConsistencyLevel::type consistency_level;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_column(const Column& val) {
    column = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_insert_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_insert_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_insert_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_insert_pargs {
 public:


  virtual ~Cassandra_insert_pargs() throw() {}

  const std::string* key;
  const ColumnParent* column_parent;
  const Column* column;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_insert_result__isset {
  _Cassandra_insert_result__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_insert_result__isset;

class Cassandra_insert_result {
 public:

  Cassandra_insert_result() {
  }

  virtual ~Cassandra_insert_result() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_insert_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_insert_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_insert_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_insert_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_insert_presult__isset {
  _Cassandra_insert_presult__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_insert_presult__isset;

class Cassandra_insert_presult {
 public:


  virtual ~Cassandra_insert_presult() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_insert_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_add_args {
 public:

  Cassandra_add_args() : key(""), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_add_args() throw() {}

  std::string key;
  ColumnParent column_parent;
  CounterColumn column;
  ConsistencyLevel::type consistency_level;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_column_parent(const ColumnParent& val) {
    column_parent = val;
  }

  void __set_column(const CounterColumn& val) {
    column = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_add_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(column_parent == rhs.column_parent))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_add_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_add_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_add_pargs {
 public:


  virtual ~Cassandra_add_pargs() throw() {}

  const std::string* key;
  const ColumnParent* column_parent;
  const CounterColumn* column;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_add_result__isset {
  _Cassandra_add_result__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_add_result__isset;

class Cassandra_add_result {
 public:

  Cassandra_add_result() {
  }

  virtual ~Cassandra_add_result() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_add_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_add_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_add_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_add_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_add_presult__isset {
  _Cassandra_add_presult__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_add_presult__isset;

class Cassandra_add_presult {
 public:


  virtual ~Cassandra_add_presult() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_add_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Cassandra_remove_args__isset {
  _Cassandra_remove_args__isset() : consistency_level(false) {}
  bool consistency_level;
} _Cassandra_remove_args__isset;

class Cassandra_remove_args {
 public:

  Cassandra_remove_args() : key(""), timestamp(0), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_remove_args() throw() {}

  std::string key;
  ColumnPath column_path;
  int64_t timestamp;
  ConsistencyLevel::type consistency_level;

  _Cassandra_remove_args__isset __isset;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_column_path(const ColumnPath& val) {
    column_path = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_remove_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(column_path == rhs.column_path))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_remove_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_remove_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_remove_pargs {
 public:


  virtual ~Cassandra_remove_pargs() throw() {}

  const std::string* key;
  const ColumnPath* column_path;
  const int64_t* timestamp;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_remove_result__isset {
  _Cassandra_remove_result__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_remove_result__isset;

class Cassandra_remove_result {
 public:

  Cassandra_remove_result() {
  }

  virtual ~Cassandra_remove_result() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_remove_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_remove_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_remove_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_remove_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_remove_presult__isset {
  _Cassandra_remove_presult__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_remove_presult__isset;

class Cassandra_remove_presult {
 public:


  virtual ~Cassandra_remove_presult() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_remove_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_remove_counter_args {
 public:

  Cassandra_remove_counter_args() : key(""), consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_remove_counter_args() throw() {}

  std::string key;
  ColumnPath path;
  ConsistencyLevel::type consistency_level;

  void __set_key(const std::string& val) {
    key = val;
  }

  void __set_path(const ColumnPath& val) {
    path = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_remove_counter_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(path == rhs.path))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_remove_counter_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_remove_counter_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_remove_counter_pargs {
 public:


  virtual ~Cassandra_remove_counter_pargs() throw() {}

  const std::string* key;
  const ColumnPath* path;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_remove_counter_result__isset {
  _Cassandra_remove_counter_result__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_remove_counter_result__isset;

class Cassandra_remove_counter_result {
 public:

  Cassandra_remove_counter_result() {
  }

  virtual ~Cassandra_remove_counter_result() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_remove_counter_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_remove_counter_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_remove_counter_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_remove_counter_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_remove_counter_presult__isset {
  _Cassandra_remove_counter_presult__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_remove_counter_presult__isset;

class Cassandra_remove_counter_presult {
 public:


  virtual ~Cassandra_remove_counter_presult() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_remove_counter_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_batch_mutate_args {
 public:

  Cassandra_batch_mutate_args() : consistency_level((ConsistencyLevel::type)1) {
    consistency_level = (ConsistencyLevel::type)1;

  }

  virtual ~Cassandra_batch_mutate_args() throw() {}

  std::map<std::string, std::map<std::string, std::vector<Mutation> > >  mutation_map;
  ConsistencyLevel::type consistency_level;

  void __set_mutation_map(const std::map<std::string, std::map<std::string, std::vector<Mutation> > > & val) {
    mutation_map = val;
  }

  void __set_consistency_level(const ConsistencyLevel::type val) {
    consistency_level = val;
  }

  bool operator == (const Cassandra_batch_mutate_args & rhs) const
  {
    if (!(mutation_map == rhs.mutation_map))
      return false;
    if (!(consistency_level == rhs.consistency_level))
      return false;
    return true;
  }
  bool operator != (const Cassandra_batch_mutate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_batch_mutate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_batch_mutate_pargs {
 public:


  virtual ~Cassandra_batch_mutate_pargs() throw() {}

  const std::map<std::string, std::map<std::string, std::vector<Mutation> > > * mutation_map;
  const ConsistencyLevel::type* consistency_level;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_batch_mutate_result__isset {
  _Cassandra_batch_mutate_result__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_batch_mutate_result__isset;

class Cassandra_batch_mutate_result {
 public:

  Cassandra_batch_mutate_result() {
  }

  virtual ~Cassandra_batch_mutate_result() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_batch_mutate_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_batch_mutate_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_batch_mutate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_batch_mutate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_batch_mutate_presult__isset {
  _Cassandra_batch_mutate_presult__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_batch_mutate_presult__isset;

class Cassandra_batch_mutate_presult {
 public:


  virtual ~Cassandra_batch_mutate_presult() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_batch_mutate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_truncate_args {
 public:

  Cassandra_truncate_args() : cfname("") {
  }

  virtual ~Cassandra_truncate_args() throw() {}

  std::string cfname;

  void __set_cfname(const std::string& val) {
    cfname = val;
  }

  bool operator == (const Cassandra_truncate_args & rhs) const
  {
    if (!(cfname == rhs.cfname))
      return false;
    return true;
  }
  bool operator != (const Cassandra_truncate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_truncate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_truncate_pargs {
 public:


  virtual ~Cassandra_truncate_pargs() throw() {}

  const std::string* cfname;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_truncate_result__isset {
  _Cassandra_truncate_result__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_truncate_result__isset;

class Cassandra_truncate_result {
 public:

  Cassandra_truncate_result() {
  }

  virtual ~Cassandra_truncate_result() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_truncate_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  bool operator == (const Cassandra_truncate_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    return true;
  }
  bool operator != (const Cassandra_truncate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_truncate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_truncate_presult__isset {
  _Cassandra_truncate_presult__isset() : ire(false), ue(false), te(false) {}
  bool ire;
  bool ue;
  bool te;
} _Cassandra_truncate_presult__isset;

class Cassandra_truncate_presult {
 public:


  virtual ~Cassandra_truncate_presult() throw() {}

  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;

  _Cassandra_truncate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_schema_versions_args {
 public:

  Cassandra_describe_schema_versions_args() {
  }

  virtual ~Cassandra_describe_schema_versions_args() throw() {}


  bool operator == (const Cassandra_describe_schema_versions_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Cassandra_describe_schema_versions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_schema_versions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_schema_versions_pargs {
 public:


  virtual ~Cassandra_describe_schema_versions_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_schema_versions_result__isset {
  _Cassandra_describe_schema_versions_result__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_schema_versions_result__isset;

class Cassandra_describe_schema_versions_result {
 public:

  Cassandra_describe_schema_versions_result() {
  }

  virtual ~Cassandra_describe_schema_versions_result() throw() {}

  std::map<std::string, std::vector<std::string> >  success;
  InvalidRequestException ire;

  _Cassandra_describe_schema_versions_result__isset __isset;

  void __set_success(const std::map<std::string, std::vector<std::string> > & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_describe_schema_versions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_schema_versions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_schema_versions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_schema_versions_presult__isset {
  _Cassandra_describe_schema_versions_presult__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_schema_versions_presult__isset;

class Cassandra_describe_schema_versions_presult {
 public:


  virtual ~Cassandra_describe_schema_versions_presult() throw() {}

  std::map<std::string, std::vector<std::string> > * success;
  InvalidRequestException ire;

  _Cassandra_describe_schema_versions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_keyspaces_args {
 public:

  Cassandra_describe_keyspaces_args() {
  }

  virtual ~Cassandra_describe_keyspaces_args() throw() {}


  bool operator == (const Cassandra_describe_keyspaces_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Cassandra_describe_keyspaces_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_keyspaces_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_keyspaces_pargs {
 public:


  virtual ~Cassandra_describe_keyspaces_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_keyspaces_result__isset {
  _Cassandra_describe_keyspaces_result__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_keyspaces_result__isset;

class Cassandra_describe_keyspaces_result {
 public:

  Cassandra_describe_keyspaces_result() {
  }

  virtual ~Cassandra_describe_keyspaces_result() throw() {}

  std::vector<KsDef>  success;
  InvalidRequestException ire;

  _Cassandra_describe_keyspaces_result__isset __isset;

  void __set_success(const std::vector<KsDef> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_describe_keyspaces_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_keyspaces_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_keyspaces_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_keyspaces_presult__isset {
  _Cassandra_describe_keyspaces_presult__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_keyspaces_presult__isset;

class Cassandra_describe_keyspaces_presult {
 public:


  virtual ~Cassandra_describe_keyspaces_presult() throw() {}

  std::vector<KsDef> * success;
  InvalidRequestException ire;

  _Cassandra_describe_keyspaces_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_cluster_name_args {
 public:

  Cassandra_describe_cluster_name_args() {
  }

  virtual ~Cassandra_describe_cluster_name_args() throw() {}


  bool operator == (const Cassandra_describe_cluster_name_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Cassandra_describe_cluster_name_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_cluster_name_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_cluster_name_pargs {
 public:


  virtual ~Cassandra_describe_cluster_name_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_cluster_name_result__isset {
  _Cassandra_describe_cluster_name_result__isset() : success(false) {}
  bool success;
} _Cassandra_describe_cluster_name_result__isset;

class Cassandra_describe_cluster_name_result {
 public:

  Cassandra_describe_cluster_name_result() : success("") {
  }

  virtual ~Cassandra_describe_cluster_name_result() throw() {}

  std::string success;

  _Cassandra_describe_cluster_name_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Cassandra_describe_cluster_name_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_cluster_name_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_cluster_name_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_cluster_name_presult__isset {
  _Cassandra_describe_cluster_name_presult__isset() : success(false) {}
  bool success;
} _Cassandra_describe_cluster_name_presult__isset;

class Cassandra_describe_cluster_name_presult {
 public:


  virtual ~Cassandra_describe_cluster_name_presult() throw() {}

  std::string* success;

  _Cassandra_describe_cluster_name_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_version_args {
 public:

  Cassandra_describe_version_args() {
  }

  virtual ~Cassandra_describe_version_args() throw() {}


  bool operator == (const Cassandra_describe_version_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Cassandra_describe_version_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_version_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_version_pargs {
 public:


  virtual ~Cassandra_describe_version_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_version_result__isset {
  _Cassandra_describe_version_result__isset() : success(false) {}
  bool success;
} _Cassandra_describe_version_result__isset;

class Cassandra_describe_version_result {
 public:

  Cassandra_describe_version_result() : success("") {
  }

  virtual ~Cassandra_describe_version_result() throw() {}

  std::string success;

  _Cassandra_describe_version_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Cassandra_describe_version_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_version_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_version_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_version_presult__isset {
  _Cassandra_describe_version_presult__isset() : success(false) {}
  bool success;
} _Cassandra_describe_version_presult__isset;

class Cassandra_describe_version_presult {
 public:


  virtual ~Cassandra_describe_version_presult() throw() {}

  std::string* success;

  _Cassandra_describe_version_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_ring_args {
 public:

  Cassandra_describe_ring_args() : keyspace("") {
  }

  virtual ~Cassandra_describe_ring_args() throw() {}

  std::string keyspace;

  void __set_keyspace(const std::string& val) {
    keyspace = val;
  }

  bool operator == (const Cassandra_describe_ring_args & rhs) const
  {
    if (!(keyspace == rhs.keyspace))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_ring_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_ring_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_ring_pargs {
 public:


  virtual ~Cassandra_describe_ring_pargs() throw() {}

  const std::string* keyspace;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_ring_result__isset {
  _Cassandra_describe_ring_result__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_ring_result__isset;

class Cassandra_describe_ring_result {
 public:

  Cassandra_describe_ring_result() {
  }

  virtual ~Cassandra_describe_ring_result() throw() {}

  std::vector<TokenRange>  success;
  InvalidRequestException ire;

  _Cassandra_describe_ring_result__isset __isset;

  void __set_success(const std::vector<TokenRange> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_describe_ring_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_ring_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_ring_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_ring_presult__isset {
  _Cassandra_describe_ring_presult__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_ring_presult__isset;

class Cassandra_describe_ring_presult {
 public:


  virtual ~Cassandra_describe_ring_presult() throw() {}

  std::vector<TokenRange> * success;
  InvalidRequestException ire;

  _Cassandra_describe_ring_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_token_map_args {
 public:

  Cassandra_describe_token_map_args() {
  }

  virtual ~Cassandra_describe_token_map_args() throw() {}


  bool operator == (const Cassandra_describe_token_map_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Cassandra_describe_token_map_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_token_map_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_token_map_pargs {
 public:


  virtual ~Cassandra_describe_token_map_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_token_map_result__isset {
  _Cassandra_describe_token_map_result__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_token_map_result__isset;

class Cassandra_describe_token_map_result {
 public:

  Cassandra_describe_token_map_result() {
  }

  virtual ~Cassandra_describe_token_map_result() throw() {}

  std::map<std::string, std::string>  success;
  InvalidRequestException ire;

  _Cassandra_describe_token_map_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_describe_token_map_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_token_map_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_token_map_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_token_map_presult__isset {
  _Cassandra_describe_token_map_presult__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_token_map_presult__isset;

class Cassandra_describe_token_map_presult {
 public:


  virtual ~Cassandra_describe_token_map_presult() throw() {}

  std::map<std::string, std::string> * success;
  InvalidRequestException ire;

  _Cassandra_describe_token_map_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_partitioner_args {
 public:

  Cassandra_describe_partitioner_args() {
  }

  virtual ~Cassandra_describe_partitioner_args() throw() {}


  bool operator == (const Cassandra_describe_partitioner_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Cassandra_describe_partitioner_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_partitioner_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_partitioner_pargs {
 public:


  virtual ~Cassandra_describe_partitioner_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_partitioner_result__isset {
  _Cassandra_describe_partitioner_result__isset() : success(false) {}
  bool success;
} _Cassandra_describe_partitioner_result__isset;

class Cassandra_describe_partitioner_result {
 public:

  Cassandra_describe_partitioner_result() : success("") {
  }

  virtual ~Cassandra_describe_partitioner_result() throw() {}

  std::string success;

  _Cassandra_describe_partitioner_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Cassandra_describe_partitioner_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_partitioner_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_partitioner_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_partitioner_presult__isset {
  _Cassandra_describe_partitioner_presult__isset() : success(false) {}
  bool success;
} _Cassandra_describe_partitioner_presult__isset;

class Cassandra_describe_partitioner_presult {
 public:


  virtual ~Cassandra_describe_partitioner_presult() throw() {}

  std::string* success;

  _Cassandra_describe_partitioner_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_snitch_args {
 public:

  Cassandra_describe_snitch_args() {
  }

  virtual ~Cassandra_describe_snitch_args() throw() {}


  bool operator == (const Cassandra_describe_snitch_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Cassandra_describe_snitch_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_snitch_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_snitch_pargs {
 public:


  virtual ~Cassandra_describe_snitch_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_snitch_result__isset {
  _Cassandra_describe_snitch_result__isset() : success(false) {}
  bool success;
} _Cassandra_describe_snitch_result__isset;

class Cassandra_describe_snitch_result {
 public:

  Cassandra_describe_snitch_result() : success("") {
  }

  virtual ~Cassandra_describe_snitch_result() throw() {}

  std::string success;

  _Cassandra_describe_snitch_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  bool operator == (const Cassandra_describe_snitch_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_snitch_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_snitch_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_snitch_presult__isset {
  _Cassandra_describe_snitch_presult__isset() : success(false) {}
  bool success;
} _Cassandra_describe_snitch_presult__isset;

class Cassandra_describe_snitch_presult {
 public:


  virtual ~Cassandra_describe_snitch_presult() throw() {}

  std::string* success;

  _Cassandra_describe_snitch_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_keyspace_args {
 public:

  Cassandra_describe_keyspace_args() : keyspace("") {
  }

  virtual ~Cassandra_describe_keyspace_args() throw() {}

  std::string keyspace;

  void __set_keyspace(const std::string& val) {
    keyspace = val;
  }

  bool operator == (const Cassandra_describe_keyspace_args & rhs) const
  {
    if (!(keyspace == rhs.keyspace))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_keyspace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_keyspace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_keyspace_pargs {
 public:


  virtual ~Cassandra_describe_keyspace_pargs() throw() {}

  const std::string* keyspace;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_keyspace_result__isset {
  _Cassandra_describe_keyspace_result__isset() : success(false), nfe(false), ire(false) {}
  bool success;
  bool nfe;
  bool ire;
} _Cassandra_describe_keyspace_result__isset;

class Cassandra_describe_keyspace_result {
 public:

  Cassandra_describe_keyspace_result() {
  }

  virtual ~Cassandra_describe_keyspace_result() throw() {}

  KsDef success;
  NotFoundException nfe;
  InvalidRequestException ire;

  _Cassandra_describe_keyspace_result__isset __isset;

  void __set_success(const KsDef& val) {
    success = val;
  }

  void __set_nfe(const NotFoundException& val) {
    nfe = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_describe_keyspace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(nfe == rhs.nfe))
      return false;
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_keyspace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_keyspace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_keyspace_presult__isset {
  _Cassandra_describe_keyspace_presult__isset() : success(false), nfe(false), ire(false) {}
  bool success;
  bool nfe;
  bool ire;
} _Cassandra_describe_keyspace_presult__isset;

class Cassandra_describe_keyspace_presult {
 public:


  virtual ~Cassandra_describe_keyspace_presult() throw() {}

  KsDef* success;
  NotFoundException nfe;
  InvalidRequestException ire;

  _Cassandra_describe_keyspace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_describe_splits_args {
 public:

  Cassandra_describe_splits_args() : cfName(""), start_token(""), end_token(""), keys_per_split(0) {
  }

  virtual ~Cassandra_describe_splits_args() throw() {}

  std::string cfName;
  std::string start_token;
  std::string end_token;
  int32_t keys_per_split;

  void __set_cfName(const std::string& val) {
    cfName = val;
  }

  void __set_start_token(const std::string& val) {
    start_token = val;
  }

  void __set_end_token(const std::string& val) {
    end_token = val;
  }

  void __set_keys_per_split(const int32_t val) {
    keys_per_split = val;
  }

  bool operator == (const Cassandra_describe_splits_args & rhs) const
  {
    if (!(cfName == rhs.cfName))
      return false;
    if (!(start_token == rhs.start_token))
      return false;
    if (!(end_token == rhs.end_token))
      return false;
    if (!(keys_per_split == rhs.keys_per_split))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_splits_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_splits_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_describe_splits_pargs {
 public:


  virtual ~Cassandra_describe_splits_pargs() throw() {}

  const std::string* cfName;
  const std::string* start_token;
  const std::string* end_token;
  const int32_t* keys_per_split;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_splits_result__isset {
  _Cassandra_describe_splits_result__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_splits_result__isset;

class Cassandra_describe_splits_result {
 public:

  Cassandra_describe_splits_result() {
  }

  virtual ~Cassandra_describe_splits_result() throw() {}

  std::vector<std::string>  success;
  InvalidRequestException ire;

  _Cassandra_describe_splits_result__isset __isset;

  void __set_success(const std::vector<std::string> & val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_describe_splits_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_describe_splits_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_describe_splits_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_describe_splits_presult__isset {
  _Cassandra_describe_splits_presult__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_describe_splits_presult__isset;

class Cassandra_describe_splits_presult {
 public:


  virtual ~Cassandra_describe_splits_presult() throw() {}

  std::vector<std::string> * success;
  InvalidRequestException ire;

  _Cassandra_describe_splits_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_system_add_column_family_args {
 public:

  Cassandra_system_add_column_family_args() {
  }

  virtual ~Cassandra_system_add_column_family_args() throw() {}

  CfDef cf_def;

  void __set_cf_def(const CfDef& val) {
    cf_def = val;
  }

  bool operator == (const Cassandra_system_add_column_family_args & rhs) const
  {
    if (!(cf_def == rhs.cf_def))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_add_column_family_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_add_column_family_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_system_add_column_family_pargs {
 public:


  virtual ~Cassandra_system_add_column_family_pargs() throw() {}

  const CfDef* cf_def;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_add_column_family_result__isset {
  _Cassandra_system_add_column_family_result__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_add_column_family_result__isset;

class Cassandra_system_add_column_family_result {
 public:

  Cassandra_system_add_column_family_result() : success("") {
  }

  virtual ~Cassandra_system_add_column_family_result() throw() {}

  std::string success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_add_column_family_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_system_add_column_family_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_add_column_family_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_add_column_family_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_add_column_family_presult__isset {
  _Cassandra_system_add_column_family_presult__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_add_column_family_presult__isset;

class Cassandra_system_add_column_family_presult {
 public:


  virtual ~Cassandra_system_add_column_family_presult() throw() {}

  std::string* success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_add_column_family_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_system_drop_column_family_args {
 public:

  Cassandra_system_drop_column_family_args() : column_family("") {
  }

  virtual ~Cassandra_system_drop_column_family_args() throw() {}

  std::string column_family;

  void __set_column_family(const std::string& val) {
    column_family = val;
  }

  bool operator == (const Cassandra_system_drop_column_family_args & rhs) const
  {
    if (!(column_family == rhs.column_family))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_drop_column_family_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_drop_column_family_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_system_drop_column_family_pargs {
 public:


  virtual ~Cassandra_system_drop_column_family_pargs() throw() {}

  const std::string* column_family;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_drop_column_family_result__isset {
  _Cassandra_system_drop_column_family_result__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_drop_column_family_result__isset;

class Cassandra_system_drop_column_family_result {
 public:

  Cassandra_system_drop_column_family_result() : success("") {
  }

  virtual ~Cassandra_system_drop_column_family_result() throw() {}

  std::string success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_drop_column_family_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_system_drop_column_family_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_drop_column_family_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_drop_column_family_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_drop_column_family_presult__isset {
  _Cassandra_system_drop_column_family_presult__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_drop_column_family_presult__isset;

class Cassandra_system_drop_column_family_presult {
 public:


  virtual ~Cassandra_system_drop_column_family_presult() throw() {}

  std::string* success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_drop_column_family_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_system_add_keyspace_args {
 public:

  Cassandra_system_add_keyspace_args() {
  }

  virtual ~Cassandra_system_add_keyspace_args() throw() {}

  KsDef ks_def;

  void __set_ks_def(const KsDef& val) {
    ks_def = val;
  }

  bool operator == (const Cassandra_system_add_keyspace_args & rhs) const
  {
    if (!(ks_def == rhs.ks_def))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_add_keyspace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_add_keyspace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_system_add_keyspace_pargs {
 public:


  virtual ~Cassandra_system_add_keyspace_pargs() throw() {}

  const KsDef* ks_def;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_add_keyspace_result__isset {
  _Cassandra_system_add_keyspace_result__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_add_keyspace_result__isset;

class Cassandra_system_add_keyspace_result {
 public:

  Cassandra_system_add_keyspace_result() : success("") {
  }

  virtual ~Cassandra_system_add_keyspace_result() throw() {}

  std::string success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_add_keyspace_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_system_add_keyspace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_add_keyspace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_add_keyspace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_add_keyspace_presult__isset {
  _Cassandra_system_add_keyspace_presult__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_add_keyspace_presult__isset;

class Cassandra_system_add_keyspace_presult {
 public:


  virtual ~Cassandra_system_add_keyspace_presult() throw() {}

  std::string* success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_add_keyspace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_system_drop_keyspace_args {
 public:

  Cassandra_system_drop_keyspace_args() : keyspace("") {
  }

  virtual ~Cassandra_system_drop_keyspace_args() throw() {}

  std::string keyspace;

  void __set_keyspace(const std::string& val) {
    keyspace = val;
  }

  bool operator == (const Cassandra_system_drop_keyspace_args & rhs) const
  {
    if (!(keyspace == rhs.keyspace))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_drop_keyspace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_drop_keyspace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_system_drop_keyspace_pargs {
 public:


  virtual ~Cassandra_system_drop_keyspace_pargs() throw() {}

  const std::string* keyspace;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_drop_keyspace_result__isset {
  _Cassandra_system_drop_keyspace_result__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_drop_keyspace_result__isset;

class Cassandra_system_drop_keyspace_result {
 public:

  Cassandra_system_drop_keyspace_result() : success("") {
  }

  virtual ~Cassandra_system_drop_keyspace_result() throw() {}

  std::string success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_drop_keyspace_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_system_drop_keyspace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_drop_keyspace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_drop_keyspace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_drop_keyspace_presult__isset {
  _Cassandra_system_drop_keyspace_presult__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_drop_keyspace_presult__isset;

class Cassandra_system_drop_keyspace_presult {
 public:


  virtual ~Cassandra_system_drop_keyspace_presult() throw() {}

  std::string* success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_drop_keyspace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_system_update_keyspace_args {
 public:

  Cassandra_system_update_keyspace_args() {
  }

  virtual ~Cassandra_system_update_keyspace_args() throw() {}

  KsDef ks_def;

  void __set_ks_def(const KsDef& val) {
    ks_def = val;
  }

  bool operator == (const Cassandra_system_update_keyspace_args & rhs) const
  {
    if (!(ks_def == rhs.ks_def))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_update_keyspace_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_update_keyspace_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_system_update_keyspace_pargs {
 public:


  virtual ~Cassandra_system_update_keyspace_pargs() throw() {}

  const KsDef* ks_def;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_update_keyspace_result__isset {
  _Cassandra_system_update_keyspace_result__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_update_keyspace_result__isset;

class Cassandra_system_update_keyspace_result {
 public:

  Cassandra_system_update_keyspace_result() : success("") {
  }

  virtual ~Cassandra_system_update_keyspace_result() throw() {}

  std::string success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_update_keyspace_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_system_update_keyspace_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_update_keyspace_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_update_keyspace_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_update_keyspace_presult__isset {
  _Cassandra_system_update_keyspace_presult__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_update_keyspace_presult__isset;

class Cassandra_system_update_keyspace_presult {
 public:


  virtual ~Cassandra_system_update_keyspace_presult() throw() {}

  std::string* success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_update_keyspace_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_system_update_column_family_args {
 public:

  Cassandra_system_update_column_family_args() {
  }

  virtual ~Cassandra_system_update_column_family_args() throw() {}

  CfDef cf_def;

  void __set_cf_def(const CfDef& val) {
    cf_def = val;
  }

  bool operator == (const Cassandra_system_update_column_family_args & rhs) const
  {
    if (!(cf_def == rhs.cf_def))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_update_column_family_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_update_column_family_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_system_update_column_family_pargs {
 public:


  virtual ~Cassandra_system_update_column_family_pargs() throw() {}

  const CfDef* cf_def;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_update_column_family_result__isset {
  _Cassandra_system_update_column_family_result__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_update_column_family_result__isset;

class Cassandra_system_update_column_family_result {
 public:

  Cassandra_system_update_column_family_result() : success("") {
  }

  virtual ~Cassandra_system_update_column_family_result() throw() {}

  std::string success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_update_column_family_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_system_update_column_family_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_system_update_column_family_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_system_update_column_family_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_system_update_column_family_presult__isset {
  _Cassandra_system_update_column_family_presult__isset() : success(false), ire(false), sde(false) {}
  bool success;
  bool ire;
  bool sde;
} _Cassandra_system_update_column_family_presult__isset;

class Cassandra_system_update_column_family_presult {
 public:


  virtual ~Cassandra_system_update_column_family_presult() throw() {}

  std::string* success;
  InvalidRequestException ire;
  SchemaDisagreementException sde;

  _Cassandra_system_update_column_family_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_execute_cql_query_args {
 public:

  Cassandra_execute_cql_query_args() : query(""), compression((Compression::type)0) {
  }

  virtual ~Cassandra_execute_cql_query_args() throw() {}

  std::string query;
  Compression::type compression;

  void __set_query(const std::string& val) {
    query = val;
  }

  void __set_compression(const Compression::type val) {
    compression = val;
  }

  bool operator == (const Cassandra_execute_cql_query_args & rhs) const
  {
    if (!(query == rhs.query))
      return false;
    if (!(compression == rhs.compression))
      return false;
    return true;
  }
  bool operator != (const Cassandra_execute_cql_query_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_execute_cql_query_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_execute_cql_query_pargs {
 public:


  virtual ~Cassandra_execute_cql_query_pargs() throw() {}

  const std::string* query;
  const Compression::type* compression;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_execute_cql_query_result__isset {
  _Cassandra_execute_cql_query_result__isset() : success(false), ire(false), ue(false), te(false), sde(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
  bool sde;
} _Cassandra_execute_cql_query_result__isset;

class Cassandra_execute_cql_query_result {
 public:

  Cassandra_execute_cql_query_result() {
  }

  virtual ~Cassandra_execute_cql_query_result() throw() {}

  CqlResult success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;
  SchemaDisagreementException sde;

  _Cassandra_execute_cql_query_result__isset __isset;

  void __set_success(const CqlResult& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_execute_cql_query_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_execute_cql_query_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_execute_cql_query_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_execute_cql_query_presult__isset {
  _Cassandra_execute_cql_query_presult__isset() : success(false), ire(false), ue(false), te(false), sde(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
  bool sde;
} _Cassandra_execute_cql_query_presult__isset;

class Cassandra_execute_cql_query_presult {
 public:


  virtual ~Cassandra_execute_cql_query_presult() throw() {}

  CqlResult* success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;
  SchemaDisagreementException sde;

  _Cassandra_execute_cql_query_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_prepare_cql_query_args {
 public:

  Cassandra_prepare_cql_query_args() : query(""), compression((Compression::type)0) {
  }

  virtual ~Cassandra_prepare_cql_query_args() throw() {}

  std::string query;
  Compression::type compression;

  void __set_query(const std::string& val) {
    query = val;
  }

  void __set_compression(const Compression::type val) {
    compression = val;
  }

  bool operator == (const Cassandra_prepare_cql_query_args & rhs) const
  {
    if (!(query == rhs.query))
      return false;
    if (!(compression == rhs.compression))
      return false;
    return true;
  }
  bool operator != (const Cassandra_prepare_cql_query_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_prepare_cql_query_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_prepare_cql_query_pargs {
 public:


  virtual ~Cassandra_prepare_cql_query_pargs() throw() {}

  const std::string* query;
  const Compression::type* compression;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_prepare_cql_query_result__isset {
  _Cassandra_prepare_cql_query_result__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_prepare_cql_query_result__isset;

class Cassandra_prepare_cql_query_result {
 public:

  Cassandra_prepare_cql_query_result() {
  }

  virtual ~Cassandra_prepare_cql_query_result() throw() {}

  CqlPreparedResult success;
  InvalidRequestException ire;

  _Cassandra_prepare_cql_query_result__isset __isset;

  void __set_success(const CqlPreparedResult& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_prepare_cql_query_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_prepare_cql_query_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_prepare_cql_query_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_prepare_cql_query_presult__isset {
  _Cassandra_prepare_cql_query_presult__isset() : success(false), ire(false) {}
  bool success;
  bool ire;
} _Cassandra_prepare_cql_query_presult__isset;

class Cassandra_prepare_cql_query_presult {
 public:


  virtual ~Cassandra_prepare_cql_query_presult() throw() {}

  CqlPreparedResult* success;
  InvalidRequestException ire;

  _Cassandra_prepare_cql_query_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_execute_prepared_cql_query_args {
 public:

  Cassandra_execute_prepared_cql_query_args() : itemId(0) {
  }

  virtual ~Cassandra_execute_prepared_cql_query_args() throw() {}

  int32_t itemId;
  std::vector<std::string>  values;

  void __set_itemId(const int32_t val) {
    itemId = val;
  }

  void __set_values(const std::vector<std::string> & val) {
    values = val;
  }

  bool operator == (const Cassandra_execute_prepared_cql_query_args & rhs) const
  {
    if (!(itemId == rhs.itemId))
      return false;
    if (!(values == rhs.values))
      return false;
    return true;
  }
  bool operator != (const Cassandra_execute_prepared_cql_query_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_execute_prepared_cql_query_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_execute_prepared_cql_query_pargs {
 public:


  virtual ~Cassandra_execute_prepared_cql_query_pargs() throw() {}

  const int32_t* itemId;
  const std::vector<std::string> * values;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_execute_prepared_cql_query_result__isset {
  _Cassandra_execute_prepared_cql_query_result__isset() : success(false), ire(false), ue(false), te(false), sde(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
  bool sde;
} _Cassandra_execute_prepared_cql_query_result__isset;

class Cassandra_execute_prepared_cql_query_result {
 public:

  Cassandra_execute_prepared_cql_query_result() {
  }

  virtual ~Cassandra_execute_prepared_cql_query_result() throw() {}

  CqlResult success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;
  SchemaDisagreementException sde;

  _Cassandra_execute_prepared_cql_query_result__isset __isset;

  void __set_success(const CqlResult& val) {
    success = val;
  }

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  void __set_ue(const UnavailableException& val) {
    ue = val;
  }

  void __set_te(const TimedOutException& val) {
    te = val;
  }

  void __set_sde(const SchemaDisagreementException& val) {
    sde = val;
  }

  bool operator == (const Cassandra_execute_prepared_cql_query_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(ire == rhs.ire))
      return false;
    if (!(ue == rhs.ue))
      return false;
    if (!(te == rhs.te))
      return false;
    if (!(sde == rhs.sde))
      return false;
    return true;
  }
  bool operator != (const Cassandra_execute_prepared_cql_query_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_execute_prepared_cql_query_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_execute_prepared_cql_query_presult__isset {
  _Cassandra_execute_prepared_cql_query_presult__isset() : success(false), ire(false), ue(false), te(false), sde(false) {}
  bool success;
  bool ire;
  bool ue;
  bool te;
  bool sde;
} _Cassandra_execute_prepared_cql_query_presult__isset;

class Cassandra_execute_prepared_cql_query_presult {
 public:


  virtual ~Cassandra_execute_prepared_cql_query_presult() throw() {}

  CqlResult* success;
  InvalidRequestException ire;
  UnavailableException ue;
  TimedOutException te;
  SchemaDisagreementException sde;

  _Cassandra_execute_prepared_cql_query_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Cassandra_set_cql_version_args {
 public:

  Cassandra_set_cql_version_args() : version("") {
  }

  virtual ~Cassandra_set_cql_version_args() throw() {}

  std::string version;

  void __set_version(const std::string& val) {
    version = val;
  }

  bool operator == (const Cassandra_set_cql_version_args & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const Cassandra_set_cql_version_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_set_cql_version_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Cassandra_set_cql_version_pargs {
 public:


  virtual ~Cassandra_set_cql_version_pargs() throw() {}

  const std::string* version;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_set_cql_version_result__isset {
  _Cassandra_set_cql_version_result__isset() : ire(false) {}
  bool ire;
} _Cassandra_set_cql_version_result__isset;

class Cassandra_set_cql_version_result {
 public:

  Cassandra_set_cql_version_result() {
  }

  virtual ~Cassandra_set_cql_version_result() throw() {}

  InvalidRequestException ire;

  _Cassandra_set_cql_version_result__isset __isset;

  void __set_ire(const InvalidRequestException& val) {
    ire = val;
  }

  bool operator == (const Cassandra_set_cql_version_result & rhs) const
  {
    if (!(ire == rhs.ire))
      return false;
    return true;
  }
  bool operator != (const Cassandra_set_cql_version_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cassandra_set_cql_version_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Cassandra_set_cql_version_presult__isset {
  _Cassandra_set_cql_version_presult__isset() : ire(false) {}
  bool ire;
} _Cassandra_set_cql_version_presult__isset;

class Cassandra_set_cql_version_presult {
 public:


  virtual ~Cassandra_set_cql_version_presult() throw() {}

  InvalidRequestException ire;

  _Cassandra_set_cql_version_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class CassandraClient : virtual public CassandraIf {
 public:
  CassandraClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  CassandraClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void login(const AuthenticationRequest& auth_request);
  void send_login(const AuthenticationRequest& auth_request);
  void recv_login();
  void set_keyspace(const std::string& keyspace);
  void send_set_keyspace(const std::string& keyspace);
  void recv_set_keyspace();
  void get(ColumnOrSuperColumn& _return, const std::string& key, const ColumnPath& column_path, const ConsistencyLevel::type consistency_level);
  void send_get(const std::string& key, const ColumnPath& column_path, const ConsistencyLevel::type consistency_level);
  void recv_get(ColumnOrSuperColumn& _return);
  void get_slice(std::vector<ColumnOrSuperColumn> & _return, const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  void send_get_slice(const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  void recv_get_slice(std::vector<ColumnOrSuperColumn> & _return);
  int32_t get_count(const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  void send_get_count(const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  int32_t recv_get_count();
  void multiget_slice(std::map<std::string, std::vector<ColumnOrSuperColumn> > & _return, const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  void send_multiget_slice(const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  void recv_multiget_slice(std::map<std::string, std::vector<ColumnOrSuperColumn> > & _return);
  void multiget_count(std::map<std::string, int32_t> & _return, const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  void send_multiget_count(const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level);
  void recv_multiget_count(std::map<std::string, int32_t> & _return);
  void get_range_slices(std::vector<KeySlice> & _return, const ColumnParent& column_parent, const SlicePredicate& predicate, const KeyRange& range, const ConsistencyLevel::type consistency_level);
  void send_get_range_slices(const ColumnParent& column_parent, const SlicePredicate& predicate, const KeyRange& range, const ConsistencyLevel::type consistency_level);
  void recv_get_range_slices(std::vector<KeySlice> & _return);
  void get_paged_slice(std::vector<KeySlice> & _return, const std::string& column_family, const KeyRange& range, const std::string& start_column, const ConsistencyLevel::type consistency_level);
  void send_get_paged_slice(const std::string& column_family, const KeyRange& range, const std::string& start_column, const ConsistencyLevel::type consistency_level);
  void recv_get_paged_slice(std::vector<KeySlice> & _return);
  void get_indexed_slices(std::vector<KeySlice> & _return, const ColumnParent& column_parent, const IndexClause& index_clause, const SlicePredicate& column_predicate, const ConsistencyLevel::type consistency_level);
  void send_get_indexed_slices(const ColumnParent& column_parent, const IndexClause& index_clause, const SlicePredicate& column_predicate, const ConsistencyLevel::type consistency_level);
  void recv_get_indexed_slices(std::vector<KeySlice> & _return);
  void insert(const std::string& key, const ColumnParent& column_parent, const Column& column, const ConsistencyLevel::type consistency_level);
  void send_insert(const std::string& key, const ColumnParent& column_parent, const Column& column, const ConsistencyLevel::type consistency_level);
  void recv_insert();
  void add(const std::string& key, const ColumnParent& column_parent, const CounterColumn& column, const ConsistencyLevel::type consistency_level);
  void send_add(const std::string& key, const ColumnParent& column_parent, const CounterColumn& column, const ConsistencyLevel::type consistency_level);
  void recv_add();
  void remove(const std::string& key, const ColumnPath& column_path, const int64_t timestamp, const ConsistencyLevel::type consistency_level);
  void send_remove(const std::string& key, const ColumnPath& column_path, const int64_t timestamp, const ConsistencyLevel::type consistency_level);
  void recv_remove();
  void remove_counter(const std::string& key, const ColumnPath& path, const ConsistencyLevel::type consistency_level);
  void send_remove_counter(const std::string& key, const ColumnPath& path, const ConsistencyLevel::type consistency_level);
  void recv_remove_counter();
  void batch_mutate(const std::map<std::string, std::map<std::string, std::vector<Mutation> > > & mutation_map, const ConsistencyLevel::type consistency_level);
  void send_batch_mutate(const std::map<std::string, std::map<std::string, std::vector<Mutation> > > & mutation_map, const ConsistencyLevel::type consistency_level);
  void recv_batch_mutate();
  void truncate(const std::string& cfname);
  void send_truncate(const std::string& cfname);
  void recv_truncate();
  void describe_schema_versions(std::map<std::string, std::vector<std::string> > & _return);
  void send_describe_schema_versions();
  void recv_describe_schema_versions(std::map<std::string, std::vector<std::string> > & _return);
  void describe_keyspaces(std::vector<KsDef> & _return);
  void send_describe_keyspaces();
  void recv_describe_keyspaces(std::vector<KsDef> & _return);
  void describe_cluster_name(std::string& _return);
  void send_describe_cluster_name();
  void recv_describe_cluster_name(std::string& _return);
  void describe_version(std::string& _return);
  void send_describe_version();
  void recv_describe_version(std::string& _return);
  void describe_ring(std::vector<TokenRange> & _return, const std::string& keyspace);
  void send_describe_ring(const std::string& keyspace);
  void recv_describe_ring(std::vector<TokenRange> & _return);
  void describe_token_map(std::map<std::string, std::string> & _return);
  void send_describe_token_map();
  void recv_describe_token_map(std::map<std::string, std::string> & _return);
  void describe_partitioner(std::string& _return);
  void send_describe_partitioner();
  void recv_describe_partitioner(std::string& _return);
  void describe_snitch(std::string& _return);
  void send_describe_snitch();
  void recv_describe_snitch(std::string& _return);
  void describe_keyspace(KsDef& _return, const std::string& keyspace);
  void send_describe_keyspace(const std::string& keyspace);
  void recv_describe_keyspace(KsDef& _return);
  void describe_splits(std::vector<std::string> & _return, const std::string& cfName, const std::string& start_token, const std::string& end_token, const int32_t keys_per_split);
  void send_describe_splits(const std::string& cfName, const std::string& start_token, const std::string& end_token, const int32_t keys_per_split);
  void recv_describe_splits(std::vector<std::string> & _return);
  void system_add_column_family(std::string& _return, const CfDef& cf_def);
  void send_system_add_column_family(const CfDef& cf_def);
  void recv_system_add_column_family(std::string& _return);
  void system_drop_column_family(std::string& _return, const std::string& column_family);
  void send_system_drop_column_family(const std::string& column_family);
  void recv_system_drop_column_family(std::string& _return);
  void system_add_keyspace(std::string& _return, const KsDef& ks_def);
  void send_system_add_keyspace(const KsDef& ks_def);
  void recv_system_add_keyspace(std::string& _return);
  void system_drop_keyspace(std::string& _return, const std::string& keyspace);
  void send_system_drop_keyspace(const std::string& keyspace);
  void recv_system_drop_keyspace(std::string& _return);
  void system_update_keyspace(std::string& _return, const KsDef& ks_def);
  void send_system_update_keyspace(const KsDef& ks_def);
  void recv_system_update_keyspace(std::string& _return);
  void system_update_column_family(std::string& _return, const CfDef& cf_def);
  void send_system_update_column_family(const CfDef& cf_def);
  void recv_system_update_column_family(std::string& _return);
  void execute_cql_query(CqlResult& _return, const std::string& query, const Compression::type compression);
  void send_execute_cql_query(const std::string& query, const Compression::type compression);
  void recv_execute_cql_query(CqlResult& _return);
  void prepare_cql_query(CqlPreparedResult& _return, const std::string& query, const Compression::type compression);
  void send_prepare_cql_query(const std::string& query, const Compression::type compression);
  void recv_prepare_cql_query(CqlPreparedResult& _return);
  void execute_prepared_cql_query(CqlResult& _return, const int32_t itemId, const std::vector<std::string> & values);
  void send_execute_prepared_cql_query(const int32_t itemId, const std::vector<std::string> & values);
  void recv_execute_prepared_cql_query(CqlResult& _return);
  void set_cql_version(const std::string& version);
  void send_set_cql_version(const std::string& version);
  void recv_set_cql_version();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class CassandraProcessor : public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<CassandraIf> iface_;
  virtual bool process_fn(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (CassandraProcessor::*)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_login(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_keyspace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_slice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_count(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_multiget_slice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_multiget_count(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_range_slices(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_paged_slice(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get_indexed_slices(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_insert(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_add(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_remove_counter(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_batch_mutate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_truncate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_schema_versions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_keyspaces(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_cluster_name(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_version(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_ring(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_token_map(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_partitioner(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_snitch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_keyspace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_describe_splits(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_system_add_column_family(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_system_drop_column_family(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_system_add_keyspace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_system_drop_keyspace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_system_update_keyspace(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_system_update_column_family(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_execute_cql_query(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_prepare_cql_query(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_execute_prepared_cql_query(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_set_cql_version(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  CassandraProcessor(boost::shared_ptr<CassandraIf> iface) :
    iface_(iface) {
    processMap_["login"] = &CassandraProcessor::process_login;
    processMap_["set_keyspace"] = &CassandraProcessor::process_set_keyspace;
    processMap_["get"] = &CassandraProcessor::process_get;
    processMap_["get_slice"] = &CassandraProcessor::process_get_slice;
    processMap_["get_count"] = &CassandraProcessor::process_get_count;
    processMap_["multiget_slice"] = &CassandraProcessor::process_multiget_slice;
    processMap_["multiget_count"] = &CassandraProcessor::process_multiget_count;
    processMap_["get_range_slices"] = &CassandraProcessor::process_get_range_slices;
    processMap_["get_paged_slice"] = &CassandraProcessor::process_get_paged_slice;
    processMap_["get_indexed_slices"] = &CassandraProcessor::process_get_indexed_slices;
    processMap_["insert"] = &CassandraProcessor::process_insert;
    processMap_["add"] = &CassandraProcessor::process_add;
    processMap_["remove"] = &CassandraProcessor::process_remove;
    processMap_["remove_counter"] = &CassandraProcessor::process_remove_counter;
    processMap_["batch_mutate"] = &CassandraProcessor::process_batch_mutate;
    processMap_["truncate"] = &CassandraProcessor::process_truncate;
    processMap_["describe_schema_versions"] = &CassandraProcessor::process_describe_schema_versions;
    processMap_["describe_keyspaces"] = &CassandraProcessor::process_describe_keyspaces;
    processMap_["describe_cluster_name"] = &CassandraProcessor::process_describe_cluster_name;
    processMap_["describe_version"] = &CassandraProcessor::process_describe_version;
    processMap_["describe_ring"] = &CassandraProcessor::process_describe_ring;
    processMap_["describe_token_map"] = &CassandraProcessor::process_describe_token_map;
    processMap_["describe_partitioner"] = &CassandraProcessor::process_describe_partitioner;
    processMap_["describe_snitch"] = &CassandraProcessor::process_describe_snitch;
    processMap_["describe_keyspace"] = &CassandraProcessor::process_describe_keyspace;
    processMap_["describe_splits"] = &CassandraProcessor::process_describe_splits;
    processMap_["system_add_column_family"] = &CassandraProcessor::process_system_add_column_family;
    processMap_["system_drop_column_family"] = &CassandraProcessor::process_system_drop_column_family;
    processMap_["system_add_keyspace"] = &CassandraProcessor::process_system_add_keyspace;
    processMap_["system_drop_keyspace"] = &CassandraProcessor::process_system_drop_keyspace;
    processMap_["system_update_keyspace"] = &CassandraProcessor::process_system_update_keyspace;
    processMap_["system_update_column_family"] = &CassandraProcessor::process_system_update_column_family;
    processMap_["execute_cql_query"] = &CassandraProcessor::process_execute_cql_query;
    processMap_["prepare_cql_query"] = &CassandraProcessor::process_prepare_cql_query;
    processMap_["execute_prepared_cql_query"] = &CassandraProcessor::process_execute_prepared_cql_query;
    processMap_["set_cql_version"] = &CassandraProcessor::process_set_cql_version;
  }

  virtual bool process(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~CassandraProcessor() {}
};

class CassandraProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  CassandraProcessorFactory(const ::boost::shared_ptr< CassandraIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< CassandraIfFactory > handlerFactory_;
};

class CassandraMultiface : virtual public CassandraIf {
 public:
  CassandraMultiface(std::vector<boost::shared_ptr<CassandraIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~CassandraMultiface() {}
 protected:
  std::vector<boost::shared_ptr<CassandraIf> > ifaces_;
  CassandraMultiface() {}
  void add(boost::shared_ptr<CassandraIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void login(const AuthenticationRequest& auth_request) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->login(auth_request);
    }
  }

  void set_keyspace(const std::string& keyspace) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->set_keyspace(keyspace);
    }
  }

  void get(ColumnOrSuperColumn& _return, const std::string& key, const ColumnPath& column_path, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get(_return, key, column_path, consistency_level);
        return;
      } else {
        ifaces_[i]->get(_return, key, column_path, consistency_level);
      }
    }
  }

  void get_slice(std::vector<ColumnOrSuperColumn> & _return, const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_slice(_return, key, column_parent, predicate, consistency_level);
        return;
      } else {
        ifaces_[i]->get_slice(_return, key, column_parent, predicate, consistency_level);
      }
    }
  }

  int32_t get_count(const std::string& key, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        return ifaces_[i]->get_count(key, column_parent, predicate, consistency_level);
      } else {
        ifaces_[i]->get_count(key, column_parent, predicate, consistency_level);
      }
    }
    return 0xDEADBEEF; //psergey: shut up the compiler
  }

  void multiget_slice(std::map<std::string, std::vector<ColumnOrSuperColumn> > & _return, const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->multiget_slice(_return, keys, column_parent, predicate, consistency_level);
        return;
      } else {
        ifaces_[i]->multiget_slice(_return, keys, column_parent, predicate, consistency_level);
      }
    }
  }

  void multiget_count(std::map<std::string, int32_t> & _return, const std::vector<std::string> & keys, const ColumnParent& column_parent, const SlicePredicate& predicate, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->multiget_count(_return, keys, column_parent, predicate, consistency_level);
        return;
      } else {
        ifaces_[i]->multiget_count(_return, keys, column_parent, predicate, consistency_level);
      }
    }
  }

  void get_range_slices(std::vector<KeySlice> & _return, const ColumnParent& column_parent, const SlicePredicate& predicate, const KeyRange& range, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_range_slices(_return, column_parent, predicate, range, consistency_level);
        return;
      } else {
        ifaces_[i]->get_range_slices(_return, column_parent, predicate, range, consistency_level);
      }
    }
  }

  void get_paged_slice(std::vector<KeySlice> & _return, const std::string& column_family, const KeyRange& range, const std::string& start_column, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_paged_slice(_return, column_family, range, start_column, consistency_level);
        return;
      } else {
        ifaces_[i]->get_paged_slice(_return, column_family, range, start_column, consistency_level);
      }
    }
  }

  void get_indexed_slices(std::vector<KeySlice> & _return, const ColumnParent& column_parent, const IndexClause& index_clause, const SlicePredicate& column_predicate, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->get_indexed_slices(_return, column_parent, index_clause, column_predicate, consistency_level);
        return;
      } else {
        ifaces_[i]->get_indexed_slices(_return, column_parent, index_clause, column_predicate, consistency_level);
      }
    }
  }

  void insert(const std::string& key, const ColumnParent& column_parent, const Column& column, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->insert(key, column_parent, column, consistency_level);
    }
  }

  void add(const std::string& key, const ColumnParent& column_parent, const CounterColumn& column, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->add(key, column_parent, column, consistency_level);
    }
  }

  void remove(const std::string& key, const ColumnPath& column_path, const int64_t timestamp, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->remove(key, column_path, timestamp, consistency_level);
    }
  }

  void remove_counter(const std::string& key, const ColumnPath& path, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->remove_counter(key, path, consistency_level);
    }
  }

  void batch_mutate(const std::map<std::string, std::map<std::string, std::vector<Mutation> > > & mutation_map, const ConsistencyLevel::type consistency_level) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->batch_mutate(mutation_map, consistency_level);
    }
  }

  void truncate(const std::string& cfname) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->truncate(cfname);
    }
  }

  void describe_schema_versions(std::map<std::string, std::vector<std::string> > & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_schema_versions(_return);
        return;
      } else {
        ifaces_[i]->describe_schema_versions(_return);
      }
    }
  }

  void describe_keyspaces(std::vector<KsDef> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_keyspaces(_return);
        return;
      } else {
        ifaces_[i]->describe_keyspaces(_return);
      }
    }
  }

  void describe_cluster_name(std::string& _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_cluster_name(_return);
        return;
      } else {
        ifaces_[i]->describe_cluster_name(_return);
      }
    }
  }

  void describe_version(std::string& _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_version(_return);
        return;
      } else {
        ifaces_[i]->describe_version(_return);
      }
    }
  }

  void describe_ring(std::vector<TokenRange> & _return, const std::string& keyspace) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_ring(_return, keyspace);
        return;
      } else {
        ifaces_[i]->describe_ring(_return, keyspace);
      }
    }
  }

  void describe_token_map(std::map<std::string, std::string> & _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_token_map(_return);
        return;
      } else {
        ifaces_[i]->describe_token_map(_return);
      }
    }
  }

  void describe_partitioner(std::string& _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_partitioner(_return);
        return;
      } else {
        ifaces_[i]->describe_partitioner(_return);
      }
    }
  }

  void describe_snitch(std::string& _return) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_snitch(_return);
        return;
      } else {
        ifaces_[i]->describe_snitch(_return);
      }
    }
  }

  void describe_keyspace(KsDef& _return, const std::string& keyspace) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_keyspace(_return, keyspace);
        return;
      } else {
        ifaces_[i]->describe_keyspace(_return, keyspace);
      }
    }
  }

  void describe_splits(std::vector<std::string> & _return, const std::string& cfName, const std::string& start_token, const std::string& end_token, const int32_t keys_per_split) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->describe_splits(_return, cfName, start_token, end_token, keys_per_split);
        return;
      } else {
        ifaces_[i]->describe_splits(_return, cfName, start_token, end_token, keys_per_split);
      }
    }
  }

  void system_add_column_family(std::string& _return, const CfDef& cf_def) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->system_add_column_family(_return, cf_def);
        return;
      } else {
        ifaces_[i]->system_add_column_family(_return, cf_def);
      }
    }
  }

  void system_drop_column_family(std::string& _return, const std::string& column_family) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->system_drop_column_family(_return, column_family);
        return;
      } else {
        ifaces_[i]->system_drop_column_family(_return, column_family);
      }
    }
  }

  void system_add_keyspace(std::string& _return, const KsDef& ks_def) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->system_add_keyspace(_return, ks_def);
        return;
      } else {
        ifaces_[i]->system_add_keyspace(_return, ks_def);
      }
    }
  }

  void system_drop_keyspace(std::string& _return, const std::string& keyspace) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->system_drop_keyspace(_return, keyspace);
        return;
      } else {
        ifaces_[i]->system_drop_keyspace(_return, keyspace);
      }
    }
  }

  void system_update_keyspace(std::string& _return, const KsDef& ks_def) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->system_update_keyspace(_return, ks_def);
        return;
      } else {
        ifaces_[i]->system_update_keyspace(_return, ks_def);
      }
    }
  }

  void system_update_column_family(std::string& _return, const CfDef& cf_def) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->system_update_column_family(_return, cf_def);
        return;
      } else {
        ifaces_[i]->system_update_column_family(_return, cf_def);
      }
    }
  }

  void execute_cql_query(CqlResult& _return, const std::string& query, const Compression::type compression) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->execute_cql_query(_return, query, compression);
        return;
      } else {
        ifaces_[i]->execute_cql_query(_return, query, compression);
      }
    }
  }

  void prepare_cql_query(CqlPreparedResult& _return, const std::string& query, const Compression::type compression) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->prepare_cql_query(_return, query, compression);
        return;
      } else {
        ifaces_[i]->prepare_cql_query(_return, query, compression);
      }
    }
  }

  void execute_prepared_cql_query(CqlResult& _return, const int32_t itemId, const std::vector<std::string> & values) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      if (i == sz - 1) {
        ifaces_[i]->execute_prepared_cql_query(_return, itemId, values);
        return;
      } else {
        ifaces_[i]->execute_prepared_cql_query(_return, itemId, values);
      }
    }
  }

  void set_cql_version(const std::string& version) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->set_cql_version(version);
    }
  }

};

}}} // namespace

#endif
