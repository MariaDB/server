#
# MDEV-36132 Optimizer support for functional indexes: handle GROUP/ORDER BY
#
create table t (c int, key (c));
insert into t select seq from seq_1_to_10000;
alter table t
add column vc int as (c + 1),
add index(vc);
explain select c from t order by c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index
explain select vc from t order by vc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10000	Using index
explain select vc from t order by vc limit 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10	Using index
explain select c + 1 from t order by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using filesort
explain select c + 1 from t order by vc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using filesort
explain select vc from t order by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10000	Using index
explain select vc from t order by c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index
explain select c from t order by vc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using filesort
explain select c from t order by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using filesort
explain select vc from t order by c + 1 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	Using index
explain select c + 1 from t order by c + 1 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	
explain select c + 1 from t order by vc limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	
explain delete from t order by c + 1 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	
alter table t add column d int;
explain update t set d = 500 order by c + 1 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	Using buffer
explain update t set d = 500 order by c limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	2	Using buffer
explain update t set c = 500 order by c + 1 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	Using buffer
explain update t set c = 500 order by c limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	2	Using buffer
drop table t;
create table t (c int);
insert into t select seq from seq_1_to_10000;
alter table t
add column vc int as (c + 1),
add index(vc);
explain select vc from t order by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10000	Using index
explain select vc from t order by c + 1 limit 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10	Using index
drop table t;
create table t (c int, key (c));
insert into t select seq from seq_1_to_10000;
alter table t
add column vc1 int as (c + 1),
add index(vc1);
alter table t
add column vc2 int as (vc1 * 2),
add index(vc2);
explain select c from t order by vc2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using filesort
explain select vc2 from t order by vc1 * 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc2	5	NULL	10000	Using index
explain select vc2 from t order by vc1 * 2 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc2	5	NULL	2	Using index
drop table t;
create table t (c int, vc int generated always as (1 + 1) virtual, key (c));
insert into t values (42, default), (83, default);
explain select vc from t order by vc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	2	Using index; Using filesort
select vc from t order by vc;
vc
2
2
drop table t;
create table t (c int);
insert into t select seq from seq_1_to_10000;
alter table t
add column vc1 int as (c + 1);
alter table t
add column vc2 int as (1 - c),
add index(vc1, vc2);
explain select vc1, vc2 from t order by c + 1, 1 - c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc1	10	NULL	10000	Using index
drop table t;
create table t (c int, key (c));
insert into t select seq from seq_1_to_10000;
alter table t
add column vc int as (c + 1),
add index(vc);
explain select c from t group by c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index
explain select vc from t group by vc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10000	Using index
explain select vc from t group by vc limit 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10	Using index
explain select c + 1 from t group by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using temporary; Using filesort
explain select c + 1 from t group by vc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using temporary; Using filesort
explain select vc from t group by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10000	Using index
explain select vc from t group by c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index
explain select c from t group by vc;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using temporary; Using filesort
explain select c from t group by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using temporary; Using filesort
explain select vc from t group by c + 1 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	Using index
explain select c + 1 from t group by c + 1 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	
explain select c + 1 from t group by vc limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	2	
drop table t;
create table t (c int);
insert into t select seq from seq_1_to_10000;
alter table t
add column vc int as (c + 1),
add index(vc);
explain select vc from t group by c + 1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10000	Using index
explain select vc from t group by c + 1 limit 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc	5	NULL	10	Using index
drop table t;
create table t (c int, key (c));
insert into t select seq from seq_1_to_10000;
alter table t
add column vc1 int as (c + 1),
add index(vc1);
alter table t
add column vc2 int as (vc1 * 2),
add index(vc2);
explain select c from t group by vc2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	c	5	NULL	10000	Using index; Using temporary; Using filesort
explain select vc2 from t group by vc1 * 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc2	5	NULL	10000	Using index
explain select vc2 from t group by vc1 * 2 limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc2	5	NULL	2	Using index
drop table t;
create table t (c int);
insert into t select seq from seq_1_to_10000;
alter table t
add column vc1 int as (c + 1);
alter table t
add column vc2 int as (1 - c),
add index(vc1, vc2);
explain select vc1, vc2 from t group by c + 1, 1 - c;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t	index	NULL	vc1	10	NULL	10000	Using index
drop table t;
#
# MDEV-37435 Assertion `field' failed in virtual bool Item_field::fix_fields(THD *, Item **)
#
CREATE TABLE t (a INT,a1 INT AS (a) VIRTUAL,INDEX (a1));
SELECT a FROM t GROUP BY a HAVING a>2;
a
SELECT a FROM t WHERE a=(SELECT a FROM t GROUP BY a HAVING a>2);
a
drop table t;
#
# MDEV-37422 SIGSEGV failed in base_list_iterator::replace, Assertion `n < m_size' in Bounds_checked_array, ASAN use-after-poison in JOIN::rollup_make_fields
#
# original case
CREATE TABLE t (a INT,b INT,a1 INT GENERATED ALWAYS AS (a) VIRTUAL,INDEX (a1)) ENGINE=INNODB;
SELECT * FROM t GROUP BY a WITH ROLLUP;
a	b	a1
drop table t;
# vcol subst group by with rollup
CREATE TABLE t (a INT,b INT,a1 INT GENERATED ALWAYS AS (a) VIRTUAL,INDEX (a1)) ENGINE=INNODB;
insert into t (a, b) select seq / 10, seq from seq_1_to_100;
SELECT * FROM t GROUP BY a WITH ROLLUP;
a	b	a1
0	1	0
1	14	1
2	21	2
3	31	3
4	41	4
5	51	5
6	61	6
7	71	7
8	81	8
9	91	9
10	99	10
NULL	99	10
SELECT a, b FROM t GROUP BY a WITH ROLLUP;
a	b
0	1
1	14
2	21
3	31
4	41
5	51
6	61
7	71
8	81
9	91
10	99
NULL	99
SELECT a, count(b) FROM t GROUP BY a WITH ROLLUP;
a	count(b)
0	4
1	10
2	10
3	10
4	10
5	10
6	10
7	10
8	10
9	10
10	6
NULL	100
SELECT a, a, count(b) FROM t GROUP BY a WITH ROLLUP;
a	a	count(b)
0	0	4
1	1	10
2	2	10
3	3	10
4	4	10
5	5	10
6	6	10
7	7	10
8	8	10
9	9	10
10	10	6
NULL	NULL	100
SELECT a, a + 1, count(b) FROM t GROUP BY a WITH ROLLUP;
a	a + 1	count(b)
0	1	4
1	2	10
2	3	10
3	4	10
4	5	10
5	6	10
6	7	10
7	8	10
8	9	10
9	10	10
10	11	6
NULL	NULL	100
SELECT count(b) FROM t GROUP BY a WITH ROLLUP;
count(b)
4
10
10
10
10
10
10
10
10
10
6
100
drop table t;
# nontrivial vcol subst group by with rollup
CREATE TABLE t (a INT,b INT,a1 INT GENERATED ALWAYS AS (a + 1) VIRTUAL,INDEX (a1)) ENGINE=INNODB;
insert into t (a, b) select seq / 10, seq from seq_1_to_100;
SELECT * FROM t GROUP BY a + 1 WITH ROLLUP;
a	b	a1
0	1	1
1	14	2
2	21	3
3	31	4
4	41	5
5	51	6
6	61	7
7	71	8
8	81	9
9	91	10
10	99	11
10	99	11
SELECT a + 1, b FROM t GROUP BY a + 1 WITH ROLLUP;
a + 1	b
1	1
2	14
3	21
4	31
5	41
6	51
7	61
8	71
9	81
10	91
11	99
NULL	99
SELECT a + 1, count(b) FROM t GROUP BY a + 1 WITH ROLLUP;
a + 1	count(b)
1	4
2	10
3	10
4	10
5	10
6	10
7	10
8	10
9	10
10	10
11	6
NULL	100
SELECT a + 1, a + 1, count(b) FROM t GROUP BY a + 1 WITH ROLLUP;
a + 1	a + 1	count(b)
1	1	4
2	2	10
3	3	10
4	4	10
5	5	10
6	6	10
7	7	10
8	8	10
9	9	10
10	10	10
11	11	6
NULL	NULL	100
SELECT a + 1, a, count(b) FROM t GROUP BY a + 1 WITH ROLLUP;
a + 1	a	count(b)
1	0	4
2	1	10
3	2	10
4	3	10
5	4	10
6	5	10
7	6	10
8	7	10
9	8	10
10	9	10
11	10	6
NULL	10	100
SELECT count(b) FROM t GROUP BY a + 1 WITH ROLLUP;
count(b)
4
10
10
10
10
10
10
10
10
10
6
100
drop table t;
# multiple rollup levels vcol subst group by with rollup
CREATE TABLE t (a INT,b INT, c INT,a1 INT GENERATED ALWAYS AS (a) VIRTUAL, b1 INT GENERATED ALWAYS AS (b) VIRTUAL,INDEX (a1, b1)) ENGINE=INNODB;
insert into t (a, b, c) select seq / 20, seq / 10, seq from seq_1_to_100;
SELECT * FROM t GROUP BY a, b WITH ROLLUP;
a	b	c	a1	b1
0	0	1	0	0
0	1	9	0	1
0	NULL	9	0	1
1	1	14	1	1
1	2	24	1	2
1	3	29	1	3
1	NULL	29	1	3
2	3	34	2	3
2	4	44	2	4
2	5	49	2	5
2	NULL	49	2	5
3	5	54	3	5
3	6	64	3	6
3	7	69	3	7
3	NULL	69	3	7
4	7	74	4	7
4	8	84	4	8
4	9	89	4	9
4	NULL	89	4	9
5	9	94	5	9
5	10	95	5	10
5	NULL	95	5	10
NULL	NULL	95	5	10
SELECT a, b FROM t GROUP BY a, b WITH ROLLUP;
a	b
0	0
0	1
0	NULL
1	1
1	2
1	3
1	NULL
2	3
2	4
2	5
2	NULL
3	5
3	6
3	7
3	NULL
4	7
4	8
4	9
4	NULL
5	9
5	10
5	NULL
NULL	NULL
SELECT a, b, count(c) FROM t GROUP BY a, b WITH ROLLUP;
a	b	count(c)
0	0	4
0	1	5
0	NULL	9
1	1	5
1	2	10
1	3	5
1	NULL	20
2	3	5
2	4	10
2	5	5
2	NULL	20
3	5	5
3	6	10
3	7	5
3	NULL	20
4	7	5
4	8	10
4	9	5
4	NULL	20
5	9	5
5	10	6
5	NULL	11
NULL	NULL	100
SELECT count(c) FROM t GROUP BY a, b WITH ROLLUP;
count(c)
4
5
9
5
10
5
20
5
10
5
20
5
10
5
20
5
10
5
20
5
6
11
100
drop table t;
# multiple rollup levels nontrivial vcol subst group by with rollup
CREATE TABLE t (a INT,b INT, c INT,a1 INT GENERATED ALWAYS AS (a+1) VIRTUAL, b1 INT GENERATED ALWAYS AS (b+1) VIRTUAL,INDEX (a1, b1)) ENGINE=INNODB;
insert into t (a, b, c) select seq / 20, seq / 10, seq from seq_1_to_100;
SELECT * FROM t GROUP BY a + 1, b + 1 WITH ROLLUP;
a	b	c	a1	b1
0	0	1	1	1
0	1	9	1	2
0	1	9	1	2
1	1	14	2	2
1	2	24	2	3
1	3	29	2	4
1	3	29	2	4
2	3	34	3	4
2	4	44	3	5
2	5	49	3	6
2	5	49	3	6
3	5	54	4	6
3	6	64	4	7
3	7	69	4	8
3	7	69	4	8
4	7	74	5	8
4	8	84	5	9
4	9	89	5	10
4	9	89	5	10
5	9	94	6	10
5	10	95	6	11
5	10	95	6	11
5	10	95	6	11
SELECT a + 1, b + 1 FROM t GROUP BY a + 1, b + 1 WITH ROLLUP;
a + 1	b + 1
1	1
1	2
1	NULL
2	2
2	3
2	4
2	NULL
3	4
3	5
3	6
3	NULL
4	6
4	7
4	8
4	NULL
5	8
5	9
5	10
5	NULL
6	10
6	11
6	NULL
NULL	NULL
SELECT a + 1, b + 1, count(c) FROM t GROUP BY a + 1, b + 1 WITH ROLLUP;
a + 1	b + 1	count(c)
1	1	4
1	2	5
1	NULL	9
2	2	5
2	3	10
2	4	5
2	NULL	20
3	4	5
3	5	10
3	6	5
3	NULL	20
4	6	5
4	7	10
4	8	5
4	NULL	20
5	8	5
5	9	10
5	10	5
5	NULL	20
6	10	5
6	11	6
6	NULL	11
NULL	NULL	100
SELECT count(c) FROM t GROUP BY a + 1, b + 1 WITH ROLLUP;
count(c)
4
5
9
5
10
5
20
5
10
5
20
5
10
5
20
5
10
5
20
5
6
11
100
drop table t;
