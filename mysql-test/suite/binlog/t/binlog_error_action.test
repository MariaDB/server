--echo
--echo # MDEV-17856 Port binlog_error_action from MySQL
--echo
###############################################################################
# Bug#11758766:MYSQLD CONTINUES OPERATION WITHOUT LOGGING WHEN BINLOGS
# CANNOT BE WRITTEN
#
# Problem:
# ========
# If an error occurs that prevents mysqld writing to the binary logs (disk
# full, readonly filesystem, etc) then the logs are disabled and operations
# continue. This can lead to out of sync slaves and improper backups.
#
# Test:
# =====
# A new option "binlog_error_action" has been introduced whose values
# are "IGNORE" or "ABORT". When binlogging becomes impossible if user sets
# the variable to "ABORT" server will stop if user sets it to "IGNORE" binlog
# will be turned off and server will continue. 4 different test cases are
# added to check both the behaviours.
###############################################################################

--source include/have_log_bin.inc
--source include/have_debug.inc
--source include/not_valgrind.inc
--source include/not_crashrep.inc

# copied from MySQL but selectively enabled for examining
# call mtr.add_suppression("MYSQL_BIN_LOG::add_log_to_index failed to copy index file to crash safe index file.");
# call mtr.add_suppression("Disk is full writing *");
# call mtr.add_suppression("Error writing file.*");
# call mtr.add_suppression("Could not open .*");
call mtr.add_suppression("Could not use \\S+ for logging ");
call mtr.add_suppression("Can't generate a unique log-filename");
call mtr.add_suppression("Turning logging off");
call mtr.add_suppression("Waiting for someone to free space");
call mtr.add_suppression("Retry in \\d+ sec");
# call mtr.add_suppression("The server was unable to create a new log file *");
# call mtr.add_suppression("An error occured during flushing cache to file.");

RESET MASTER;
let $old=`select @@debug`;
let $default_binlog_error_action=`SELECT @@GLOBAL.binlog_error_action`;

--echo Test case1
# Make binlog index readonly and check the behaviour with ABORT
let $MYSQLD_DATADIR= `select @@datadir`;
let $INDEX=$MYSQLD_DATADIR/mysqld-bin.index;
--chmod 0444 $INDEX
SET GLOBAL binlog_error_action= ABORT_SERVER;
--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
#mysql had it ER_BINLOG_LOGGING_IMPOSSIBLE but i dont wanna
--error 29
flush logs;
--source include/wait_until_disconnected.inc
--chmod 0666 $INDEX
--exec echo "restart" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--enable_reconnect
--source include/wait_until_connected_again.inc

--echo Test case2
# Make MYSQL_BIN_LOG::open fail with debug simulation and test
# the behaviour in case of ABORT
SET SESSION debug="+d,fault_injection_updating_index";
SET GLOBAL binlog_error_action= ABORT_SERVER;
--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--error ER_BINLOG_LOGGING_IMPOSSIBLE
flush logs;
--source include/wait_until_disconnected.inc
--exec echo "restart" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--enable_reconnect
--source include/wait_until_connected_again.inc

#FIXME: hangs
# Waiting for someone to free space... (Expect up to 60 secs delay for server to continue after freeing disk space)
# Retry in 60 secs. Message reprinted in 600 secs
#--echo Test case3
## Simulate file write error (diskfull) during opening of binlog and check for diskfull error
## behaviour where binlog error action is to abort the server.
#SET SESSION debug="+d,simulate_file_write_error";
#SET GLOBAL binlog_error_action= ABORT_SERVER;
#--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
#--error ER_BINLOG_LOGGING_IMPOSSIBLE
#flush logs;
#--source include/wait_until_disconnected.inc
#--exec echo "restart" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
#--enable_reconnect4
#--source include/wait_until_connected_again.inc

--echo Test case4
SET SESSION debug="+d,fault_injection_init_name";
SET GLOBAL binlog_error_action= ABORT_SERVER;
--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--error ER_BINLOG_LOGGING_IMPOSSIBLE
flush logs;
--source include/wait_until_disconnected.inc
--exec echo "restart" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--enable_reconnect
--source include/wait_until_connected_again.inc

--echo Test case5
# Make binlog index readonly and check the behaviour with IGNORE
SET GLOBAL binlog_error_action= IGNORE_ERROR;
--chmod 0444 $INDEX
#--replace_regex /\.[\\\/]mysqld/mysqld/ /Errcode: 13 ".*"\)/Errcode: 13 "Permission denied")/
--error 29
flush logs;
CREATE TABLE t1 ( f int );
SHOW TABLES;
DROP TABLE t1;
--chmod 0666 $INDEX
--source include/restart_mysqld.inc

--echo Test case6
# Make MYSQL_BIN_LOG::open_binlog fail with debug simulation and test
# the behaviour in case of IGNORE
SET GLOBAL binlog_error_action= IGNORE_ERROR;
SET SESSION debug="+d,fault_injection_updating_index";
#--replace_regex /\.[\\\/]master/master/ /errno: 1 ".*"\)/errno: 1 "Operation not permitted")/
--error ER_CANT_OPEN_FILE
flush logs;
CREATE TABLE t2 (f int );
SHOW TABLES;
DROP TABLE t2;
SET SESSION debug="-d,fault_injection_updating_index";
--source include/restart_mysqld.inc

#FIXME: also hangs
#--echo Test case7
## Simulate diskfull during opening of binlog and check for diskfull error
## behaviour where binlog error action is to continue the server
## after the error.
#SET GLOBAL binlog_error_action= IGNORE_ERROR;
#SET SESSION debug="+d,simulate_file_write_error";
##--replace_regex /\.[\\\/]master/master/ /Errcode: 28 ".*"\)/Errcode: 28 "No space left on device")/
## error EE_WRITE with error code number 3 is expected.
#--error 3
#flush logs;
#SET SESSION debug="-d,simulate_file_write_error";
#--source include/restart_mysqld.inc

--echo Test case8
SET GLOBAL binlog_error_action= IGNORE_ERROR;
SET SESSION debug="+d,fault_injection_init_name";
#--replace_regex /\.[\\\/]master/master/ /errno: 1 ".*"\)/errno: 1 "Operation not permitted")/
--error ER_CANT_OPEN_FILE
flush logs;
CREATE TABLE t2 (f int );
SHOW TABLES;
DROP TABLE t2;
SET SESSION debug="-d,fault_injection_init_name";
--source include/restart_mysqld.inc

#XXX: This was From their follow-up commit, but I donâ€™t find anything resembling in our version of `log.cc`
# https://github.com/mysql/mysql-server/commit/3b6b4bf8c5d1bfada58678acebafdf6f813c2dfe#diff-0464eed4eba118bfe876fa26af42bbf449724a332247e64685cd5b73f1922a51
#--echo Test case9
#CREATE TABLE t1(i INT);
## Simulate error during flushing cache to file and test the behaviour
## when binlog_error_action is set to ABORT_SERVER/IGNORE_ERROR.
#SET SESSION debug="+d,simulate_error_during_flush_cache_to_file";
#SET GLOBAL binlog_error_action= ABORT_SERVER;
#--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
#--error ER_BINLOG_LOGGING_IMPOSSIBLE
#INSERT INTO t1 VALUES (1);
#--source include/wait_until_disconnected.inc
#--exec echo "restart" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
#--enable_reconnect
#--source include/wait_until_connected_again.inc
#
#--let $assert_cond= COUNT(*) = 0 FROM t1;
#--let $assert_text= Count of elements in t1 should be 0.
#--source include/assert.inc
#
#SET SESSION debug="+d,simulate_error_during_flush_cache_to_file";
#SET GLOBAL binlog_error_action= IGNORE_ERROR;
#INSERT INTO t1 VALUES (2);
#
#--let $assert_cond= COUNT(*) = 1 FROM t1;
#--let $assert_text= Count of elements in t1 should be 1.
#--source include/assert.inc
#
#DROP table t1;
#SET SESSION debug="-d,simulate_error_during_flush_cache_to_file";
#--source include/restart_mysqld.inc

###############################################################################
# Bug#20805298: BINLOG_ERROR_ACTION DOESN'T HANDLE SOME
# FAILURES DURING BINLOG ROTATION
#
# Problem:
# ========
# Hardware errors in binlog partition during binlog rotate are not handled by
# binlog_error_action.
#
# Test:
# =====
# Simulate failure during creation of new binary log file name. Set
# binlog_error_action to "IGNORE_ERROR" and observe that the binary log gets
# disabled and the server continues by logging an appropriate error message in
# error log file. Set binlog_error_action to "ABORT_ERROR" and observe that
# the
# server aborts when creation of new binarylog file name fails.
###############################################################################
# they were ENGINE=InnoDB in MySQL

echo "Test case10";
# Test error scenario with binlog_error_action=IGNORE_ERROR
CREATE TABLE t1 (a INT);
SET GLOBAL binlog_error_action=IGNORE_ERROR;
SET SESSION debug='+d,error_unique_log_filename';
--error ER_NO_UNIQUE_LOGFILE
FLUSH LOGS;
DROP TABLE t1;
SET SESSION debug='-d,error_unique_log_filename';
# Test to prove that binary log is disabled
--error ER_NO_BINARY_LOGGING
SHOW BINARY LOGS;
--source include/restart_mysqld.inc

echo "Test case11";
# Test error scenario with binlog_error_action=ABORT_SERVER
CREATE TABLE t1 (a INT);
SET GLOBAL binlog_error_action=ABORT_SERVER;
SET SESSION debug='+d,error_unique_log_filename';
--exec echo "wait" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
#mysql had it ER_BINLOG_LOGGING_IMPOSSIBLE but i dont wanna
--error ER_NO_UNIQUE_LOGFILE
FLUSH LOGS;
--source include/wait_until_disconnected.inc
--exec echo "restart" > $MYSQLTEST_VARDIR/tmp/mysqld.1.expect
--enable_reconnect
--source include/wait_until_connected_again.inc
DROP TABLE t1;

# Cleanup
--eval SET SESSION debug="$old"
--eval SET GLOBAL binlog_error_action= $default_binlog_error_action
