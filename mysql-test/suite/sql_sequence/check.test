--source include/have_innodb.inc

# Check failure of underlying engine
create sequence s;
let $datadir= `select @@datadir`;
remove_file $datadir/test/s.MYD;
write_file $datadir/test/s.MYD;
foo
EOF
call mtr.add_suppression("ha_myisam");
call mtr.add_suppression("Checking table");
check table s;
drop table s;

# Insert a row into a sequence table updates that row
create sequence s;
insert into s values (3,1,9223372036854775806,1,1,1000,0,0);
select * from s;
# ok
check table s;
--disable_ps2_protocol
select nextval(s);
--enable_ps2_protocol
drop sequence s;

# Insert a row into a non-sequence table then turn it into a sequence
# table
create sequence s;
alter table s sequence=0;
insert into s values (3,1,9223372036854775806,1,1,1000,0,0);
select * from s;
alter table s sequence=1;
check table s;
# Only the first row appears
select * from s;
check table s;
--disable_ps2_protocol
select nextval(s);
--enable_ps2_protocol
check table s;
drop sequence s;

# Insert a wrong row (min > max)
create sequence s;
alter table s sequence=0 engine=innodb;
delete from s;
insert into s values (2,500,200,1,1,1000,0,0);
select * from s;
alter table s sequence=1;
check table s;
select * from s;
# SELECT NEXTVAL does not fail, with or without execution of check
# table beforehand, even though the sequence metadata is wrong. This
# should be a separate issue to fix, if needed.
--disable_ps2_protocol
select nextval(s);
--enable_ps2_protocol
check table s;
# REPAIR is still delegated to the underlying engine. It is not
# implemented in innodb. In this case the printing of
# HA_ERR_SEQUENCE_INVALID_DATA happens when trying to write row in
# mysql_alter_table through a call to admin_recreate_table().
repair table s;
drop sequence s;

# Sequence run out tests.
#
# General principle: CHECK TABLE of a sequence table returns OK with a
# warning of ER_SEQUENCE_RUN_OUT if a SELECT NEXTVAL of the sequence
# in place of the CHECK TABLE statement would report
# ER_SEQUENCE_RUN_OUT.
create sequence s minvalue 13 maxvalue 15 increment by 4;
check table s;
--disable_ps2_protocol
select nextval(s);
--enable_ps2_protocol
check table s;
alter sequence s cycle;
check table s;
alter sequence s nocycle;
check table s;
# Still get run out because next_free_value has not changed. same
# would happen with a SELECT NEXTVAL(s) statement without the
# preceding check table statement.
alter sequence s increment by 1;
check table s;
alter sequence s increment by 4;
# If all_values_used is true, and then we make sequence cycle, check
# table will be ok without warning, as expected. this is because the
# ALTER SEQUENCE statement causes all_values_used to be reset.
--disable_ps2_protocol
--error ER_SEQUENCE_RUN_OUT
select nextval(s);
--enable_ps2_protocol
alter sequence s cycle;
check table s;
alter sequence s maxvalue 23 nocycle;
check table s;
alter sequence s maxvalue 15;
check table s;
drop sequence s;

# CHECK TABLE calls sequence_definition::check_and_adjust() with
# adjust_next=false, so that there will be no flushing of
# next_free_value in this call, hence no running out
create sequence s minvalue 13 maxvalue 20 increment by 1;
--disable_ps2_protocol
select nextval(s);
--enable_ps2_protocol
check table s;
--disable_ps2_protocol
select nextval(s);
--enable_ps2_protocol
drop sequence s;

# Without the CHECK TABLE statement below, the ALTER TABLE ...
# SEQUENCE=1 statement would still cause flushing in subsequent SELECT
# NEXTVAL statement (initialized == SQUENCE:SQL_UNITIALIZED =>
# read_initial_value() => => sequence_defitinion::adjust_values()),
# resulting in sequence running out.

# Same effect takes place with ALTER SEQUENCE, though different cause:
# in ALTER SEQUENCE, sequence_defitinion::adjust_values() is called in
# sequence_definition::check_and_adjust() which is called in
# Sql_cmd_alter_sequence::execute()
create sequence s minvalue 13 maxvalue 20 increment by 1;
--disable_ps2_protocol
select nextval(s);
--enable_ps2_protocol
alter table s sequence=0;
alter table s sequence=1;
check table s;
--disable_ps2_protocol
--error ER_SEQUENCE_RUN_OUT
select nextval(s);
--enable_ps2_protocol
drop sequence s;

# Directly create a table with wrong structure is detected, therefore
# no check is needed
CREATE TABLE `s` (
  # `next_not_cached_value` bigint(21) NOT NULL,
  `minimum_value` bigint(21) NOT NULL,
  `maximum_value` bigint(21) NOT NULL,
  `start_value` bigint(21) NOT NULL COMMENT 'start value when sequences is created or value if RESTART is used',
  `increment` bigint(21) NOT NULL COMMENT 'increment value',
  `cache_size` bigint(21) unsigned NOT NULL,
  `cycle_option` tinyint(1) unsigned NOT NULL COMMENT '0 if no cycles are allowed, 1 if the sequence should begin a new cycle when maximum_value is passed',
  `cycle_count` bigint(21) NOT NULL COMMENT 'How many cycles have been done'
) ENGINE=innodb;
--error ER_SEQUENCE_INVALID_TABLE_STRUCTURE
alter table s sequence=1;
drop table s;

# Altering a sequence table to a wrong structure is detected,
# therefore no check needed
create sequence s;
--error ER_SEQUENCE_INVALID_TABLE_STRUCTURE
alter table s drop column next_not_cached_value;
drop sequence s;

--echo #
--echo # MDEV-35866 mariadb-check does not return warning for incorrect sequence with engine InnoDB
--echo #
--source include/have_innodb.inc
CREATE TABLE `s1` (
`next_not_cached_value` bigint(21) NOT NULL,
`minimum_value` bigint(21) NOT NULL,
`maximum_value` bigint(21) NOT NULL,
`start_value` bigint(21) NOT NULL COMMENT 'start value when sequences is created or value if RESTART is used',
`increment` bigint(21) NOT NULL COMMENT 'increment value',
`cache_size` bigint(21) unsigned NOT NULL,
`cycle_option` tinyint(1) unsigned NOT NULL COMMENT '0 if no cycles are allowed, 1 if the sequence should begin a new cycle when maximum_value is passed',
`cycle_count` bigint(21) NOT NULL COMMENT 'How many cycles have been done'
) ENGINE=innodb;

# CHECK fails with error: no record
alter table s1 sequence=1;
call mtr.add_suppression("\\[ERROR\\] mariadbd: Can't find record in 's1'");
check table s1;

# CHECK succeeds
alter table s1 sequence=0;
insert into s1 values (1,1,9223372036854775806,1,1,1000,0,0);
alter table s1 sequence=1;
check table s1;

# CHECK succeeds with warning more than one row
alter table s1 sequence=0;
insert into s1 values (2,1,9223372036854775806,1,1,1000,0,0);
alter table s1 sequence=1;
check table s1;

# CHECK succeeds with warning more than one row
alter table s1 sequence=0;
insert into s1 values (3,1,9223372036854775806,1,1,1000,0,0);
alter table s1 sequence=1;
check table s1;

drop sequence s1;
