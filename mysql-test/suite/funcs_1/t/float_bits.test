###################################################
#                                                 #
#  Demonstrates the use of data interchange       #
#  functions for exchanging floating-point values #
#                                                 #
#  Also demonstrates the use where floating point #
#  comparisions act in surprising ways.           #
#                                                 #
###################################################

SELECT float_to_int32_bits(1.0);
SELECT int32_bits_to_float(1065353216);

SELECT float_to_int32_bits(-12.5);
SELECT int32_bits_to_float(-1052246016);

SELECT double_to_int64_bits(1.0);
SELECT int64_bits_to_double(4607182418800017408);

SELECT double_to_int64_bits(-12.5);
SELECT int64_bits_to_double(-4600145544382251008);

CREATE TABLE t1
(
  id bigint,
  d double,
  PRIMARY KEY (id)
);
INSERT INTO t1 VALUES (1, 0.671437), (2, -1.5);
SELECT id, d FROM t1;

SELECT 'with double-precision floating point (64 bit)\n we get the results we asked for every time:' AS _docs;
SELECT id, d FROM t1 WHERE d = 0.671437;
SELECT id, d FROM t1 WHERE d = -1.5;

CREATE TABLE t2
(
  id int,
  f float,
  PRIMARY KEY (id)
);
INSERT INTO t2 VALUES (1, 0.671437), (2, -1.5);
SELECT id,f FROM t2;

SELECT 'with single-precision float (32 bit)\n we DO NOT get the results we asked for every time,\n just sometimes:' AS _docs;
SELECT id, f FROM t2 WHERE f = 0.671437;
SELECT id, f FROM t2 WHERE f = -1.5;

SELECT 'with interchange values, we can get what we expect:' AS _docs;
SELECT id, f FROM t2
WHERE float_to_int32_bits(f) = float_to_int32_bits(0.671437);

SELECT id, f FROM t2
WHERE float_to_int32_bits(f) = float_to_int32_bits(-1.5);

SELECT 'Some corner case values for double-precision' AS _docs;
INSERT INTO t1 VALUES
(3, NULL),
(4, 0),
(5,  1.7976931348623157E+308),
(6, -1.7976931348623157E+308),
(7,  2.2250738585072014E-308),
(8, -2.2250738585072014E-308);

SELECT	id,
	d,
	double_to_int64_bits(d),
	int64_bits_to_double(double_to_int64_bits(d)),
	d = int64_bits_to_double(double_to_int64_bits(d))
FROM t1;

SELECT 'Some corner case values for single-precision' AS _docs;
INSERT INTO t2 VALUES
(3, NULL),
(4, 0),
(5,  3.402823466E+38),
(6, -3.402823466E+38),
(7,  1.175494351E-38),
(8, -1.175494351E-38);

SELECT	id,
	f,
	float_to_int32_bits(f),
	int32_bits_to_float(float_to_int32_bits(f)),
	f = int32_bits_to_float(float_to_int32_bits(f))
FROM t2;

SELECT 'demonstrate sign flexibility:' AS _docs;
SELECT int32_bits_to_float(2222222222);
SELECT int32_bits_to_float(-2072745074);
SELECT int64_bits_to_double(9999999999999999999);
SELECT int64_bits_to_double(-8446744073709551617);

SELECT 'demonstrate negative-zero:' AS _docs;
SELECT int32_bits_to_float(-2147483648);
SELECT float_to_int32_bits(-0.000000000000000000000e+00);
SELECT int64_bits_to_double(-9223372036854775808);
SELECT double_to_int64_bits(-0.000000000000000000000e+00);

SELECT 'demonstrate +/- infinities are NULL' AS _docs;
SELECT int32_bits_to_float(-8388608), '-inf';
SELECT int32_bits_to_float(2139095040), 'inf';
SELECT int64_bits_to_double(-4503599627370496), '-inf';
SELECT int64_bits_to_double(9218868437227405312), 'inf';

SELECT 'demonstrate a variety of NAN values' AS _docs;
SELECT int32_bits_to_float(-8388607), '-nan';
SELECT int32_bits_to_float(-4194306), '-nan';
SELECT int32_bits_to_float(-4194303), '-nan';
SELECT int32_bits_to_float(-2), '-nan';
SELECT int32_bits_to_float(-1), '-nan';
SELECT int32_bits_to_float(2139095041), 'nan';
SELECT int32_bits_to_float(2143289342), 'nan';
SELECT int32_bits_to_float(2143289345), 'nan';
SELECT int32_bits_to_float(2147483646), 'nan';
SELECT int32_bits_to_float(2147483647), 'nan';
SELECT int64_bits_to_double(-4503599627370495), '-nan';
SELECT int64_bits_to_double(-2251799813685250), '-nan';
SELECT int64_bits_to_double(-2251799813685247), '-nan';
SELECT int64_bits_to_double(-2), '-nan';
SELECT int64_bits_to_double(-1), '-nan';
SELECT int64_bits_to_double(9218868437227405313), 'nan';
SELECT int64_bits_to_double(9221120237041090558), 'nan';
SELECT int64_bits_to_double(9221120237041090561), 'nan';
SELECT int64_bits_to_double(9223372036854775806), 'nan';
SELECT int64_bits_to_double(9223372036854775807), 'nan';


SELECT 'demonstrate data type guarding' AS _docs;
CREATE TABLE g1 (g POINT);
INSERT INTO g1 VALUES (PointFromText('POINT(10 10)'));
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT int32_bits_to_float(g) FROM g1;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT int64_bits_to_double(g) FROM g1;

SELECT 'Test some round-tripping with boundary condition\n values of single-precision. Note that the values will\n be displayed as "real" by item_func which has double-\n precision, however, they will continue to round-trip\n as expected.' AS _docs;
CREATE TABLE t3(i32 int, f32 float);
INSERT INTO t3 VALUES
 (-2147483647, -1.401298464324817070924e-45),
 (-2143289346, -5.877468951514508890210e-39),
 (-2143289343, -5.877473155409901864661e-39),
 (-2139095042, -1.175494070562594643005e-38),
 (-2130706433, -2.350988561514728583456e-38),
 (-1090519040, -5.000000000000000000000e-01),
 (-1082130433, -9.999999403953552246094e-01),
 (-1082130432, -1.000000000000000000000e+00),
 (-1056964609, -7.999999523162841796875e+00),
 (-16777216, -1.701411834604692317317e+38),
 (-8388609, -3.402823466385288598117e+38),
 (0, 0.000000000000000000000e+00),
 (1, 1.401298464324817070924e-45),
 (4194302, 5.877468951514508890210e-39),
 (8388606, 1.175494070562594643005e-38),
 (16777215, 2.350988561514728583456e-38),
 (1056964608, 5.000000000000000000000e-01),
 (1065353215, 9.999999403953552246094e-01),
 (1065353216, 1.000000000000000000000e+00),
 (1090519039, 7.999999523162841796875e+00),
 (2130706432, 1.701411834604692317317e+38),
 (2139095039, 3.402823466385288598117e+38);
SELECT	(float_to_int32_bits(f32) = float_to_int32_bits(int32_bits_to_float(i32))) AS round_trip_ok,
	f32 AS expect_f,
	int32_bits_to_float(float_to_int32_bits(f32)) AS round_trip_fif,
	int32_bits_to_float(i32) AS i32_to_float,
	i32 AS expect_i,
	float_to_int32_bits(int32_bits_to_float(i32)) AS round_trip_ifi,
	float_to_int32_bits(f32) AS f32_to_int32
FROM t3 ORDER BY i32;

SELECT 'Next we test round-tripping with boundary condition\n values of double-precision.' AS _docs;
CREATE TABLE t4 (i64 bigint, d64 double);
INSERT INTO t4 VALUES
  (-9223372036854775807, -4.940656458412465441766e-324),
  (-9221120237041090562, -1.112536929253599703414e-308),
  (-9214364837600034817, -4.450147717014402272115e-308),
  (-4620693217682128896, -5.000000000000000000000e-01),
  (-4616189618054758401, -9.999999999999998889777e-01),
  (-4616189618054758400, -1.000000000000000000000e+00),
  (-4602678819172646913, -7.999999999999999111822e+00),
  (-9007199254740992, -8.988465674311579538647e+307),
  (-9007199254740991, -8.988465674311581534487e+307),
  (-6755399441055746, -1.348269851146736531629e+308),
  (-4503599627370497, -1.797693134862315708145e+308),
  (0, 0.000000000000000000000e+00),
  (1, 4.940656458412465441766e-324),
  (2251799813685246, 1.112536929253599703414e-308),
  (9007199254740991, 4.450147717014402272115e-308),
  (4602678819172646912, 5.000000000000000000000e-01),
  (4607182418800017407, 9.999999999999998889777e-01),
  (4607182418800017408, 1.000000000000000000000e+00),
  (4620693217682128895, 7.999999999999999111822e+00),
  (9214364837600034816, 8.988465674311579538647e+307),
  (9214364837600034817, 8.988465674311581534487e+307),
  (9216616637413720062, 1.348269851146736531629e+308),
  (9218868437227405311, 1.797693134862315708145e+308);
SELECT	(double_to_int64_bits(d64) = double_to_int64_bits(int64_bits_to_double(i64))) AS round_trip_ok,
	d64 AS expect_f,
	int64_bits_to_double(double_to_int64_bits(d64)) AS round_trip_fif,
	int64_bits_to_double(i64) AS i64_to_double,
	i64 AS expect_i,
	double_to_int64_bits(int64_bits_to_double(i64)) AS round_trip_ifi,
	double_to_int64_bits(d64) AS d64_to_int64
FROM t4 ORDER BY i64;

SELECT 'The int32_bits_to_float is an Item_real_func, which is always type double.\nIf we get a 32-bit Item_float_func, we shouls switch to that.' AS _note;
CREATE TABLE t5 (
	f0 DOUBLE NOT NULL,
	f1 DOUBLE,
	i0 BIGINT NOT NULL,
	i1 BIGINT);
CREATE TABLE t6 AS SELECT
	double_to_int64_bits(f0),
	double_to_int64_bits(f1),
	int64_bits_to_double(i0),
	int64_bits_to_double(i1),
	float_to_int32_bits(f0),
	float_to_int32_bits(f1),
	int32_bits_to_float(i0),
	int32_bits_to_float(i1)

FROM t5;
SHOW CREATE TABLE t6;

SELECT 'Again, the int32_bits_to_float is an Item_real_func, which is always type double.' AS _note;
CREATE TABLE t7 (
	f0 FLOAT NOT NULL,
	f1 FLOAT,
	i0 INT NOT NULL,
	i1 INT);
CREATE TABLE t8 AS SELECT
	float_to_int32_bits(f0),
	float_to_int32_bits(f1),
	int32_bits_to_float(i0),
	int32_bits_to_float(i1),
	double_to_int64_bits(f0),
	double_to_int64_bits(f1),
	int64_bits_to_double(i0),
	int64_bits_to_double(i1)
FROM t7;
SHOW CREATE TABLE t8;

# clean up
DROP TABLE t1;
DROP TABLE t2;
DROP TABLE g1;
DROP TABLE t3;
DROP TABLE t4;
DROP TABLE t5;
DROP TABLE t6;
DROP TABLE t7;
DROP TABLE t8;
