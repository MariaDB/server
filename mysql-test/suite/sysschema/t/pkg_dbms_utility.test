-- source include/have_perfschema.inc

--echo #
--echo # MDEV-34330: System package SYS.DBMS_UTILITY
--echo #

SET sql_mode= oracle;

SET SESSION note_verbosity = "";

DELIMITER //;

--echo #
--echo # Test GET_TIME
--echo #
BEGIN SET timestamp=1216359724; SELECT sys.DBMS_UTILITY.GET_TIME(); END;//

DELIMITER ;//

--echo #
--echo # Test GET_TIME with an argument
--echo #
--error ER_SP_WRONG_NO_OF_ARGS
SELECT sys.DBMS_UTILITY.GET_TIME(1);

DELIMITER //;

CREATE OR REPLACE PROCEDURE proc1
IS
BEGIN
   RAISE TOO_MANY_ROWS;
END;
//

CREATE OR REPLACE PROCEDURE proc1_1
IS
BEGIN
    proc1;
EXCEPTION
    WHEN OTHERS
    THEN
      RAISE DUP_VAL_ON_INDEX;
END;//

CREATE OR REPLACE PACKAGE pkg1
IS
   PROCEDURE proc2;
END pkg1;//

CREATE OR REPLACE PACKAGE BODY pkg1
IS
   PROCEDURE proc2
   IS
   BEGIN
      proc1_1;
   EXCEPTION
      WHEN OTHERS
      THEN
        RAISE DUP_VAL_ON_INDEX;
   END;
END pkg1;//

CREATE PROCEDURE proc3( )
AS
BEGIN
   pkg1.proc2;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      SELECT sys.DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
      SELECT sys.DBMS_UTILITY.FORMAT_ERROR_STACK();
END;//

DELIMITER ;//

--echo #
--echo # Test FORMAT_BACKTRACE & FORMAT_ERROR_STACK in an exception handler
--echo #
CALL proc3( );

DELIMITER //;

CREATE OR REPLACE PROCEDURE proc1_2_2
IS
BEGIN
   SELECT 'hello';
END;
//

CREATE OR REPLACE PROCEDURE proc1_2
IS
BEGIN
    proc1_2_2;
    proc1;
EXCEPTION
    WHEN OTHERS
    THEN
      RAISE DUP_VAL_ON_INDEX;
END;//

CREATE PROCEDURE proc6( )
AS
BEGIN
   proc1_2;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      SELECT sys.DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
      SELECT sys.DBMS_UTILITY.FORMAT_ERROR_STACK();
END;//

DELIMITER ;//

--echo #
--echo # Test FORMAT_BACKTRACE & FORMAT_ERROR_STACK with called "non-error producing" routines, thereby exclusion from trace
--echo #
CALL proc6( );

DELIMITER //;

--echo #
--echo # Test FORMAT_BACKTRACE in nested block
--echo #
CREATE PROCEDURE proc3_3( )
AS
BEGIN
    BEGIN
        BEGIN
            pkg1.proc2;
        EXCEPTION
            WHEN DUP_VAL_ON_INDEX THEN
                SELECT sys.DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
        END;
    END;
END;//

DELIMITER ;//

CALL proc3_3( );

DELIMITER //;

CREATE PROCEDURE proc4( )
AS
BEGIN
   pkg1.proc2;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        SET @x2 = 2;
END;//

DELIMITER ;//

--echo #
--echo # Test FORMAT_BACKTRACE outside SPs
--echo #
CALL proc4( );
SELECT sys.DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();

delimiter //;

CREATE OR REPLACE PROCEDURE show_errors
IS
BEGIN
   SELECT sys.DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
END;
//

CREATE OR REPLACE PROCEDURE proc2
IS
BEGIN
    proc1_1;
EXCEPTION
    WHEN OTHERS
    THEN
      RAISE DUP_VAL_ON_INDEX;
END;//

CREATE OR REPLACE PACKAGE TEST_PKG AS
    PROCEDURE p2public;
END;
//

CREATE OR REPLACE PACKAGE BODY TEST_PKG AS
    PROCEDURE p2public AS
    BEGIN
        SELECT 'in p2public';
    END;
BEGIN
    proc2;
EXCEPTION
    WHEN OTHERS
    THEN
        CALL show_errors();
END;
//

delimiter ;//

--echo #
--echo # Test FORMAT_BACKTRACE & FORMAT_ERROR_STACK from a package initialization section
--echo #
CALL TEST_PKG.p2public;

##########################################################
#    Recursive Test                                      #
##########################################################
SET @session_max_recursion_depth = @@SESSION.max_sp_recursion_depth;


# Setting session value of variable
SET @@session.max_sp_recursion_depth = 10;
SELECT @@session.max_sp_recursion_depth;
# create procedure to add rows

--disable_warnings
DROP PROCEDURE IF EXISTS sp_add_records;
--enable_warnings

DELIMITER //;

CREATE PROCEDURE sp_add_records (var1 INT,var2 INT) AS
BEGIN
SELECT var1,var2;
IF var1 < var2 THEN
   CALL sp_add_records(var1+1,var2);
   SELECT var1,var2;
ELSE
    proc1;
END IF;
EXCEPTION
    WHEN OTHERS
    THEN
      RAISE DUP_VAL_ON_INDEX;
END;//

CREATE PROCEDURE proc5( )
AS
BEGIN
    CALL sp_add_records(0,8);
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      SELECT sys.DBMS_UTILITY.FORMAT_ERROR_STACK();
END;//


DELIMITER ;//


CALL proc5( );

SET @identifier := REPEAT('x', 500);
--echo #
--echo # Test FORMAT_ERROR_STACK with very long result string
--echo #
--error ER_DUP_ENTRY

DELIMITER //;

CREATE OR REPLACE PROCEDURE cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc IS BEGIN proc1; EXCEPTION WHEN OTHERS THEN SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO=3047, MESSAGE_TEXT=@identifier; END;//

CREATE OR REPLACE PROCEDURE bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb IS BEGIN cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc; EXCEPTION WHEN OTHERS THEN SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO=3047, MESSAGE_TEXT=@identifier; END;//

CREATE OR REPLACE PROCEDURE aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa IS BEGIN bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb; EXCEPTION WHEN OTHERS THEN SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO=3047, MESSAGE_TEXT=@identifier; END;//

CREATE OR REPLACE PROCEDURE proc1_1
IS
BEGIN
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;
EXCEPTION
    WHEN OTHERS
    THEN
      SIGNAL SQLSTATE 'HY000' SET MYSQL_ERRNO=3047, MESSAGE_TEXT=@identifier;
END;//

CREATE PROCEDURE proc3_2( )
AS
BEGIN
   pkg1.proc2;
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        SELECT sys.DBMS_UTILITY.FORMAT_ERROR_STACK();
END;//

DELIMITER ;//
CALL proc3_2( );

--echo #
--echo # Test FORMAT_BACKTRACE & FORMAT_ERROR_STACK when no error occurs
--echo #
DELIMITER $$;
CREATE PROCEDURE p1() AS
BEGIN
  CALL sys.DBMS_TRANSACTION.COMMIT;
EXCEPTION
    WHEN OTHERS
    THEN
        SELECT sys.DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
END;
$$
DELIMITER ;$$

CALL p1();

DROP PROCEDURE proc1_2_2;
DROP PROCEDURE proc1_2;
DROP PROCEDURE proc6;
DROP PROCEDURE p1;
DROP PROCEDURE cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc;
DROP PROCEDURE bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;
DROP PROCEDURE aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;
DROP PROCEDURE proc3_2;
DROP PROCEDURE show_errors;
DROP PROCEDURE proc2;
DROP PACKAGE TEST_PKG;
DROP PROCEDURE proc1;
DROP PROCEDURE proc1_1;
DROP PACKAGE pkg1;
DROP PROCEDURE proc3_3;
DROP PROCEDURE proc3;
DROP PROCEDURE proc4;
DROP PROCEDURE IF EXISTS sp_add_records;
DROP PROCEDURE IF EXISTS proc5;

SET @@SESSION.max_sp_recursion_depth = @session_max_recursion_depth;