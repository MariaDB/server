#
# Purpose:
#
# This test verifies the correct behavior of replication database filters
# for ALTER TABLE commands, specifically: binlog_dump_do/ignore_db.
#
# The test compares the master's binary log (binlog) and the slave's relay log
# to confirm how these filters affect ALTER TABLE replication.
#
# Key points:
#
# binlog_dump_do/ignore_db filters what the master sends to the slave via the binlog dump thread.
#    - ALTER TABLE commands are written to the master's binlog, but only filtered events
#      are sent to the slave.
#    - As a result the Master's binlog will have all the ALTER events written but the Slave's relaylog file 
#      will contain only the filtered events
#
# This test ensures that ALTER TABLE commands with filters behave as expected, by examining
# which events appear in the master's binlog and the slave's relay log.

--source include/master-slave.inc

eval SET @@default_storage_engine=$engine_type;

connection master;

--echo # On master: create table in replicated database
CREATE TABLE t1 (id INT PRIMARY KEY, data VARCHAR(50));
INSERT INTO t1 VALUES (1, 'first row in t1');

--echo # Create and use a filtered DB
CREATE DATABASE ignored_db;
USE ignored_db;
CREATE TABLE t2 (id INT PRIMARY KEY, data VARCHAR(50));
INSERT INTO t2 VALUES (1, 'row in t2');

--echo # Perform ALTER TABLE on replicated database
USE test;
ALTER TABLE t1 ADD COLUMN new_col INT DEFAULT 100;
INSERT INTO t1 VALUES (2, 'second row in t1', 200);

--echo # Perform ALTER TABLE on filtered database (should not replicate)
USE ignored_db;
ALTER TABLE t2 ADD COLUMN filtered_col VARCHAR(100) DEFAULT 'filtered';
INSERT INTO t2 VALUES (2, 'second row in t2', 'filtered value');

--echo # Perform multiple ALTER operations on filtered database
ALTER TABLE t2 ADD COLUMN another_col INT DEFAULT 42;
ALTER TABLE t2 MODIFY COLUMN data VARCHAR(100);
ALTER TABLE t2 DROP COLUMN filtered_col;

--echo # Back to replicated database for another ALTER
USE test;
ALTER TABLE t1 ADD INDEX idx_data (data);
ALTER TABLE t1 MODIFY COLUMN data VARCHAR(100);

--echo # Capture current binlog file name
--let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)

--echo # Sync slave to ensure all replicated events are processed
--sync_slave_with_master

--echo # Find relay log file on slave
connection slave;

--echo # Get slave's current relay log file
--let $relaylog_file= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1)

--echo # Dump master binlog to file
--exec $MYSQL_BINLOG $MYSQLTEST_VARDIR/mysqld.1/data/$binlog_file > $MYSQLTEST_VARDIR/tmp/master_binlog_alter.txt

--echo # Dump slave relay log to file
--exec $MYSQL_BINLOG $MYSQLTEST_VARDIR/mysqld.2/data/$relaylog_file > $MYSQLTEST_VARDIR/tmp/slave_relaylog_alter.txt

--echo # Validate that ALTER TABLE t1 ADD COLUMN is in the master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog_alter.txt
--let $assert_text= ALTER TABLE t1 ADD COLUMN must be present in master binlog
--let $assert_select= ALTER TABLE.*t1.*ADD COLUMN.*new_col
--let $assert_count= 1
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t1 ADD COLUMN is in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog_alter.txt
--let $assert_text= ALTER TABLE t1 ADD COLUMN must be present in slave relaylog
--let $assert_select= ALTER TABLE.*t1.*ADD COLUMN.*new_col
--let $assert_count= 1
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t2 (filtered) ADD COLUMN is in the master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog_alter.txt
--let $assert_text= ALTER TABLE t2 ADD COLUMN must be present in master binlog
--let $assert_select= ALTER TABLE.*t2.*ADD COLUMN.*filtered_col
--let $assert_count= 1
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t2 (filtered) ADD COLUMN is NOT in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog_alter.txt
--let $assert_text= ALTER TABLE t2 ADD COLUMN must not be present in slave relaylog
--let $assert_select= ALTER TABLE.*t2.*ADD COLUMN.*filtered_col
--let $assert_count= 0
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t2 MODIFY is in master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog_alter.txt
--let $assert_text= ALTER TABLE t2 MODIFY must be present in master binlog
--let $assert_select= ALTER TABLE.*t2.*MODIFY
--let $assert_count= 1
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t2 MODIFY is NOT in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog_alter.txt
--let $assert_text= ALTER TABLE t2 MODIFY must not be present in slave relaylog
--let $assert_select= ALTER TABLE.*t2.*MODIFY
--let $assert_count= 0
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t2 DROP COLUMN is NOT in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog_alter.txt
--let $assert_text= ALTER TABLE t2 DROP COLUMN must not be present in slave relaylog
--let $assert_select= ALTER TABLE.*t2.*DROP COLUMN
--let $assert_count= 0
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t1 ADD INDEX is in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog_alter.txt
--let $assert_text= ALTER TABLE t1 ADD INDEX must be present in slave relaylog
--let $assert_select= ALTER TABLE.*t1.*ADD INDEX
--let $assert_count= 1
--source include/assert_grep.inc

--echo # Validate that ALTER TABLE t1 MODIFY is in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog_alter.txt
--let $assert_text= ALTER TABLE t1 MODIFY must be present in slave relaylog
--let $assert_select= ALTER TABLE.*t1.*MODIFY
--let $assert_count= 1
--source include/assert_grep.inc

--echo # Verify slave has correct table structure for t1
connection slave;
USE test;
SHOW CREATE TABLE t1;
SELECT * FROM t1 ORDER BY id;

--echo # Verify slave does not have filtered database changes
--error ER_NO_SUCH_TABLE
SHOW CREATE TABLE ignored_db.t2;

--echo # Cleanup
connection master;
USE ignored_db;
DROP TABLE t2;
USE test;
DROP TABLE t1;
DROP DATABASE ignored_db;
