#
# Purpose:
#   Verify that partial filtering behaves correctly when a single query
#   targets multiple databases at once.
#
#   The test issues multi-table UPDATE statements (e.g. UPDATE test.t1, sample_db.t2 …),
#   where each database has different filter settings applied. This ensures:
#     - Events for filtered databases are excluded from the relay log.
#     - Events for allowed databases remain visible on the slave.
#
#   Mapping:
#     test.t1 → allowed
#     sample_db.t2 → filtered
#     test.t3 → filtered
#     sample_db.t4 → allowed
#
#   This validates that binlog_dump_do/ignore_db filters operate at the
#   per-db level, even within a single query affecting multiple tables.
#
#
#   NOTE: Partial Filtering feature is only intended for row format for now 
#         In the future when there is support for statement format
#         there is no need to add a new test one could just 
#         remove the have_binlog_format_row
#

--source include/have_binlog_format_row.inc
--source include/master-slave.inc

connection master;

eval SET @@default_storage_engine=$engine_type;

--echo # On master: create two tables and insert data
CREATE TABLE t1 (id INT PRIMARY KEY, data VARCHAR(50));
CREATE TABLE t3 (id INT PRIMARY KEY, data VARCHAR(50));
INSERT INTO t1 VALUES (1, 'row in t1');
INSERT INTO t3 VALUES (1, 'row in t3');

CREATE DATABASE sample_db;

CREATE TABLE sample_db.t2 (id INT PRIMARY KEY, data VARCHAR(50));
CREATE TABLE sample_db.t4 (id INT PRIMARY KEY, data VARCHAR(50));
INSERT INTO sample_db.t2 VALUES (1, 'row in t2');
INSERT INTO sample_db.t4 VALUES (1, 'row in t4');

--echo # This query should affect multiple tables at the same time
UPDATE test.t1, sample_db.t2
SET t1.data = 'updated t1', t2.data = 'updated t2';
UPDATE test.t3, sample_db.t4
SET t3.data = 'updated t3', t4.data = 'updated t4';

--echo # Capture current binlog file name
--let $binlog_file= SELECT @@global.log_bin_basename
--let $binlog_index= query_get_value(SHOW MASTER STATUS, File, 1)

--echo # Find relay log file on slave
connection slave;
--let $relaylog_file= query_get_value(SHOW SLAVE STATUS, Relay_Log_File, 1)

--echo # Dump master binlog to file
--exec $MYSQL_BINLOG $MYSQLTEST_VARDIR/mysqld.1/data/$binlog_index > $MYSQLTEST_VARDIR/tmp/master_binlog.txt

--echo # Dump slave relay log to file
--exec $MYSQL_BINLOG $MYSQLTEST_VARDIR/mysqld.2/data/$relaylog_file > $MYSQLTEST_VARDIR/tmp/slave_relaylog.txt

--echo # Validate that 'Table_map t1' is in the master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog.txt
--let $assert_text= Table_map t1 must be present in master binlog
--let $assert_select= Table_map: `test`.`t1`
--let $assert_count= 2
--source include/assert_grep.inc

--echo # Validate that 'Table_map t2' is in the master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog.txt
--let $assert_text= Table_map t2 must be present in master binlog
--let $assert_select= Table_map: `sample_db`.`t2`
--let $assert_count= 2
--source include/assert_grep.inc

--echo # Validate that 'Table_map t3' is in the master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog.txt
--let $assert_text= Table_map t3 must be present in master binlog
--let $assert_select= Table_map: `test`.`t3`
--let $assert_count= 2
--source include/assert_grep.inc

--echo # Validate that 'Table_map t4' is in the master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog.txt
--let $assert_text= Table_map t4 must be present in master binlog
--let $assert_select= Table_map: `sample_db`.`t4`
--let $assert_count= 2
--source include/assert_grep.inc

--echo # Validate that all 'Update_rows' is in the master binlog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/master_binlog.txt
--let $assert_text= Update_rows t1, t2 , t3 and t4 must be present in master binlog
--let $assert_select= Update_rows
--let $assert_count= 4
--source include/assert_grep.inc




--echo # Validate that 'Table_map t1' is in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog.txt
--let $assert_text= Table_map t1 must be present in master binlog
--let $assert_select= Table_map: `test`.`t1`
--let $assert_count= 2
--source include/assert_grep.inc

--echo # Validate that 'Table_map t2' is in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog.txt
--let $assert_text= Table_map t2 must be present in master binlog
--let $assert_select= Table_map: `sample_db`.`t2`
--let $assert_count= 0
--source include/assert_grep.inc

--echo # Validate that 'Table_map t3' is in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog.txt
--let $assert_text= Table_map t3 must be present in master binlog
--let $assert_select= Table_map: `test`.`t3`
--let $assert_count= 0
--source include/assert_grep.inc

--echo # Validate that 'Table_map t4' is in the slave relaylog
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog.txt
--let $assert_text= Table_map t4 must be present in master binlog
--let $assert_select= Table_map: `sample_db`.`t4`
--let $assert_count= 2
--source include/assert_grep.inc

--echo # Validate that all 'Update_rows' is in the slave relaylog "partial filter applied over ROW_EVENT"
--let $assert_file= $MYSQLTEST_VARDIR/tmp/slave_relaylog.txt
--let $assert_text= Update_rows t1, t2 and t4 must be present in master binlog
--let $assert_select= Update_rows
--let $assert_count= 3
--source include/assert_grep.inc

--echo # Cleanup

connection master;
DROP TABLE test.t1;
DROP TABLE test.t3;
DROP TABLE sample_db.t2;
DROP TABLE sample_db.t4;
DROP DATABASE sample_db;
