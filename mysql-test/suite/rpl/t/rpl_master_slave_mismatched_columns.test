#
# Test ensures that if slave tables have their columns organized differently
# than their master, that the slave can still correctly replicate the events.
# That is, the slave will use column names, if available (supplied when
# binlog_row_metadata=FULL), to identify the correct columns to store the row
# data.
#
#
# The following use cases are tested:
#
# -----------------------------------------------------------------------------
# TODO: This is just a plan, I'm still working on writing the tests to cover
#       these test cases.
# -----------------------------------------------------------------------------
#
#   1. ALTER TABLE adds a new column in the first position on the slave,
#      default value is used for the new column during replication, and all
#      other fields replicate correctly.
#   2. ALTER TABLE adds a new column in the middle of the table on the slave,
#      default value is used for the new column during replication, and all
#      other fields replicate correctly.
#   3. ALTER TABLE adds a new column in the last position on the slave,
#      default value is used for the new column during replication, and all
#      other fields replicate correctly.
#   4. ALTER TABLE drops the first column on the slave, that column is not
#      replicated, but all other fields replicate correctly.
#   5. ALTER TABLE drops a middle column on the slave, that column is not
#      replicated, but all other fields replicate correctly.
#   6. ALTER TABLE drops the last column on the slave, that column is not
#      replicated, but all other fields replicate correctly.
#   7. Re-test use-cases 1-6 with type conversion.
#   8. Re-test use-cases 1-6 with NULL columns. *TODO
#   9. Re-test use-cases 1-6 with type conversion and NULL columns. *TODO
#   10. ALTER TABLE adds a column with the same name as an existing column,
#      but with a prefix, and before the existing column. Replication should
#      not update the new column. *TODO
#   11. Multi-table transaction with each target table on the slave having
#       different column structure than the master. *TODO
#
# TODO:
#   * BINLOG_ROW_IMAGE=MINIMAL and BINLOG_ROW_METADATA=FULL
#   * ERROR Cases
#     E1. Master and slave have matching table names but no matching column
#         names
#
# References:
#   MDEV-36290: ALTER TABLE with multi-master can cause data loss
#

--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_binlog_format_row.inc
--let $rpl_topology=1->2, 2->3
--source include/rpl_init.inc

--connection server_2
set @saved_slave_type_conversions = @@global.slave_type_conversions;
set global slave_type_conversions='ALL_NON_LOSSY';
--connection server_3
set @saved_slave_type_conversions = @@global.slave_type_conversions;
set global slave_type_conversions='ALL_NON_LOSSY';

--echo #
--echo # Test Cases 1-3: Add columns

# No type-conversion, so have source and target match
--let $source_type= BLOB
--let $target_type= BLOB
--let $source_value= 'aaa'
--let $target_value= 'aaa'
--let $can_convert= 1
--let $add_col= 1
--let $add_col_loc= first
--source rpl_master_slave_mismatched_columns.inc

--let $add_col_loc= middle
--source rpl_master_slave_mismatched_columns.inc

--let $add_col_loc= end
--source rpl_master_slave_mismatched_columns.inc

--let $source_type=
--let $target_type=
--let $source_value=
--let $target_value=
--let $can_convert=
--let $add_col=
--let $add_col_loc=

--echo #
--echo # Test Case 4-6: Drop columns
# No type-conversion, so have source and target match
--let $source_type= BLOB
--let $target_type= BLOB
--let $source_value= 'aaa'
--let $target_value= 'aaa'
--let $can_convert= 1

--let $drop_col= a
--source rpl_master_slave_mismatched_columns.inc
--let $drop_col= b
--source rpl_master_slave_mismatched_columns.inc
--let $drop_col= c
--source rpl_master_slave_mismatched_columns.inc
--let $drop_col= pk
--source rpl_master_slave_mismatched_columns.inc

--let $source_type=
--let $target_type=
--let $source_value=
--let $target_value=
--let $can_convert=
--let $drop_col=

--echo #
--echo # Test Case 7: (Re-test 1-6 with type conversion)
--let $source_type= TINYBLOB
--let $target_type= BLOB
--let $source_value= 'aaa'
--let $target_value= 'aaa'

--echo # ALTER ADD COLUMN tests
--let $can_convert= 1
--let $add_col= 1
--let $add_col_loc= first
--source rpl_master_slave_mismatched_columns.inc
--let $add_col_loc= middle
--source rpl_master_slave_mismatched_columns.inc
--let $add_col_loc= end
--source rpl_master_slave_mismatched_columns.inc

--let $add_col=
--let $add_col_loc=

--echo # ALTER DROP COLUMN tests
--let $drop_col= a
--source rpl_master_slave_mismatched_columns.inc
--let $drop_col= b
--source rpl_master_slave_mismatched_columns.inc
--let $drop_col= c
--source rpl_master_slave_mismatched_columns.inc
--let $drop_col= pk
--source rpl_master_slave_mismatched_columns.inc

--let $source_type=
--let $target_type=
--let $source_value=
--let $target_value=
--let $can_convert=
--let $drop_col=

--echo #
--echo # Cleanup
--connection server_1
--source include/save_master_gtid.inc

--connection server_3
--source include/sync_with_master_gtid.inc

--connection server_2
set global slave_type_conversions= @saved_slave_type_conversions;
--connection server_3
set global slave_type_conversions= @saved_slave_type_conversions;

--source include/rpl_end.inc
--echo # End of .test
