#
#   This file tests that row events which are larger than a server's configured
# binlog_row_event_fragment_threshold will be fragmented into
# Partial_rows_log_event, that the slave re-assembles to execute the event.
#
#   The following use cases are tested when replaying transactions via
# traditional replication.
#
#   Test cases done:
#   1: Boundary testing of event size vs binlog_row_event_fragment_threshold
#     a) If full rows_log_event
#        (ev metadta incl) <= binlog_row_event_fragment_threshold, no
#        fragmentation
#     b) If rows_data size is less than binlog_row_event_fragment_threshold,
#        but adding the metadata of the Rows_event would result in surpassing
#        binlog_row_event_fragment_threshold (by one byte), fragmentation
#        should occur
#   2: Any Rows event type that surpasses binlog_row_event_fragment_threshold
#      should be fragmented:
#     a) Write_rows
#     b) Update_rows
#     c) Delete_rows
#     d) Write_rows_compressed
#     e) Update_rows_compressed
#     f) Delete_rows_compressed
#   3: SHOW BINLOG EVENTS should show Partial_rows_log_event fragment
#      sequencing
#   4: The parallel replication applier can re-assemble Rows_log_events and
#      apply them
#   5: A transaction with multiple Rows_log_events can be replicated
#   6: Using chain-replication, servers configured with different
#      binlog_row_event_fragment_threshold should binlog according to the
#      configured policy of that specific server
#   7: Replication filters will filter the re-constructed Rows_log_event,
#      when filtering either the target database or table.
#
#
#   Note this test users MTR variables to save old variables rather than user
# variables because binlog_row_event_fragment_threshold is reset dynamically,
# and connections are disconnected and reconnected to reset the value, as
# FLUSH STATUS doesn't reset this value.
#
#
# References:
#   MDEV-28768: mysqlbinlog can produce events larger than max_allowed_packet
#   MDEV-32570: Fragment ROW replication events larger than frag_threshold_size
#
--source include/have_sequence.inc
--source include/have_innodb.inc
--source include/have_binlog_format_row.inc
--let $rpl_topology=1->2, 2->3
--source include/rpl_init.inc


--echo #
--echo #
--echo # Test setup

# Option is disabled for all tests in this file
--let $test_mysqlbinlog_replay=

--connection server_1
--let $server_1_old_binlog_frag_threshold= `SELECT @@global.binlog_row_event_fragment_threshold`
--let $server_1_old_net_buf= `SELECT @@global.net_buffer_length`
set @@global.binlog_row_event_fragment_threshold= 1024;
set @@global.net_buffer_length= 1024;
--disconnect server_1
--source include/wait_until_disconnected.inc
--connect (server_1,127.0.0.1,root,,test,$SERVER_MYPORT_1,)

--connection server_2
--source include/stop_slave.inc
--let $server_2_old_binlog_frag_threshold= `SELECT @@global.binlog_row_event_fragment_threshold`
--let $server_2_old_net_buf= `SELECT @@global.net_buffer_length`
set @@global.binlog_row_event_fragment_threshold= 1024;
set @@global.net_buffer_length= 1024;
--disconnect server_2
--source include/wait_until_disconnected.inc
--connect (server_2,127.0.0.1,root,,test,$SERVER_MYPORT_2,)
--source include/start_slave.inc

--connection server_3
--source include/stop_slave.inc
--let $server_3_old_binlog_frag_threshold= `SELECT @@global.binlog_row_event_fragment_threshold`
--let $server_3_old_net_buf= `SELECT @@global.net_buffer_length`
set @@global.binlog_row_event_fragment_threshold= 1024;
set @@global.net_buffer_length= 1024;
--disconnect server_3
--source include/wait_until_disconnected.inc
--connect (server_3,127.0.0.1,root,,test,$SERVER_MYPORT_3,)
--source include/start_slave.inc


--echo #
--echo #
--echo # Test case 1) Boundary Testing
--let $log_ev_header_len= 19
--let $rows_header_len= 8
--let $binlog_checksum_len= 4
--let $ev_metadata_size=  `SELECT ($log_ev_header_len + $rows_header_len + $binlog_checksum_len)`
--let $max_unfragged_ev= `SELECT (1024 - $ev_metadata_size)`

--echo #
--echo # A rows event at its maximum unfragmented length (i.e. the length of
--echo # binlog_row_event_fragment_threshold minus the Rows_log event metadata (e.g.
--echo # headers)) should not fragment, and replication replay should work both
--echo # via traditional replication as well as mysqlbinlog.
--let $test_update=0
--let $test_delete=0
--let $insert_size=$max_unfragged_ev
--source rpl_fragment_row_event.inc

--echo #
--echo # If rows event surpasses its maximum unfragmented length by 1, it
--echo # should fragment into 2 pieces, and replication replay should work
--echo # both via traditional replication as well as mysqlbinlog.

--let $insert_size= `SELECT ($max_unfragged_ev + 1)`
--source rpl_fragment_row_event.inc

# Clear insert_size for future transactions to use default insertion logic
--let $insert_size=
--let $test_update=1
--let $test_delete=1


--echo #
--echo #
--echo # Test cases 2a-2c) Regular row events that surpass
--echo # binlog_row_event_fragment_threshold should be fragmented
--source rpl_fragment_row_event.inc


--echo #
--echo #
--echo # Test cases 2d-2f) Compressed row events that surpass
--echo # binlog_row_event_fragment_threshold should be fragmented
--connection server_1
--let $old_s1_compress= `SELECT @@global.log_bin_compress`
set @@global.log_bin_compress= 1;
--connection server_2
--let $old_s2_compress= `SELECT @@global.log_bin_compress`
set @@global.log_bin_compress= 1;
--connection server_3
--let $old_s3_compress= `SELECT @@global.log_bin_compress`
set @@global.log_bin_compress= 1;

--source rpl_fragment_row_event.inc

--connection server_1
--eval set @@global.log_bin_compress= $old_s1_compress
--connection server_2
--eval set @@global.log_bin_compress= $old_s2_compress
--connection server_3
--eval set @@global.log_bin_compress= $old_s3_compress


--echo #
--echo #
--echo # Test case 3) SHOW BINLOG EVENTS should show Partial_rows_log_event
--echo # fragment sequencing

--let $test_show_binlog_events= 1
--source rpl_fragment_row_event.inc
--let $test_show_binlog_events=


--echo #
--echo #
--echo # Test case 4) The parallel replication applier can re-assemble
--echo # Rows_log_events and apply them
--connection server_2
--source include/stop_slave.inc
--let $old_s2_threads= `SELECT @@global.slave_parallel_threads`
set @@global.slave_parallel_threads= 4;
--source include/start_slave.inc
--connection server_3
--source include/stop_slave.inc
--let $old_s3_threads= `SELECT @@global.slave_parallel_threads`
set @@global.slave_parallel_threads= 4;
--source include/start_slave.inc

--source rpl_fragment_row_event.inc

--connection server_2
--source include/stop_slave.inc
--eval set @@global.slave_parallel_threads= $old_s2_threads;
--source include/start_slave.inc
--connection server_3
--source include/stop_slave.inc
--eval set @@global.slave_parallel_threads= $old_s3_threads;
--source include/start_slave.inc


--echo #
--echo #
--echo # Test Case 5) A transaction with multiple Rows_log_events can be
--echo # replicated

--let $test_multi_table_trx= 1
--let $test_show_binlog_events= 1
--let $test_update= 0
--let $test_delete= 0
--source rpl_fragment_row_event.inc
--let $test_multi_table_trx=
--let $test_show_binlog_events=
--let $test_update= 1
--let $test_delete= 1


--echo #
--echo #
--echo # Test case 6) Chain replication with different binlog_row_event_fragment_threshold
--echo # configurations

--let $server_2_frag_threshold=16384
--let $server_3_frag_threshold=16384
--source rpl_fragment_row_event.inc
--let $server_2_frag_threshold=
--let $server_3_frag_threshold=

--echo #
--echo #
--echo # Test Case 7) Replication filters should be honored when executing a re-assembled Rows_log_event

--connection server_2
--source include/start_slave.inc
--connection server_3
--source include/start_slave.inc

--connection server_1
create table t1 (a int, b longblob) engine=innodb;
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc

--connection server_2
--source include/stop_slave.inc
set @@global.replicate_ignore_db="test";
--source include/start_slave.inc

--connection server_1
--disable_query_log
--eval insert into t1 values (1, repeat("a", 1024))
--enable_query_log
  --let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)
--source include/show_binlog_events.inc
--source include/save_master_gtid.inc

--connection server_2
--source include/sync_with_master_gtid.inc
--echo # Ensuring insert was ignored by replicate_ignore_db rule..
if (`SELECT count(*) FROM test.t1`)
{
  --echo # Insert should have been ignored by replicate_ignore_db
  --die Insert should have been ignored by replicate_ignore_db
}
--echo # ..done

--connection server_2
--source include/stop_slave.inc
set @@global.replicate_ignore_db="";
set @@global.replicate_ignore_table="test.t1";
--source include/start_slave.inc

--connection server_1
--disable_query_log
--eval insert into t1 values (1, repeat("b", 1024))
  --let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)
--source include/show_binlog_events.inc
--enable_query_log
--source include/save_master_gtid.inc

--connection server_2
--source include/sync_with_master_gtid.inc
--echo # Ensuring insert was ignored by replicate_ignore_table rule..
if (`SELECT count(*) FROM test.t1`)
{
  --echo # Insert should have been ignored by replicate_ignore_table
  --die Insert should have been ignored by replicate_ignore_table
}
--echo # ..done

--connection server_2
--source include/stop_slave.inc
set @@global.replicate_ignore_table="";
--source include/start_slave.inc

--connection server_1
drop table t1;
FLUSH LOGS;
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc
--source include/save_master_gtid.inc
--connection server_3
--source include/sync_with_master_gtid.inc


--echo #
--echo #
--echo # Cleanup
--connection server_1
--eval set @@global.binlog_row_event_fragment_threshold= $server_1_old_binlog_frag_threshold
--eval set @@global.net_buffer_length= $server_1_old_net_buf
--disconnect server_1
--source include/wait_until_disconnected.inc
--connect (server_1,127.0.0.1,root,,test,$SERVER_MYPORT_1,)

--connection server_2
--source include/stop_slave.inc
--eval set @@global.binlog_row_event_fragment_threshold= $server_2_old_binlog_frag_threshold
--eval set @@global.net_buffer_length= $server_2_old_net_buf
--source include/start_slave.inc
--disconnect server_2
--source include/wait_until_disconnected.inc
--connect (server_2,127.0.0.1,root,,test,$SERVER_MYPORT_2,)

--connection server_3
--source include/stop_slave.inc
--eval set @@global.binlog_row_event_fragment_threshold= $server_3_old_binlog_frag_threshold
--eval set @@global.net_buffer_length= $server_3_old_net_buf
--source include/start_slave.inc
--disconnect server_3
--source include/wait_until_disconnected.inc
--connect (server_3,127.0.0.1,root,,test,$SERVER_MYPORT_3,)

--source include/rpl_end.inc
--echo # End of rpl_fragment_row_event.test
