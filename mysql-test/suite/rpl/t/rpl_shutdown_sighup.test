#
#   The signal handler thread can use various different runtime resources when
# processing a SIGHUP (e.g. master-info information), as the logic calls into
# reload_acl_and_cache(). This test ensures that SIGHUP processing, when
# concurrent with server shutdown, the shutdown logic must wait for the SIGHUP
# processing to finish before cleaning up any resources.
#
#   Additionally, the error case is tested such that the signal handler thread
# takes too long processing a SIGHUP, and the main mysqld thread must skip its
# wait and output a warning.
#
# Note the SIGHUP is sent via the command-line kill program via a perl script.
#
# References:
#  MDEV-30260: Slave crashed:reload_acl_and_cache during shutdown
#

--source include/not_windows.inc
--source include/have_debug.inc

# Binlog format doesn't matter
--source include/have_binlog_format_statement.inc
--source include/master-slave.inc

# For error test case which forces timeout
--connection slave
set statement sql_log_bin=0 for call mtr.add_suppression("Signal handler thread did not exit in a timely manner");
--source include/stop_slave.inc
set @old_dbug= @@global.debug_dbug;
set @@global.debug_dbug= "+d,try_force_segfault";
--source include/start_slave.inc


--echo #
--echo # Main test

--connection master
create table t1 (a int);
insert into t1 values (1);
--source include/save_master_gtid.inc
insert into t1 values (1);
insert into t1 values (1);
insert into t1 values (1);

--connection slave
--source include/sync_with_master_gtid.inc

--write_file $MYSQLTEST_VARDIR/tmp/mysqld.2.expect
wait
EOF

--echo # Waiting for mysig
set debug_sync='now wait_for mysig';

# Make a thread handle SIGHUP
--let KILL_NODE_PIDFILE = `SELECT @@pid_file`
--perl
  my $kill_sig = $ENV{'KILL_SIGNAL_VALUE'};
  my $pid_filename = $ENV{'KILL_NODE_PIDFILE'};
  my $mysqld_pid = `cat $pid_filename`;
  chomp($mysqld_pid);
  system("kill -HUP $mysqld_pid");
  exit(0);
EOF

#--echo # Waiting for paused_reload_got_mi..
#set debug_sync= "now wait_for paused_reload_got_mi";
sleep 1; # Give time for MI to be gained by signal thread

# While we are shutting down
--send shutdown
--reap

#set debug_sync= "now signal continue_reload";

--source include/wait_until_disconnected.inc
--append_file $MYSQLTEST_VARDIR/tmp/mysqld.2.expect
restart: --skip-slave-start=0
EOF

--connection server_2
--enable_reconnect
--source include/wait_until_connected_again.inc

--connection slave
--enable_reconnect
--source include/wait_until_connected_again.inc

--let $assert_text= Ensure Mariadbd did not segfault when shutting down
--let $assert_select= got signal 11
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_count= 0
--let $assert_only_after = CURRENT_TEST: rpl.rpl_shutdown_sighup
--source include/assert_grep.inc

--connection master
--sync_slave_with_master


--echo #
--echo # Error testcase to ensure an error message is shown if the signal
--echo # takes longer than the timeout while processing the SIGHUP

--connection slave
--source include/stop_slave.inc
set @@global.debug_dbug= @old_dbug;
set @old_dbug= @@global.debug_dbug;
set @@global.debug_dbug= "+d,force_sighup_processing_timeout";
--source include/start_slave.inc

--connection master
insert into t1 values (1);
--source include/save_master_gtid.inc
insert into t1 values (1);
insert into t1 values (1);
insert into t1 values (1);

--connection slave
--source include/sync_with_master_gtid.inc

--write_file $MYSQLTEST_VARDIR/tmp/mysqld.2.expect
wait
EOF

# Make a thread handle SIGHUP
--let KILL_NODE_PIDFILE = `SELECT @@pid_file`
--perl
  my $kill_sig = $ENV{'KILL_SIGNAL_VALUE'};
  my $pid_filename = $ENV{'KILL_NODE_PIDFILE'};
  my $mysqld_pid = `cat $pid_filename`;
  chomp($mysqld_pid);
  system("kill -HUP $mysqld_pid");
  exit(0);
EOF

# While we are shutting down
--send shutdown
--reap

--source include/wait_until_disconnected.inc
--append_file $MYSQLTEST_VARDIR/tmp/mysqld.2.expect
restart: --skip-slave-start=0
EOF

--connection server_2
--enable_reconnect
--source include/wait_until_connected_again.inc

--connection slave
--enable_reconnect
--source include/wait_until_connected_again.inc

--let $assert_text= Ensure warning is issued that signal handler thread is still processing
--let $assert_select= Signal handler thread did not exit in a timely manner.
--let $assert_file= $MYSQLTEST_VARDIR/log/mysqld.2.err
--let $assert_count= 1
--let $assert_only_after = CURRENT_TEST: rpl.rpl_shutdown_sighup
--source include/assert_grep.inc

set @@global.debug_dbug= @old_dbug;


--echo #
--echo # Cleanup
--connection master
drop table t1;

--source include/rpl_end.inc
--echo # End of rpl_shutdown_sighup.test
