###############################################################################
# Bug#13963 SHOW SLAVE HOSTS is unreliable
#
# Slaves only appear in the output of SHOW SLAVE HOSTS when report-host option
# is set. If an expected slave does not appear in the list, nobody knows
# whether the slave does not connect or has started without the "report-host"
# option.
#
# Remove the "Rpl_recovery_rank" column from SHOW SLAVE HOSTS, It is not
# implemented.
#######################################################################
source include/master-slave.inc;
connect (slave2,127.0.0.1,root,,test,$SLAVE_MYPORT2,);

connection slave2;
RESET SLAVE;
--replace_result $MASTER_MYPORT MASTER_PORT
--eval CHANGE MASTER TO master_host='127.0.0.1',master_port=$MASTER_MYPORT,master_user='root'
START SLAVE IO_THREAD;
source include/wait_for_slave_io_to_start.inc;

connection master;
let $show_statement= SHOW SLAVE HOSTS;
let $field= Server_id;
# 3 is server_id of slave2.
let $condition= ='3';
source include/wait_show_condition.inc;
# Make sure that the other slave also had time to register. Otherwise we get
# occasional spurious failures where server_id=2 is missing from SHOW SLAVE
# HOSTS, when that slave is much slower to register due to thread scheduling.
let $condition= ='2';
source include/wait_show_condition.inc;
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

connection slave2;
--source include/stop_slave_io.inc

connection master;
let $show_statement= SHOW SLAVE HOSTS;
let $field= Server_id;
# 3 is server_id of slave2.
let $condition= <> '3';
# All rows of 'SHOW SLAVE HOSTS' are not equal to 3.  It mean that master has
# knew the leave of slave2 and has unregistered it.
let $wait_for_all= 1;
source include/wait_show_condition.inc;
--replace_result $SLAVE_MYPORT SLAVE_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # MDEV-21322: report slave progress to the primary
--echo #

call mtr.add_suppression('Slave I/O: Relay log write failure: could not queue event from master');
call mtr.add_suppression('Replication event checksum verification failed');
call mtr.add_suppression("Timeout waiting for reply of binlog*");
call mtr.add_suppression('Found invalid event in binary log');
call mtr.add_suppression('event read from binlog did not pass crc check');
call mtr.add_suppression('Event crc check failed! Most likely there is event corruption');
call mtr.add_suppression('Slave SQL: Error initializing relay log position: I/O error reading event at position .*, error.* 1593');
call mtr.add_suppression("Semi-sync slave .* reply");

select @@global.rpl_semi_sync_master_wait_point;
reset master;

--echo # Test 1: Primary has not enabled semisync
--echo # Note:   even if not enabled semisync we are expecting to see following
--echo #         columns:
--echo #         `Server_id`,`Host Port`,`Master_id`,`Gtid_State_Sent`,`Gtid_State_Ack`,`Sync`(TODO),
--echo #         where replica with `server_id=2` is already connected
--echo # -----------------------------------------------------------------------
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--echo # Test 2: Primary enabled semisync
--echo # Note:   it should be the same as test 1
--echo # -----------------------------------------------------------------------
set global rpl_semi_sync_master_enabled = 1;
show variables like 'rpl_semi_sync_master_enabled';
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;


--echo # Test 3: Replica (server_id=2) enabled semisync
--echo # Note:   No new GTIDs, so expected empty `Gtid_State_Sent`,`Gtid_State_Ack`
--echo # -----------------------------------------------------------------------
connection slave;
--source include/stop_slave.inc
--source include/reset_slave.inc
set global rpl_semi_sync_slave_enabled = 1;
--source include/start_slave.inc
show variables like 'rpl_semi_sync_slave_enabled';
# Check on replica number of ACKs
show status like "Rpl_semi_sync_slave_send_ack";

connection master;
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 1;
source include/wait_for_status_var.inc;
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;


--echo # Test 4: Make new events - generate new GTID
--echo # Note 1: Create 2 events on primary. Replica is already connected
--echo # Note 2: `Gtid_State_Sent` and `Gtid_State_Ack` should have event group
--echo # -----------------------------------------------------------------------
# Write 2 new events
create table t(t int);
insert into t values (1);

show status like 'Rpl_semi_sync_master_status';
show status like 'Rpl_semi_sync_master_clients';
show status like 'Rpl_semi_sync_master_no_tx';
# There are 2 events
show status like 'Rpl_semi_sync_master_yes_tx';
# Here we should get `Gtid_State_Sent` and `Gtid_State_Ack`
--source include/save_master_gtid.inc # Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Sent;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 1;
source include/wait_show_condition.inc;
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;
show status like 'Rpl_semi_sync_master_clients';
show status like 'Rpl_semi_sync_master_yes_tx';
show status like 'Rpl_semi_sync_master_no_tx';
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';

connection slave;
# Check the table on slave
--let $diff_tables=master:test.t,slave:test.t
--source include/diff_tables.inc

# Check on replica number of ACKs
show status like "Rpl_semi_sync_slave_send_ack";

--echo # Test 5: Enable semi-sync for slave2
--echo # Note 1: Replica (`server_id=3`) should be started and semi-sync enabled
--echo # Note 2: In semi-sync replication ACK thread (on primary),
--echo #         waits only on single replica to respond about received events.
--echo # Note 3: Since `Gtid_State_Ack` is received for 2 events
--echo #         from `server_id=2` in previous test and there is no new event
--echo #         in this test, primary is resending old transactions,
--echo #         we are expecting empty `Gtid_State_Ack` for `server_id=3`
--echo #         in show statement (see Note 2).
--echo # -----------------------------------------------------------------------
# Replica is already stopped
connection slave2;
set global rpl_semi_sync_slave_enabled = 1;
--source include/start_slave.inc
show variables like 'rpl_semi_sync_slave_enabled';
show status like "Rpl_semi_sync_slave_send_ack";

connection master;
# - Check number of semi-sync replicas - 2 should be connected
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_clients';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

connection slave2;
# Check the table on slave2
--let $diff_tables=master:test.t,slave:test.t,slave2:test.t
--source include/diff_tables.inc

# Check on replica 2 number of ACKs
show status like "Rpl_semi_sync_slave_send_ack";

connection slave;
let $slave1_sent_ack= query_get_value(show status like 'Rpl_semi_sync_slave_send_ack', Value, 1);
# Check on replica 1 number of ACKs
show status like "Rpl_semi_sync_slave_send_ack";

--echo # Test 6: Create new transactions on primary
--echo # Note:   New transactions on primary are sent to replicas
--echo #         and connected replicas (`server_id=2` and `server_id=3`)
--echo #         should sync to the GTID state on primary.
--echo # -----------------------------------------------------------------------
connection master;
# Check old counters for _get_ack and _request_ack on primary
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';
let $master_get_ack_num= query_get_value(show status like 'Rpl_semi_sync_master_get_ack', Value, 1);
let $master_request_ack_num= query_get_value(show status like 'Rpl_semi_sync_master_request_ack', Value, 1);

# In this test there are 2 active replicas and 1 transactions.
# Using DBUG_SYNC(pause_ack_thread_on_next_ack)
# test will ensure that we should wait on single ACK from active replica.
--let $save_primary_dbug= `SELECT @@GLOBAL.DEBUG_DBUG`
SET @@GLOBAL.DEBUG_DBUG="d,pause_ack_thread_on_next_ack";
SELECT @@GLOBAL.DEBUG_DBUG;

# Write the new event
create table t2(t2 int);
SET debug_sync='now WAIT_FOR pause_ack_reply_to_binlog';

# In this point master_request_ack should be incremented
# Check number of received transactions and requested ACKs
let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= `SELECT $master_request_ack_num + 1`;
source include/wait_for_status_var.inc;
--echo "Waited on master_request_ack"

# In this test we did not check for `Rpl_semi_sync_master_get_ack`, since it gets
# incremented for each event that is sent to the replica, that needs an ack.
# Primary sends event to one replica and gets ACK, before the replica even tries
# sending the event to the other replica, after which other replica sends ACK
# for the same event, so increment for `$master_get_ack_num` below would be 4.
# However this can fail on bb, where increment can be 4 or 3.
# It was tried to add `Rpl_semi_sync_master_net_waits` but increment was 3,
# so could not create stable test.
# Instead use latest value obtained for the status `Rpl_semi_sync_master_get_ack`.

# Result show statement
--source include/save_master_gtid.inc #Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Sent;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 1;
source include/wait_show_condition.inc;
--echo "Waited on Gtid_State_Sent be sent to all replicas
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo # The test disables master
--echo # Wait on master to be started.
let $status_var= Rpl_semi_sync_master_status;
let $status_var_value= ON; 
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_status';
show variables like 'rpl_semi_sync_master_enabled';

--echo # Check statuses on slave - should not be OFF
connection slave;
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show variables like 'rpl_semi_sync_slave_status';
show variables like 'rpl_semi_sync_slave_enabled';

connection slave2;
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show variables like 'rpl_semi_sync_slave_status';
show variables like 'rpl_semi_sync_slave_enabled';

connection master;

# Wait that number of active transactions gets incremented
let $status_var= Rpl_semi_sync_master_yes_tx;
let $status_var_comparsion= >=;
let $status_var_value= `SELECT $master_request_ack_num + 1`;
source include/wait_for_status_var.inc;
--echo # Wait that number of active transaction is incremented
show status like 'Rpl_semi_sync_master_yes_tx';

--echo # Check condition (get ack) before getting the ACK
show status like 'Rpl_semi_sync_master_get_ack';

SET debug_sync='now SIGNAL unpause_ack_reply_to_binlog';

# Wait on master's get_ACK 
--echo # Get ack before
let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_comparsion= >=;
let $status_var_value= `SELECT $master_get_ack_num + 1`;
source include/wait_for_status_var.inc;

--echo # Reset debug sync on primary
--eval SET @@GLOBAL.debug_dbug= "$save_primary_dbug"
SET debug_sync='RESET';
SELECT @@GLOBAL.debug_dbug;

# Here we know that there will be single active replica that has sent ACK
# and master got the ack, while other replica will be stale.
# If the transaction is not committed on primary we may get new master_get_ack_num
# from other replica
# Result show statement
--source include/save_master_gtid.inc #Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Ack;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 0;
# we have to reset comparision
let $status_var_comparsion= =;
source include/wait_show_condition.inc;
--echo "Waited on Gtid_State_Ack be obtained to single replica

--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_get_ack';
# Determine binlog_dump_thread_count, number of connected semi-sync replica
show status like "Slaves_connected";

# Update ACK get/request number
let $master_request_ack_num= `SELECT $master_request_ack_num + 1`;
# Here we may have get increment by 4 or by 3 for `rpl_semi_sync_master_get_ack`,
# so instead of manual increment, get the returned value of status.
let $master_get_ack_num= query_get_value(show status like 'Rpl_semi_sync_master_get_ack', Value, 1);

# Check ACKs on replica server_id=2
connection slave;
let $status_var= Rpl_semi_sync_slave_send_ack;
let $status_var_value= `SELECT $slave1_sent_ack + 1`;
source include/wait_for_status_var.inc;
show status like "Rpl_semi_sync_slave_send_ack";

# Check ACKs on on replica server_id=3:
# 2 ACKs are already sent by server_id=2
# On some bb slave2 increments send_ack by 1 instead of by 2
# so let's not show it here.

--echo # Test 7: Simulate stop of the IO thread of replica
--echo # Note 1: Stopping the IO thread will unregister replica from master info
--echo #         so for `server_id=2`, `rpl_semi_sync_slave_status` will be `OFF`
--echo #         and so should not be visible in show statement output.
--echo # Note 2: New event will be created and successfully sent and acked by `server_id=3`
--echo # Note 3: Starting the IO thread again for `server_id=2` will enable `rpl_semi_sync_slave_status`,
--echo #         but since there is no new transaction and `ack` counter is reseted,
--echo #         `Gtid_State_Sent` and `Gtid_State_Ack` will be empty.
--echo # Note 4: When synching replica with primary, primary will resent the old
--echo #         transaction, so `Gtid_State_Sent` will be the same event group
--echo #         as `server_id=3`(replica that ACKed the transaction), but since
--echo #         there is no new transaction on primary `Gtid_State_Ack` will
--echo #         remain empty.
--echo # -----------------------------------------------------------------------
connection slave;
show variables like 'rpl_semi_sync_slave_enabled';
show variables like 'rpl_semi_sync_slave_status';

STOP SLAVE IO_THREAD;
--source include/wait_for_slave_io_to_stop.inc

let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= OFF;
source include/wait_for_status_var.inc;
# Status should be changed
show variables like 'rpl_semi_sync_slave_status';
# Check slave_send_ack is reseted when replica is stopped
show status like "Rpl_semi_sync_slave_send_ack";

connection master;
# Note: without waiting that master [un]registers replica, multiple rows (cached) for
# the same replica may be showed in show replica hosts statement
# in case if `Rpl_semi_sync_master_clients` is used, so use `Slaves_connected`
# for the wait condition.
let $status_var= Slaves_connected;
let $status_var_value= 1;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";

# Initial show statement
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
# Show statement should not show server_id=2
SHOW REPLICA HOSTS;

connection master;
--echo # Check master status before new event test 7
let $status_var= Rpl_semi_sync_master_status;
let $status_var_value= ON; 
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_status';

# Write the new event
INSERT INTO t VALUES (10);

let $status_var= Rpl_semi_sync_master_status;
let $status_var_value= ON; 
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_status';
show variables like 'rpl_semi_sync_master_enabled';

# Wait on transaction/request/ack and show them
let $status_var= Rpl_semi_sync_master_yes_tx;
let $status_var_value= `SELECT $master_request_ack_num + 1`;
source include/wait_for_status_var.inc;

let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= `SELECT $master_get_ack_num + 1`;
source include/wait_for_status_var.inc;

let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= `SELECT $master_request_ack_num + 1`;
source include/wait_for_status_var.inc;

show status like 'Rpl_semi_sync_master_get_ack';
show status like 'Rpl_semi_sync_master_request_ack';

# Update ACK get/request number
let $master_request_ack_num= `SELECT $master_request_ack_num + 1`;
let $master_get_ack_num= `SELECT $master_get_ack_num + 1`;

# Result show statement
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

connection slave;
START SLAVE IO_THREAD;
--source include/wait_for_slave_io_to_start.inc

# Wait on the slave status change
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show variables like 'rpl_semi_sync_slave_status';
show variables like 'rpl_semi_sync_slave_enabled';
# Check slave_send_ack is still reseted
show status like "Rpl_semi_sync_slave_send_ack";

connection master;
let $status_var= Slaves_connected;
let $status_var_value= 2;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";

# It may happen that primary does not resend the transaction and that
# `Slaves_connected` is 2 and `rpl_semi_sync_master_clients` is still 1
# Ensure with waiting on ACK
--source include/save_master_gtid.inc #Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Sent;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_clients';

--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo "Sync replica with master"
sync_slave_with_master;

connection master;
# After sync slave with master, the number of semi_sync clients is incremented
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_clients';

# Primary did resend transactions:
# `Gtid_state_ack` for `server_id=2` should be NULL, since no new events are active
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

# Master's get ACK and request ACK should be the same as before
let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= $master_get_ack_num;
source include/wait_for_status_var.inc;
let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= $master_request_ack_num;
source include/wait_for_status_var.inc;
show status like "Rpl_semi_sync_master_get_ack";
show status like "Rpl_semi_sync_master_request_ack";

--echo # Test 8: Replica `server_id=2` failure with `corrupt_queue_event`
--echo # Note 1: Simulate replicas failure by making replica busy.
--echo #         Consequence is that replica will be unregistered and that is why
--echo #         we need to wait that replica unregisters (`Slaves_connected`).
--echo #         By creating new event, only active replicas should respond
--echo #         (`server_id=3`) with ACK
--echo # Note 2: In order not to show old result from `server_id=2`,from busy replica
--echo #         we have to *wait* that binlog_dump_thread_count shows status 
--echo #         `Slaves_connected` decreased and after that check show statement.
--echo # -----------------------------------------------------------------------
connection slave;
--let $sav_server_2_dbug= `SELECT @@GLOBAL.debug_dbug`
SET @@GLOBAL.debug_dbug= "+d,corrupt_queue_event";

connection master;
# Write the new event
INSERT INTO t VALUES (3);

# Wait on master's get/request ACK num
let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= `SELECT $master_get_ack_num + 1`;
source include/wait_for_status_var.inc;
let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= `SELECT $master_request_ack_num + 1`;
source include/wait_for_status_var.inc;
let $status_var= Slaves_connected;
let $status_var_value= 1;
source include/wait_for_status_var.inc;
show status like "Rpl_semi_sync_master_get_ack";
show status like "Rpl_semi_sync_master_request_ack";
show status like "Slaves_connected";
# Update get/request ACK number
let $master_request_ack_num= `SELECT $master_request_ack_num + 1`;
let $master_get_ack_num= `SELECT $master_get_ack_num + 1`;

--source include/save_master_gtid.inc #Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Ack;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 1;
source include/wait_show_condition.inc;
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

# Setting the old value for debug_dbug will not start the slave
connection slave;
--eval SET @@GLOBAL.debug_dbug= "$sav_server_2_dbug"

connection master;
let $status_var= Slaves_connected;
let $status_var_value= 1;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";
show status like 'Rpl_semi_sync_master_clients';
# Result show statement should be the same as before
--connection master
--source include/save_master_gtid.inc # Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Ack;
let $condition= LIKE '%$master_pos%';
source include/wait_show_condition.inc;

--echo # Test 9: Stop `server_id=3`
--echo # Note:   Check that no replicas get new generated event, so show statement
--echo #         is expected to be empty.
--echo # -----------------------------------------------------------------------
connection slave2;
--source include/stop_slave.inc
# Check slave_send_ack is reseted when replica is stopped
show status like "Rpl_semi_sync_slave_send_ack";
--source include/reset_slave.inc
# Check slave_send_ack is reseted when replica is reseted
show status like "Rpl_semi_sync_slave_send_ack";

connection master;
# Here both replicas are off and primary will wait on ACK timeout (default 10),
# and turn-off semi-sync status, so let's decrease timeout.
--let $save_default_master_timeout= `SELECT @@GLOBAL.rpl_semi_sync_master_timeout`
select @@global.rpl_semi_sync_master_timeout;
set @@global.rpl_semi_sync_master_timeout= 2000;
select @@global.rpl_semi_sync_master_timeout;

let $status_var= Slaves_connected;
let $status_var_value= 0;
source include/wait_for_status_var.inc;
show status like "Slaves_connected";

# get_ack and request_ack stay the same
let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= $master_get_ack_num;
source include/wait_for_status_var.inc;

let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= $master_request_ack_num;
source include/wait_for_status_var.inc;

show status like 'Rpl_semi_sync_master_no_tx';
show status like 'Rpl_semi_sync_master_yes_tx';
show status like 'Rpl_semi_sync_master_clients';
show status like 'rpl_semi_sync_master_get_ack';
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'Rpl_semi_sync_master_status';

# Write the new event
INSERT INTO t VALUES (5);

# When there are no semi-sync replicas and new event, master will wait timeout,
# (set by 2[s]) and will disable master status, because commit ACK has not occured
let $status_var= Rpl_semi_sync_master_status;
let $status_var_value= OFF;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_status';
show status like 'Rpl_semi_sync_master_no_tx';
show status like 'Rpl_semi_sync_master_yes_tx';
show status like 'Rpl_semi_sync_master_request_ack';
show status like 'rpl_semi_sync_master_get_ack';

--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo # Start slaves again
connection slave;
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
--sync_with_master

connection slave2;
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';
--sync_with_master

--echo # sync with master, should ENABLE master_status
connection master;
let $status_var= Rpl_semi_sync_master_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_status';

# There will be 2 get ACKS from 2 replicas for 1 event
let $status_var= Rpl_semi_sync_master_get_ack;
let $status_var_value= `SELECT $master_get_ack_num + 1`;
source include/wait_for_status_var.inc;

let $status_var= Rpl_semi_sync_master_request_ack;
let $status_var_value= `SELECT $master_request_ack_num + 1`;
source include/wait_for_status_var.inc;
show status like 'Rpl_semi_sync_master_yes_tx';

# Update ACK get/request number
let $master_request_ack_num= `SELECT $master_request_ack_num + 1`;
let $master_get_ack_num= `SELECT $master_get_ack_num + 1`;

--echo # Test 10: Testing `rpl_semi_sync_master_timeout=0`
--echo # Note 1:  For asynchronous replication `Gtid_state_sent` is not null,
--echo #          but `Gtid_state_ack` is null.
--echo # Note 2:  We want that `rpl_semi_sync_master_timeout=0` be edge case,
--echo #          by mimicking asynchronous replication, as semi-sync stalled
--echo #          replication type, for which `Gtid_state_ack` should reflect
--echo #          the latest received transaction by the replica[s].
--echo #          Also `rpl_semi_sync_master_status` has
--echo #          to remain `ON`, instead switching off, so instead of
--echo #          no waiting on ACK, primary must wait on ACK from replica.
--echo # Note 3:  With this option we want `Gtid_state_ack` to reflect
--echo #          the latest received transaction by the replica[s].
--echo # -----------------------------------------------------------------------
# Test DBUG_SYNC by stopping the slave and testing the new sync point
# Note we need to stop both slaves in order to control sent ACK for new active transaction

--echo # Initial number of ACK get/requests
show status like 'rpl_semi_sync_master_get_ack';
show status like 'rpl_semi_sync_master_request_ack';
show variables like 'rpl_semi_sync_master_enabled';

# Master status must be `ON`
let $status_var= rpl_semi_sync_master_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_master_status';

set global rpl_semi_sync_master_timeout=0;
select @@global.rpl_semi_sync_master_timeout;
# here rpl_semi_sync_master_status=0 means async is taking place (no wait on ACK from slave)
show variables like 'rpl_semi_sync_master_timeout';

connection slave;
--source include/stop_slave.inc
--let $save_server_2_dbug= `SELECT @@GLOBAL.DEBUG_DBUG`
SET @@GLOBAL.DEBUG_DBUG="d,synchronize_semisync_slave_reply";
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';

connection slave2;
--source include/stop_slave.inc
--let $save_server_3_dbug= `SELECT @@GLOBAL.DEBUG_DBUG`
SET @@GLOBAL.DEBUG_DBUG="d,synchronize_semisync_slave_reply";
--source include/start_slave.inc
let $status_var= rpl_semi_sync_slave_status;
let $status_var_value= ON;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_slave%';

connection master;
# Write event
INSERT INTO t values (1111);

--echo # Both replicas are stopped with synchronization point after master's new event
--connection slave
SET debug_sync='now WAIT_FOR at_slave_reply';

--connection slave2
SET debug_sync='now WAIT_FOR at_slave_reply';

--connection master
# There will be no GET ACK so good enough to check
# if the initial `rpl_semi_sync_master_get_ack` is observed
let $status_var= rpl_semi_sync_master_get_ack;
let $status_var_value= `SELECT $master_get_ack_num`;
source include/wait_for_status_var.inc;
show status like 'rpl_semi_sync_master_get_ack';

# Checking show statement:
# `Gtid_State_Sent` > `Gtid_State_Ack` (ACK is empty)
--echo # `Gtid_State_Sent` event sent from primary
--source include/save_master_gtid.inc # Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Sent;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 1;
source include/wait_show_condition.inc;
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

# Allow server_id= 2 to send the ACK
connection slave;
SET debug_sync='now SIGNAL reply_ack_to_master';

--echo # Replica server_2 has sent ACK
# It may be race condition, so wait on proper master GTID for replica 2
# We have to ensure that at least 1 row has latest GTID as ACK
# Problem occured that `Gtid_State_Sent` was delayed record
# Note we need `wait_for_all` be 0 since
# not all rows will have condition fullfiled
--connection master
--source include/save_master_gtid.inc # Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Ack;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

let $status_var= rpl_semi_sync_master_get_ack;
let $status_var_value= `SELECT $master_get_ack_num + 1`;
source include/wait_for_status_var.inc;
# Update master's get ACK number
let $master_get_ack_num= `SELECT $master_get_ack_num + 1`;
show status like 'rpl_semi_sync_master_get_ack';
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

# Allow server_id= 3 to send the ACK
connection slave2;
SET debug_sync='now SIGNAL reply_ack_to_master';

--echo # Replica server_3 has sent ACK
# GTID_sent == GTID_ack (already sent by server_id=2)
# It may be race condition, so wait on proper master GTID for replica 3
# We have to ensure that at least 1 row has latest GTID as ACK
--connection master
--source include/save_master_gtid.inc # Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Ack;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

# Here we will not check the since primary may or may not receive the get ACK
# from second replica, if it already received the same number of requested ACKs.
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

sync_slave_with_master slave2;

--echo # Sync server_3 with master should return the same result as before
connection master;
--source include/save_master_gtid.inc # Saves the gtid into $master_pos
let $show_statement= SHOW REPLICA HOSTS;
let $field= Gtid_State_Ack;
let $condition= LIKE '%$master_pos%';
let $wait_for_all= 0;
source include/wait_show_condition.inc;
--replace_column 3 'SLAVE_PORT'
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW REPLICA HOSTS;

--echo # cleanup
--echo # -------------------------------------------
connection master;
--eval SET @@GLOBAL.rpl_semi_sync_master_timeout= $save_default_master_timeout
SET GLOBAL rpl_semi_sync_master_enabled = 0;
drop table t;
drop table t2;
--source include/save_master_gtid.inc
--save_master_pos

connection slave;
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
--eval SET @@GLOBAL.debug_dbug= "$save_server_2_dbug"
SET debug_sync='RESET';
set global rpl_semi_sync_slave_enabled = 0;
--source include/start_slave.inc
show variables like 'rpl_semi_sync_slave_enabled';

connection slave2;
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
set global rpl_semi_sync_slave_enabled = 0;
--eval SET @@GLOBAL.debug_dbug= "$save_server_3_dbug"
SET debug_sync='RESET';
--source include/start_slave.inc
show variables like 'rpl_semi_sync_slave_enabled';
--source include/stop_slave.inc

# End of tests
--source include/rpl_end.inc
