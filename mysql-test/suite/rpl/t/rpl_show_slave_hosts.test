###############################################################################
# Bug#13963 SHOW SLAVE HOSTS is unreliable
#
# Slaves only appear in the output of SHOW SLAVE HOSTS when report-host option
# is set. If an expected slave does not appear in the list, nobody knows
# whether the slave does not connect or has started without the "report-host"
# option.
#
# Remove the "Rpl_recovery_rank" column from SHOW SLAVE HOSTS, It is not
# implemented.
#######################################################################
--let $rpl_topology= 1->2,1->3
--source include/rpl_init.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc

connection server_1;
let $show_statement= SHOW SLAVE HOSTS;
let $field= Server_id;
# 3 is server_id of slave2.
let $condition= ='3';
source include/wait_show_condition.inc;
# Make sure that the other slave also had time to register. Otherwise we get
# occasional spurious failures where server_id=2 is missing from SHOW SLAVE
# HOSTS, when that slave is much slower to register due to thread scheduling.
let $condition= ='2';
source include/wait_show_condition.inc;
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

connection server_3;
--source include/stop_slave_io.inc

connection server_1;
let $show_statement= SHOW SLAVE HOSTS;
let $field= Server_id;
# 3 is server_id of slave2.
let $condition= <> '3';
# All rows of 'SHOW SLAVE HOSTS' are not equal to 3.  It mean that master has
# knew the leave of slave2 and has unregistered it.
let $wait_for_all= 1;
source include/wait_show_condition.inc;
--replace_result $SLAVE_MYPORT SLAVE_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # MDEV-21322: report slave progress to the primary
--echo #

--echo #
--echo # 21322.0: Test case set-up
--echo #
connection server_1;
set sql_log_bin=0;
call mtr.add_suppression("Got an error reading communication packets");
call mtr.add_suppression("Semi-sync master failed on net_flush");
call mtr.add_suppression("Could not read packet:.* vio_errno: 1158");
call mtr.add_suppression("Could not write packet:.* vio_errno: 1160");
set sql_log_bin=1;
set @save_primary_dbug= @@global.debug_dbug;
set @save_semisync_timeout= @@global.rpl_semi_sync_master_timeout;
set @save_semisync_master_enabled= @@global.rpl_semi_sync_master_enabled;
create table t1 (a int);

connection server_2;
set @save_s2_debug= @@GLOBAL.debug_dbug;
set @save_semisync_server_2_enabled= @@global.rpl_semi_sync_master_enabled;
set sql_log_bin=0;
call mtr.add_suppression('Slave I/O: Relay log write failure: could not queue event from master.*');
call mtr.add_suppression('Slave I/O: Replication event checksum verification failed while reading from network.*');
call mtr.add_suppression('Replication event checksum verification failed');
call mtr.add_suppression("Timeout waiting for reply of binlog*");
call mtr.add_suppression('Found invalid event in binary log');
call mtr.add_suppression('event read from binlog did not pass crc check');
call mtr.add_suppression('Event crc check failed! Most likely there is event corruption');
call mtr.add_suppression('Slave SQL: Error initializing relay log position: I/O error reading event at position .*, error.* 1593');
call mtr.add_suppression("Semi-sync slave .* reply");
set sql_log_bin=1;

connection server_3;
set @save_s3_debug= @@GLOBAL.debug_dbug;
set @save_semisync_server_3_enabled= @@global.rpl_semi_sync_master_enabled;
set sql_log_bin=0;
call mtr.add_suppression('Slave I/O: Relay log write failure: could not queue event from master.*');
call mtr.add_suppression('Slave I/O: Replication event checksum verification failed while reading from network.*');
call mtr.add_suppression('Replication event checksum verification failed');
call mtr.add_suppression("Timeout waiting for reply of binlog*");
call mtr.add_suppression('Found invalid event in binary log');
call mtr.add_suppression('event read from binlog did not pass crc check');
call mtr.add_suppression('Event crc check failed! Most likely there is event corruption');
call mtr.add_suppression('Slave SQL: Error initializing relay log position: I/O error reading event at position .*, error.* 1593');
call mtr.add_suppression("Semi-sync slave .* reply");
set sql_log_bin=1;

--connection server_1
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc


--echo #
--echo # 21322.1: In a fresh replication state with semi-sync disabled,
--echo # the Sync_Status column should reflect an asynchronous replication
--echo # state, and Gtid_Pos_Sent/Ack should start NULL, and only
--echo # Gtid_Pos_Sent should update with new transaction. Note only server_2
--echo # is currently connected.
--echo #
--connection server_1
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;
insert into t1 values (1);
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc

--connection server_1
--echo # Gtid_Pos_Sent should be updated for new transaction
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;
--let $master_gtid= `SELECT @@gtid_binlog_pos`
--let $gtid_sent= query_get_value(show slave hosts, Gtid_Pos_Sent, 1)
if (`SELECT strcmp("$master_gtid","$gtid_sent") != 0`)
{
  --echo # Master gtid_binlog_pos: $master_gtid
  --echo # Gtid_Pos_Sent: $gtid_sent
  --die Master did not update Gtid_Pos_Sent for asynchronous replica
}


--echo #
--echo # 21322.2: When only the primary enables semi-sync, Sync_Status should
--echo # still be asynchronous
--echo #
--connection server_1
set global rpl_semi_sync_master_enabled= 1;
show variables like 'rpl_semi_sync_master_enabled';
--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # 21322.3: Finalizing the semi-sync connection on server_2 (i.e. by
--echo # enabling it on the slave) should update Sync_Status to semi-sync
--echo # active, as the slave is up-to-date.
--echo #

--connection server_2
--source include/stop_slave.inc
set global rpl_semi_sync_slave_enabled = 1;
--source include/start_slave.inc

--connection server_1
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 1;
source include/wait_for_status_var.inc;

--echo # Waiting for dump thread to recognize replica is up-to-date..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Sync_Status;
let $condition= LIKE 'Semi-sync Active';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--replace_result $SLAVE_MYPORT SLAVE_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # 21322.4: After new semi-sync transactions are ACKed,
--echo # Gtid_Pos_Sent/Ack should match gtid_binlog_pos, and Sync_Status
--echo # should read that semi-sync is active
--echo #
--connection server_1
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc

--connection server_1
--let $master_gtid= `SELECT @@gtid_binlog_pos`

--echo # Ensuring master gtid_binlog_pos matches Gtid_Pos_Sent
--let $gtid_sent= query_get_value(show slave hosts, Gtid_Pos_Sent, 1)
if (`SELECT strcmp("$master_gtid","$gtid_sent") != 0`)
{
  --echo # Master gtid_binlog_pos: $master_gtid
  --echo # Gtid_Pos_Sent: $gtid_sent
  --die Master's gtid_binlog_pos should match Gtid_Pos_Sent, but doesn't
}

--echo # Ensuring master gtid_binlog_pos matches Gtid_Pos_Ack
# Note we don't need to do a wait_for_status_var here because the transaction
# already returned, and thereby the ACK should have been received (or timeout,
# which would invalidate the check anyway.)
--let $gtid_ack= query_get_value(show slave hosts, Gtid_Pos_Ack, 1)
if (`SELECT strcmp("$master_gtid","$gtid_ack") != 0`)
{
  --echo # Master gtid_binlog_pos: $master_gtid
  --echo # Gtid_Pos_Ack: $gtid_ack
  --die Master's gtid_binlog_pos should match Gtid_Pos_Ack, but doesn't
}

--echo # Ensuring Sync_Status is semi-sync active
--let $sync_status= query_get_value(show slave hosts, Sync_Status, 1)
if (`SELECT strcmp("$sync_status","semi-sync active") != 0`)
{
  --echo # Sync_Status: $sync_status
  --die Incorrect value for Sync_Status, should be "semi-sync active"
}

--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # 21322.5: When connecting a new slave (server_id 3) which initially has
--echo # semi-sync disabled, SHOW SLAVE HOSTS on the master should show its
--echo # Sync_Status as asynchronous (while server_id 2 is still semi-sync
--echo # active).
--echo #
# Iniital replication state on server_3 is off
connection server_3;
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc

# No wait_for_status_var needed, as we are asynchronous and the previous
# sync_with_master_gtid.inc infers Gtid_Pos_Sent should be up-to-date (and
# thereby, Sync_Status should be up-to-date as well).
connection server_1;
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--echo #
--echo # 21322.6: Reconnecting server_3 as a semi-sync enabled replica should
--echo # result in a Sync_Status reflecting active semi-sync
--echo #

connection server_3;
--source include/stop_slave.inc
set global rpl_semi_sync_slave_enabled = 1;
--source include/start_slave.inc

connection server_1;
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;

--echo # Waiting for dump thread to recognize server_3 is up-to-date..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Sync_Status;
let $condition= LIKE 'Semi-sync Active';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # 21322.7: New transactions on the master should update Gtid_Pos_Sent
--echo # when sent to the slave, and Gtid_Pos_Ack once receiving an ACK
--echo #

--connection server_2
let $server_2_sent_ack= query_get_value(show status like 'Rpl_semi_sync_slave_send_ack', Value, 1);

--connection server_1
SET @@GLOBAL.debug_dbug="+d,pause_ack_thread_on_next_ack";

# Write the new event
--connection default
--let $old_binlog_gtid= `SELECT @@gtid_binlog_pos`
--let $nextval= `SELECT max(a)+1 from t1`
--send_eval insert into t1 values ($nextval)

--connection server_1
--echo # waiting for pause_ack_reply_to_binlog
SET debug_sync='now WAIT_FOR pause_ack_reply_to_binlog';
--let $new_binlog_gtid= `SELECT @@gtid_binlog_pos`

--echo # Waiting for Gtid_Pos_Sent to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$new_binlog_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--echo # Ensuring Gtid_Pos_Ack is not yet updated (as ACK thread is paused)
--let $gtid_ack= query_get_value(show slave hosts, Gtid_Pos_Ack, 1)
if (`SELECT strcmp("$old_binlog_gtid","$gtid_ack") = 0`)
{
  --echo # Master gtid_binlog_pos: $old_binlog_gtid
  --echo # Gtid_Pos_Ack: $gtid_ack
  --die Gtid_Pos_Ack should not yet reflect the GTID of the new transaction
}

--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--connection server_1
SET debug_sync='now SIGNAL resume_ack_thread';

--connection default
--reap
--connection server_1

--echo # Waiting for Gtid_Pos_Ack to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$new_binlog_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--echo # Reset debug state
SET @@GLOBAL.debug_dbug= @save_primary_dbug;
SET debug_sync='RESET';


--echo #
--echo # 21322.8: Holding one replica's ACK (server_2) should result in
--echo # Gtid_Pos_Ack of server_3 updating to the most recent GTID, while
--echo # server_id 2 has the old GTID. Note that we need to use debug_sync to
--echo # synchronize the ACKs of both server_2 and server_3, so server_3 can't
--echo # ACK the transaction before server_2's binlog dump thread sends the
--echo # transaction (which would negate the need for server_2 to ACK at all,
--echo # resulting in MTR hanging on its expected debug_sync WAIT_FOR point.)
--echo #

--connection server_2
--source include/stop_slave.inc
set @@GLOBAL.debug_dbug="+d,synchronize_semisync_slave_reply";
--source include/start_slave.inc
--connection server_3
--source include/stop_slave.inc
set @@GLOBAL.debug_dbug="+d,synchronize_semisync_slave_reply";
--source include/start_slave.inc

--connection server_1
--echo # Waiting for master to recognize slave restart..
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;

--let $nextval= `SELECT max(a)+1 from t1`
--send_eval insert into t1 values ($nextval)

--connection server_2
set debug_sync= "now WAIT_FOR at_slave_reply";
--connection server_3
set debug_sync= "now WAIT_FOR at_slave_reply";

# New transaction is binlogged at this point, so we can query gtid_binlog_pos
--connection default
--let $binlog_gtid= `SELECT @@gtid_binlog_pos`

--echo # Ensure Gtid_Pos_Sent reflects latest transaction ($binlog_gtid) for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$binlog_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--connection server_3
set debug_sync= "now SIGNAL reply_ack_to_master";

--connection server_1
--reap

--echo # Wait for Gtid_Pos_Ack to show the latest transaction for server_3..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$binlog_gtid';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

--echo # Only server_3 should have ACKed the new GTID, server_2 should not due to debug_sync holding off the ACK
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--connection server_2
--echo # Resume slave so it can ACK the transaction
set debug_sync= "now SIGNAL reply_ack_to_master";

--echo # Waiting for Gtid_Pos_Ack to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$binlog_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--connection server_1
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--connection server_2
--source include/stop_slave.inc
set @@GLOBAL.debug_dbug= @save_s2_debug;
SET debug_sync='RESET';
--source include/start_slave.inc

--connection server_3
--source include/stop_slave.inc
set @@GLOBAL.debug_dbug= @save_s3_debug;
SET debug_sync='RESET';
--source include/start_slave.inc

--connection server_1
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc
--connection server_3
--source include/sync_with_master_gtid.inc


--echo #
--echo # 21322.9: If a server is behind when connecting to a primary (i.e. the
--echo # primary has newer transactions), the replica Sync_Status should
--echo # present as semi-sync stale and the Gtid_Pos_Ack should not populate
--echo # until it has reached Semi-Sync Active
--echo #

--connection server_2
--source include/stop_slave.inc

--connection server_1
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
--source include/save_master_gtid.inc
--let $binlog_gtid= `SELECT @@gtid_binlog_pos`
--echo # Pause dump_thread of server_2 (server_3 won't be affected as it has
--echo # already successfully ACKed the new transaction)
set @@global.debug_dbug= "+d,pause_dump_thread_after_sending_next_full_trx";

--connection server_2
--source include/start_slave.inc

--connection server_1
set debug_sync= 'now WAIT_FOR dump_thread_paused';

--echo # Ensure Gtid_Pos_Sent is updated to represent new transaction has
--echo # been sent to both replicas
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$binlog_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--echo # Ensure Sync_Status is Semi-sync Stale for the debug_sync held dump
--echo # thread, as it hasn't yet got "up-to-date"
let $show_statement= SHOW SLAVE HOSTS;
let $field= Sync_Status;
let $condition= LIKE 'Semi-sync Stale';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

set debug_sync= 'now SIGNAL dump_thread_continue';

--echo # Ensure Sync_Status will automatically update to Semi-sync Active
--echo # once the last stale transaction has finished sending
let $show_statement= SHOW SLAVE HOSTS;
let $field= Sync_Status;
let $condition= LIKE 'Semi-sync Active';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

set @@global.debug_dbug= @save_primary_dbug;
SET debug_sync='RESET';

--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc
--connection server_3
--source include/sync_with_master_gtid.inc


--echo #
--echo # 21322.10a: If one replica errors (i.e. server_2 by injecting
--echo # corrupt_gtid_event with debug_dbug), it shouldn't send its ACK,
--echo # and server_3 does ACK; then Gtid_Pos_Sent should still reflect the
--echo # new transaction for each replica, but Gtid_Pos_Ack should only be
--echo # updated by the successful transaction. When the errored replica
--echo # reconnects, it shouldn't ACK the transaction, so its on-reconnect
--echo # Gtid_Pos_Ack value should be NULL, but still have a Sync_Status
--echo # of "Semi-sync Active" when it receives the latest transaction, as it
--echo # will be ready to ACK new transactions going forward.
--echo #
--connection server_2
--source include/stop_slave.inc
SET @@GLOBAL.debug_dbug= "+d,corrupt_gtid_event";
--source include/start_slave.inc

--echo # Set-up server_3 for 10b (so we don't have to restart the slave)
--connection server_3
--source include/stop_slave.inc
set @@GLOBAL.debug_dbug="+d,synchronize_semisync_slave_reply";
--source include/start_slave.inc

--connection server_1
--echo # Waiting for master to recognize slave restarts..
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;

--connection server_1
--let $nextval= `SELECT max(a)+1 from t1`
--send_eval insert into t1 values ($nextval)

--echo # Debug_sync is irrelevant to this testcase (10a) but we must do it to
--echo # allow server_3 to ACK now (Note debug_sync is needed for 10b)
--connection server_3
set debug_sync= "now WAIT_FOR at_slave_reply";
set debug_sync= "now SIGNAL reply_ack_to_master";

--connection server_1
--reap
--let $binlog_gtid= `SELECT @@gtid_binlog_pos`
--source include/save_master_gtid.inc

--echo # Waiting for Gtid_Pos_Sent to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$binlog_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--connection server_2
--let $slave_io_errno= 1595
--source include/wait_for_slave_io_error.inc
set @@GLOBAL.debug_dbug= @save_s2_debug;

--connection server_1
--echo # Only server_3 should ACKed have the new GTID, server_2 should not due to corrupt_queue_event
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--connection server_2
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc

--connection server_1
--echo # With replica restarted/synced, its Gtid_Pos_Ack should be NULL with Sync_Status semi-sync active
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;


--echo #
--echo # 21322.10b: Succeeding the previous 10a test, if server_3 now stalls
--echo # (i.e. using debug_sync), then the previously errored server_2 should
--echo # receive and ACK new transactions as a "lone" replica, and update its
--echo # Gtid_Pos_* columns appropriately, whereas server_3's Gtid_Pos_Ack
--echo # column should not be updated.
--echo #

--let $old_binlog_gtid= `SELECT @@gtid_binlog_pos`
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
--let $new_binlog_gtid= `SELECT @@gtid_binlog_pos`
--source include/save_master_gtid.inc

--connection server_2
--source include/sync_with_master_gtid.inc

--echo # Waiting for Gtid_Pos_Sent to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$new_binlog_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--connection server_3
set debug_sync= "now WAIT_FOR at_slave_reply";

--connection server_1
--echo # Only server_2 should have ACKed the new GTID ACKed, server_3 should not due to stall
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT
SHOW SLAVE HOSTS;

--echo # Resume server_3
--connection server_3
set debug_sync= "now SIGNAL reply_ack_to_master";
--source include/sync_with_master_gtid.inc
SET debug_sync='RESET';

--source include/stop_slave.inc
set @@GLOBAL.debug_dbug= @save_s3_debug;
SET debug_sync='RESET';
--source include/start_slave.inc


--echo #
--echo # 21322.11: Configuration rpl_semi_sync_master_timeout of 0 should
--echo # have transaction behavior match asynchronous behavior (i.e. trxs don't
--echo # need to wait for ACKs), yet the slave should still send ACKs as a
--echo # normal semi-sync replica, and Gtid_Pos_Ack should still be updated
--echo # accordingly.
--echo #
--echo #  The actual behavior tested in this case is as follows:
--echo # a) Transactions won't await ACKs to complete
--echo # b) Semi-sync remains ON when a transaction completes without an ACK
--echo # c) Gtid_Pos_Ack is updated accordingly for each replica's ACK (even
--echo #    when it is behind). Here, we hold both replicas using DEBUG_SYNC to
--echo #    not send their ACKs, meanwhile, we continue creating transactions
--echo #    on the primary.
--echo # d) If a "very lagged" replica sends an ACK for a transaction from a
--echo #    purged binlog, the Gtid_Pos_Ack value should be nullified, and
--echo #    issue a warning to the user with the slave's last ACKed binlog
--echo #    coordinate (i.e. filename and position).
--echo #

--connection server_1
set global rpl_semi_sync_master_timeout=0;

--connection server_2
--source include/stop_slave.inc
SET @@GLOBAL.DEBUG_DBUG="+d,synchronize_semisync_slave_reply";
--source include/start_slave.inc
--connection server_3
--source include/stop_slave.inc
SET @@GLOBAL.DEBUG_DBUG="+d,synchronize_semisync_slave_reply";
--source include/start_slave.inc

--connection server_1
--echo # Waiting for master to recognize slave restarts..
let $status_var= Rpl_semi_sync_master_clients;
let $status_var_value= 2;
source include/wait_for_status_var.inc;

--echo #
--echo # 21322.11.a
connection server_1;
--let $yes_tx_orig= query_get_value(show status like 'Rpl_semi_sync_master_yes_tx', Value, 1)
--let $no_tx_orig= query_get_value(show status like 'Rpl_semi_sync_master_no_tx', Value, 1)
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
--let $trx1_gtid= `SELECT @@gtid_binlog_pos`

--echo # Waiting for Gtid_Pos_Sent to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$trx1_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--connection server_2
SET debug_sync='now WAIT_FOR at_slave_reply';
--connection server_3
SET debug_sync='now WAIT_FOR at_slave_reply';

--echo # Gtid_Pos_Ack should be NULL for both replicas (as they were restarted)..
--let $binlog_gtid= `SELECT @@gtid_binlog_pos`
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= = '';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--echo #
--echo # 21322.11.b
--connection server_1
--echo # Ensuring semi-sync status on primary is correct..
--let $yes_tx_post_commit= query_get_value(show status like 'Rpl_semi_sync_master_yes_tx', Value, 1)
if ($yes_tx_orig != $yes_tx_post_commit)
{
  --echo # yes_tx original: $yes_tx_orig
  --echo # yes_tx after commit: $yes_tx_post_commit
  --die Rpl_semi_sync_master_yes_tx should not have changed when Rpl_semi_sync_master_timeout is 0
}
--let $no_tx_post_commit= query_get_value(show status like 'Rpl_semi_sync_master_no_tx', Value, 1)
if ($no_tx_orig != $no_tx_post_commit)
{
  --echo # no_tx original: $no_tx_orig
  --echo # no_tx after commit: $no_tx_post_commit
  --die Rpl_semi_sync_master_no_tx should not have changed when Rpl_semi_sync_master_timeout is 0
}
--let $master_semisync_status= query_get_value(show status like 'Rpl_semi_sync_master_status', Value, 1)
if (`SELECT strcmp('$master_semisync_status','ON') != 0`)
{
  --die Master semi-sync status was disabled after transaction
}

--echo #
--echo # 21322.11.c
--connection server_1
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
--let $trx2_gtid= `SELECT @@gtid_binlog_pos`
--source include/save_master_gtid.inc

--echo # Waiting for Gtid_Pos_Sent to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$trx2_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--connection server_1
--echo # server_2 and 3 should both show a NULL ACK state
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT $trx1_gtid TRX1_GTID $trx2_gtid TRX2_GTID
SHOW SLAVE HOSTS;

--echo # Let server_2 ACK just the first transaction
--connection server_2
set debug_sync= "now SIGNAL reply_ack_to_master";
set debug_sync= "now WAIT_FOR at_slave_reply";

--connection server_1
--echo # Waiting for server_2 Gtid_Pos_Ack to reflect first transaction
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$trx1_gtid';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

--echo # Let server_2 ACK the second transaction
--connection server_2
set debug_sync= "now SIGNAL reply_ack_to_master";
--source include/sync_with_master_gtid.inc

--connection server_1
--echo # Waiting for server_2 Gtid_Pos_Ack to reflect second transaction
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$trx2_gtid';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

--echo # Let server_3 now ACK the first transaction
--connection server_3
set debug_sync= "now SIGNAL reply_ack_to_master";
set debug_sync= "now WAIT_FOR at_slave_reply";

--connection server_1
--echo # Waiting for server_3 Gtid_Pos_Ack to reflect first transaction
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$trx1_gtid';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

--echo # Let server_3 ACK the second transaction
--connection server_3
set debug_sync= "now SIGNAL reply_ack_to_master";
--source include/sync_with_master_gtid.inc

--connection server_1
--echo # Waiting for Gtid_Pos_Ack to reflect second transaction for both servers
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$trx2_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;


--echo #
--echo # 21322.11.d
--connection server_1
--let $trx2_binlog_file= query_get_value(SHOW BINARY LOGS, Log_name, 1)
--let $trx2_binlog_pos= query_get_value(SHOW BINARY LOGS, File_size, 1)
FLUSH LOGS;
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
--let $trx3_gtid= `SELECT @@gtid_binlog_pos`
--source include/save_master_gtid.inc

--echo # Waiting for Gtid_Pos_Sent to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '$trx3_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--connection server_2
set debug_sync= "now WAIT_FOR at_slave_reply";
--connection server_3
set debug_sync= "now WAIT_FOR at_slave_reply";

--connection server_1
--echo # server_2 and 3 should both show ACKed TRX2 (with TRX3 Sent)
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT $trx2_gtid TRX2_GTID $trx3_gtid TRX3_GTID
SHOW SLAVE HOSTS;

--let $purge_to_binlog= query_get_value(SHOW MASTER STATUS, File, 1)
--let $purge_binlogs_to=$purge_to_binlog
--source include/wait_for_purge.inc

--echo # Master should warn that the binary log which contains the last ACKed
--echo # binlog coordinates has been purged, and nullify Gtid_Pos_Ack
--enable_warnings
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT $trx2_gtid TRX2_GTID $trx3_gtid TRX3_GTID $trx2_binlog_file TRX2_BINLOG_FILE $trx2_binlog_pos TRX2_BINLOG_POS
SHOW SLAVE HOSTS;

--echo # Let servers ACK new transaction
--connection server_2
set debug_sync= "now SIGNAL reply_ack_to_master";
--connection server_3
set debug_sync= "now SIGNAL reply_ack_to_master";

--connection server_1
--echo # Waiting for Gtid_Pos_Ack to reflect latest transaction for all replicas..
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '$trx3_gtid';
let $wait_for_all= 1;
source include/wait_show_condition.inc;

--echo # Gtid_Pos_Ack should now show the latest transaction GTID
--replace_result $SLAVE_MYPORT SLAVE_PORT $SERVER_MYPORT_3 SLAVE2_PORT $DEFAULT_MASTER_PORT DEFAULT_PORT $trx2_gtid TRX2_GTID $trx3_gtid TRX3_GTID
SHOW SLAVE HOSTS;
--disable_warnings

--connection server_2
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
--disable_query_log
--eval SET @@GLOBAL.debug_dbug= "$save_server_2_dbug"
--enable_query_log
SET debug_sync='RESET';
--source include/start_slave.inc
--connection server_3
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
--disable_query_log
--eval SET @@GLOBAL.debug_dbug= "$save_server_3_dbug"
--enable_query_log
SET debug_sync='RESET';
--source include/start_slave.inc


--echo #
--echo # 21322.12: Gtid_Pos_Ack and Sent should be reflective of GTID position
--echo # rather than state. i.e. they should have the following properties:
--echo #   a) if the transaction stream within a domain contains multiple
--echo #      server ids, the columns should show only the last transaction in
--echo #      the stream (not last per server_id).
--echo #   b) if there are multiple domains in the binary log, the columns
--echo #      should show the latest transaction in each domain.
--echo #

--echo # We don't need two replicas for this test, so stop server_3's slave
--connection server_3
--source include/stop_slave.inc

--connection server_1
set @old_domain_id= @@global.gtid_domain_id;
set @old_server_id= @@global.server_id;

--echo #
--echo # 21322.12.a
set session gtid_domain_id= 0;
set session server_id= 1;
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
set session server_id= 111;
set session gtid_seq_no= 555;
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)

--let $expected_d0_gtid_pos= 0-111-555
--echo # Gtid_Pos_Sent should show only the transaction with the different server_id
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= = '$expected_d0_gtid_pos';
let $wait_for_all= 0;
source include/wait_show_condition.inc;

--echo # Gtid_Pos_Ack should show only the transaction with the different server_id
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= = '$expected_d0_gtid_pos';
let $wait_for_all= 0;
source include/wait_show_condition.inc;


--echo #
--echo # 21322.12.b
set session gtid_domain_id= 1;
set session server_id= 112;
set session gtid_seq_no= 1;
--let $expected_d1_gtid_pos= 1-112-1
--let $nextval= `SELECT max(a)+1 from t1`
--eval insert into t1 values ($nextval)
--source include/save_master_gtid.inc

--echo # Gtid_Pos_Sent should show transactions from both domains
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Sent;
let $condition= LIKE '%$expected_d0_gtid_pos%';
let $wait_for_all= 0;
source include/wait_show_condition.inc;
let $condition= LIKE '%$expected_d1_gtid_pos%';
source include/wait_show_condition.inc;

--echo # Gtid_Pos_Ack should show transactions from both domains
let $show_statement= SHOW SLAVE HOSTS;
let $field= Gtid_Pos_Ack;
let $condition= LIKE '%$expected_d0_gtid_pos%';
let $wait_for_all= 0;
source include/wait_show_condition.inc;
let $condition= LIKE '%$expected_d1_gtid_pos%';
source include/wait_show_condition.inc;

set session gtid_domain_id= @old_domain_id;
set session server_id= @old_server_id;

--connection server_2
--source include/sync_with_master_gtid.inc
--connection server_3
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # MDEV-21322 Cleanup
connection server_1;
set @@global.debug_dbug= @save_primary_dbug;
set @@global.rpl_semi_sync_master_timeout= @save_semisync_timeout;
set @@global.rpl_semi_sync_master_enabled= @save_semisync_master_enabled;

drop table t1;
--source include/save_master_gtid.inc
--save_master_pos

connection server_2;
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
set @@global.rpl_semi_sync_slave_enabled= @save_semisync_server_2_enabled;
--disable_query_log
--eval SET @@GLOBAL.debug_dbug= "$save_server_2_dbug"
--enable_query_log
SET debug_sync='RESET';
--source include/start_slave.inc

connection server_3;
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
set @@global.rpl_semi_sync_slave_enabled= @save_semisync_server_3_enabled;
--disable_query_log
--eval SET @@GLOBAL.debug_dbug= "$save_server_3_dbug"
--enable_query_log
SET debug_sync='RESET';
--source include/start_slave.inc

--echo #
--echo # End of MDEV-21322 tests
--echo #

--source include/rpl_end.inc
--echo # End of rpl_show_slave_hosts.test
