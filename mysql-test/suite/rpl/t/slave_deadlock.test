--source include/have_debug.inc
--source include/have_innodb.inc
--source include/have_binlog_format_statement.inc

# On --repeat test infinitely increments thread_id and finally fails --sync_with_master at log_pos 1754:
#
# 231009 20:58:15 server id 1  end_log_pos 1754 CRC32 0x7e5aecd1 	Query	thread_id=561	exec_time=0	error_code=0	xid=0
#
# force_restart seems to fix this

# --source include/force_restart.inc

# Note that test requires big enough --debug-sync-timeout unfair scheduling at high load.
# slave_deadlock.opt sets this to 1 hour

--let $rpl_topology=1->2
--source include/rpl_init.inc

--echo #
--echo # MDEV-30973 Enhance output of innodb deadlocks (SAMU-124, SAMU-131)
--echo #
--connection server_2
SET @old_dbug= @@global.debug_dbug;
set @old_parallel_threads= @@global.slave_parallel_threads;
set @old_domain_parallel_threads= @@global.slave_domain_parallel_threads;
set @old_parallel_mode= @@global.slave_parallel_mode;
set @old_slave_transaction_retries= @@global.slave_transaction_retries;
set @old_innodb_lock_wait_timeout= @@global.innodb_lock_wait_timeout;
set @old_slave_retry_log= @@global.slave_retry_log;
set @old_slave_retry_log_file= @@global.slave_retry_log_file;
set @old_slave_retry_log_max= @@global.slave_retry_log_max;
--source include/stop_slave.inc
change master to master_use_gtid= slave_pos;
set global slave_parallel_threads= 10;
set global slave_domain_parallel_threads= 1;
set global slave_parallel_mode= optimistic;
set global slave_transaction_retries= 4;
set global innodb_lock_wait_timeout= 1;

--error ER_WRONG_VALUE_FOR_VAR
set global slave_retry_log_file= "/tmp";
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
select @@slave_retry_log log, @@slave_retry_log_max max, @@slave_retry_log_file file;
set global slave_retry_log= 1;
set global slave_retry_log_max= 20;
set global slave_retry_log_file= "abcd";
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
select @@slave_retry_log log, @@slave_retry_log_max max, @@slave_retry_log_file file;
set global slave_retry_log= OFF;
set global slave_retry_log_file= "abcdef";
select @@slave_retry_log log, @@slave_retry_log_max max, @@slave_retry_log_file file;
set global slave_retry_log_file= default;
call mtr.add_suppression("Open of slave_retry_log");
set global slave_retry_log= ON;
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
select @@slave_retry_log log, @@slave_retry_log_max max, @@slave_retry_log_file file;
set global slave_retry_log= off;
let $logfile= `select @@slave_retry_log_file`;
set global slave_retry_log_file= @old_slave_retry_log_file;
--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR
select @@slave_retry_log log, @@slave_retry_log_max max, @@slave_retry_log_file file;

--disable_query_log
if ($MTR_COMBINATION_SLAVE_RETRY_LOG)
{
  set global slave_retry_log= ON;
  let grep_file= `SELECT @@GLOBAL.slave_retry_log_file`;
}
if ($MTR_COMBINATION_ERROR_LOG)
{
  set global slave_retry_log= ERROR_LOG;
  let grep_file= `SELECT @@GLOBAL.log_error`;
}
--enable_query_log

--source include/start_slave.inc
set global innodb_print_all_deadlocks= on;

--connection server_1

--delimiter ~~
create function foo(x int, d1 varchar(500), d2 varchar(500))
returns int deterministic
begin
  return x;
end
~~
--delimiter ;

create table t1 (a int unique) engine innodb;
create table t2 (x int) engine innodb;

--save_master_pos
--connection server_2
--sync_with_master
insert into t1 values (1);

--delimiter ~~
create or replace function foo(x int, d1 varchar(500), d2 varchar(500))
returns int deterministic
begin
  if d1 != '' then
    set debug_sync= d1;
  end if;
  if d2 != '' then
    set debug_sync= d2;
  end if;
  return x;
end
~~
--delimiter ;

--connect (m1,localhost,root,,test)
--connect (m2,localhost,root,,test)

--connection m1
set @@session.gtid_domain_id= 1;
insert into t2 values (foo(1,
  'after_lock_clust_rec_read_check_and_lock wait_for clust_locked', ''));
delete from t1;
--connection m2
set @@session.gtid_domain_id= 2;
insert into t2 values (foo(2,
  'after_lock_clust_rec_read_check_and_lock signal clust_locked', ''));
delete from t1 where a = 1;

--save_master_pos
--connection server_2
--sync_with_master

let $s= `show engine innodb status`;
# Somehow `select instr("$s"...) my fail with
#   mysqltest: At line 132: Empty variable
# New bug in mysqltest?
if ($s)
{
  let $i= `select instr("$s", "LATEST DETECTED DEADLOCK")`;
}
if (!$s)
{
  let $exit= 1;
}
if ($i == 0)
{
  let $exit= 1;
}
if ($exit)
{
  # Deadlock didn't happen, exiting...
  # Both INSERTs continue from after_lock_clust_rec_read_check_and_lock,
  # there is racing which one goes first.
  --source include/stop_slave.inc
  set global slave_parallel_threads= @old_parallel_threads;
  set global slave_domain_parallel_threads= @old_domain_parallel_threads;
  set global slave_parallel_mode= @old_parallel_mode;
  set global slave_transaction_retries= @old_slave_transaction_retries;
  set global innodb_lock_wait_timeout= @old_innodb_lock_wait_timeout;
  set global slave_retry_log= @old_slave_retry_log;
  set global slave_retry_log_max= @old_slave_retry_log_max;
  --source include/start_slave.inc
  set global innodb_print_all_deadlocks= default;
  set debug_sync= reset;
  --disconnect m1
  --disconnect m2
  --connection server_1
  drop tables t1, t2;
  drop function foo;
  set global innodb_print_all_deadlocks= default;
  --source include/rpl_end.inc
  --skip "Deadlock didn't happen"
}
set debug_sync="ha_commit_one_phase wait_for retries_at_max";
set global debug_dbug= "d,rpl_parallel_retries_at_max";
--send select * from t2 for update

--connection server_1
update t2 set x= 6;

--save_master_pos
--connection server_2
--sync_with_master
--disable_result_log
reap;
--enable_result_log
set global debug_dbug= @old_dbug;
flush error logs;

let grep_regex= WAITING|Updating;
let grep_once= \[SUCCESS\];
--replace_regex /\d+/x/ /  / / /\[Note\] //
--source include/grep.inc

# Cleanup
--source include/stop_slave.inc
set global slave_parallel_threads= @old_parallel_threads;
set global slave_domain_parallel_threads= @old_domain_parallel_threads;
set global slave_parallel_mode= @old_parallel_mode;
set global slave_transaction_retries= @old_slave_transaction_retries;
set global innodb_lock_wait_timeout= @old_innodb_lock_wait_timeout;
set global slave_retry_log= @old_slave_retry_log;
set global slave_retry_log_file= @old_slave_retry_log_file;
set global slave_retry_log_max= @old_slave_retry_log_max;
--source include/start_slave.inc
set global innodb_print_all_deadlocks= default;
set debug_sync= reset;

--disconnect m1
--disconnect m2

--connection server_1
drop tables t1, t2;
drop function foo;

call mtr.add_suppression("Deadlock found when trying to get lock; try restarting transaction");
call mtr.add_suppression("Sort aborted.*");
set global innodb_print_all_deadlocks= default;

--source include/rpl_end.inc
