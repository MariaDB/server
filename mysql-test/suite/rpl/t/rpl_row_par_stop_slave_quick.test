#
# Validate that STOP SLAVE works in a timely manner on a parallel replica with
# ROW binary logging format.
#
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/master-slave.inc
--source include/have_innodb.inc
--source include/have_binlog_format_row.inc

--echo #
--echo # Setup
--connection slave
--source include/stop_slave.inc
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression("Can't find record");
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression("Commit failed due to failure");
--let $old_debug= `SELECT @@global.debug_dbug`
--let $old_threads= `SELECT @@global.slave_parallel_threads`
ALTER TABLE mysql.gtid_slave_pos ENGINE=InnoDB;
--connect(slave_lock_extra,127.0.0.1,root,,test,$SLAVE_MYPORT)
CHANGE MASTER TO MASTER_USE_GTID=SLAVE_POS;
--source include/start_slave.inc

--echo #
--echo # Initialize test data
--connection master
SET STATEMENT sql_log_bin=0 FOR call mtr.add_suppression('Unsafe statement written to the binary log using statement format since BINLOG_FORMAT = STATEMENT.');

# Needed by this test and include/rpl_par_stop_slave_quick.inc

create sequence s1;
create table ti (a int) engine=innodb;
create table ti2 (a int) engine=innodb;
create table ti3 (a int) engine=innodb;
create table tm (a int) engine=myisam;
create table tm2 (a int) engine=myisam;
--let $ti_ctr= 100
--let $tm_ctr= 200
--let $tm2_ctr= 300
--let $ti2_ctr= 400
--let $ti3_ctr= 500
--sync_slave_with_master

--echo # Run binlog format independent test cases
--source include/rpl_par_stop_slave_quick_common.test

--echo #
--echo # ROW Test Case 1:
--echo # Using an N multi-statement transaction, ensure if STOP SLAVE is
--echo # issued in-between row updates, that the transaction is finished.

--connection master
truncate table ti;
truncate table tm;
--echo # Set up multiple rows to allow a multi-statement update rows event
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--eval insert into tm values ($tm_ctr)
--inc $tm_ctr
--sync_slave_with_master

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm) t`

--connection master

--echo # Next-to-commit non-transactional transaction should finish
--eval update tm set a=a+1
--source include/save_master_gtid.inc
--let $master_gtid_after_update= `select @@global.gtid_binlog_pos`

--echo # This should not be committed because it is after next-to-commit
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
set @@global.debug_dbug="+d,pause_after_next_row_exec";

START SLAVE;
set debug_sync= "now WAIT_FOR row_executed";

--connection slave1
--send STOP SLAVE;

--connection slave
set @@global.debug_dbug="";
set debug_sync= "now SIGNAL continue_row_execution";

--connection slave1
--reap
--source include/wait_for_slave_sql_to_stop.inc

--echo # Slave should be error-free
let $last_error = query_get_value("SHOW SLAVE STATUS", Last_SQL_Errno, 1);
--let $assert_text= Slave should be error free
--let $assert_cond= $last_error = 0
--source include/assert.inc

set debug_sync= "RESET";
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # ROW Test Case 2:
--echo # Using a T multi-statement transaction, ensure if STOP SLAVE is
--echo # issued in-between row updates, that the transaction is rolled back.

--connection master
truncate table ti;
truncate table ti2;
truncate table tm;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr
--sync_slave_with_master

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_threads=1;
--let $row_count_initial=`select count(*) from (select * from ti UNION ALL select * from tm) t`

--connection master

--echo # Next-to-commit transactional multi-row event should be rolled back
--source include/save_master_gtid.inc
--let $master_gtid_initial= `select @@global.gtid_binlog_pos`
--eval update ti set a=a+1

--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

--connection slave
set @@global.debug_dbug="+d,pause_after_next_row_exec";
START SLAVE;
set debug_sync= "now WAIT_FOR row_executed";

--connection slave1
--send STOP SLAVE;

--connection slave
set @@global.debug_dbug="";
set debug_sync= "now SIGNAL continue_row_execution";

--connection slave1
--reap
--source include/wait_for_slave_sql_to_stop.inc

--let $row_count_end=`select count(*) from (select * from ti UNION ALL select * from tm) t`
--let $row_count_diff=`select ($row_count_end-$row_count_initial)`
--let $assert_text= No new rows should have been inserted
--let $assert_cond= $row_count_diff = 0
--source include/assert.inc

--let $slave_gtid= `select @@global.gtid_slave_pos`
--echo # Comparing master gtid $master_pos to slaves $slave_gtid
--let $assert_text= No transactions should have committed
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

--echo # Slave should be error-free
let $last_error = query_get_value("SHOW SLAVE STATUS", Last_SQL_Errno, 1);
--let $assert_text= Slave should be error free
--let $assert_cond= $last_error = 0
--source include/assert.inc

--connection master
--source include/save_master_gtid.inc

--connection slave
set debug_sync= "RESET";
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Row Test Case 3:
--echo # A workload with a later transaction that updates a sequence table
--echo # should complete all transactions up to the sequence table update.
--echo # Workload:
--echo #    T (long running); should commit
--echo #    S (waiting for prior commit); should commit
--echo #    T (long running); should rollback

--connection slave
--source include/stop_slave.inc
set @@global.slave_parallel_mode=AGGRESSIVE;
set @@global.slave_parallel_threads=3;

--connection master
SET @old_dbug= @@SESSION.debug_dbug;
SET @@SESSION.debug_dbug="+d,binlog_force_commit_id";
SET @commit_id= 10002;
--eval insert into ti values ($ti_ctr)
--inc $ti_ctr

select next value for s1;
--source include/save_master_gtid.inc

--eval insert into ti2 values ($ti2_ctr)
--inc $ti2_ctr

SET @@SESSION.debug_dbug=@old_dbug;

--connection slave
LOCK TABLES ti write, ti2 WRITE;
--source include/start_slave.inc

--echo # Wait for replica to progress until the transactions targeting locked tables are stuck on their locks..
--let $wait_condition= SELECT count(*)=2 FROM information_schema.processlist WHERE state LIKE 'Waiting for table metadata lock' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--echo # Wait for replica to progress until unblocked transactions are queued for group commit..
--connection slave
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for prior transaction to commit' and  command LIKE 'Slave_worker';
--source include/wait_condition.inc

--connection slave1
--send STOP SLAVE;

--connection slave
--echo # Wait for replica to signal worker threads to stop
--let $wait_condition= SELECT count(*)=1 FROM information_schema.processlist WHERE state LIKE 'Waiting for worker thread to stop';
--source include/wait_condition.inc

UNLOCK TABLES;
--source include/wait_for_slave_sql_to_stop.inc

--connection slave1
--reap
--connection slave

--let $slave_gtid= `select @@global.gtid_slave_pos`
--let $assert_text= GTID slave state should not change
--let $assert_cond= $master_pos = $slave_gtid
--source include/assert.inc

set @@global.slave_parallel_mode=CONSERVATIVE;

--connection master
--source include/save_master_gtid.inc
--connection slave
--source include/start_slave.inc
--source include/sync_with_master_gtid.inc


--echo #
--echo # Cleanup
--connection master
DROP TABLE ti, ti2, ti3, tm, tm2, s1;
--source include/save_master_gtid.inc

--connection slave
--source include/sync_with_master_gtid.inc
--source include/stop_slave.inc
--eval set @@global.debug_dbug="$old_debug"
--eval set @@global.slave_parallel_threads=$old_threads
--source include/start_slave.inc

--source include/rpl_end.inc

--echo # End of tests
