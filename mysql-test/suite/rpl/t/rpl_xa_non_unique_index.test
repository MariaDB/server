# The test proves that
#
# A. an XA-prepared transaction releases locks on unmodified index records;
# B. the following transaction is able to find its target records
#    even though locked records by the 1st XA transaction is in the way
#    of scanning of the non-unique index.
#
# References a timeout part of MDEV-32020, incl
#    MDEV-NNMM
#    MDEV-34466 XA prepare don't release unmodified records for some cases
#
--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_binlog_format_row.inc
--source include/master-slave.inc

# The test consists of three parts
# 1. Prepare load such that two transactions trx_1, trx_2 are clearly isolated
#    from each other on master thanks to forcing index.
# 2. Slave serial mode check ensures that the 1st prepared XA releases
#    "avariciously" acquired locks (the propertry A), as well as
#    the 2nd transaction is able to step over locked records (the B) to
#    successfully scan out its target one, instead of ending up with
#    the timeout error.
# 3. Slave parallel mode check aims at
#    the same as p.2 complicated by trx_2 having locked its target record
#    before trx_1 has started.

--connection master
--echo *** 1. Prepare load ***
CREATE TABLE t1 (a int, b int, c int,
  INDEX i1(a),
  INDEX i2(b))
  ENGINE=InnoDB;
--source include/save_master_gtid.inc
--let $gtid_binlog_pos_0=$gtid_binlog_pos

INSERT INTO t1 VALUES
  (1,1,0), (1,2,0), (1,3,0), (1,4,0),
  (2,1,0), (2,2,0);
--sync_slave_with_master

--source include/stop_slave.inc
SET @old_timeout= @@GLOBAL.innodb_lock_wait_timeout;
SET @old_retries= @@GLOBAL.slave_transaction_retries;
SET GLOBAL innodb_lock_wait_timeout= 2;
SET GLOBAL slave_transaction_retries= 3;
--source include/start_slave.inc

--connection master
SET @@gtid_seq_no=100;
XA START "trx_1";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND (b=1 OR b=2);
XA END "trx_1";
XA PREPARE "trx_1";

--connection master1
XA START "trx_2";
UPDATE t1 FORCE INDEX (i2) SET c=c+1 WHERE a=1 AND b=3;
XA END "trx_2";
XA PREPARE "trx_2";

--connection master
XA COMMIT "trx_1";

--connection master1
XA COMMIT "trx_2";
--source include/save_master_gtid.inc

--connection master
SELECT * FROM t1 ORDER BY a,b,c;

--echo *** 2. Serial mode check ***
--sync_slave_with_master
SELECT * FROM t1 ORDER BY a,b,c;

--echo *** 3. Parallel mode check ***
# Rerun the DML part with slave worker threads
--connection slave
--source include/stop_slave.inc
delete from t1;
reset master;
--evalp set @@global.gtid_slave_pos='$gtid_binlog_pos_0'

set @old_slave_parallel_threads=@@global.slave_parallel_threads;
set @old_slave_parallel_mode=@@global.slave_parallel_mode;
set @@global.slave_parallel_threads=2;
set @@global.slave_parallel_mode=optimistic;
CHANGE MASTER TO master_use_gtid=slave_pos;
SET @@global.debug_dbug="+d,hold_worker_on_schedule";
--source include/start_slave.inc

--let $wait_condition= SELECT count(*) = 1 FROM information_schema.processlist WHERE state LIKE "Waiting for prior transaction to commit"
--source include/wait_condition.inc
SET DEBUG_SYNC = 'now SIGNAL continue_worker';

--source include/sync_with_master_gtid.inc
SELECT * FROM t1 ORDER BY a,b,c;

# Cleanup
--connection master
DROP TABLE t1;

--connection slave
SET GLOBAL innodb_lock_wait_timeout= @old_timeout;
SET GLOBAL slave_transaction_retries= @old_retries;
--source include/stop_slave.inc
SET debug_sync = RESET;
SET @@global.debug_dbug = "";
set @@global.slave_parallel_threads= @old_slave_parallel_threads;
set @@global.slave_parallel_mode= @old_slave_parallel_mode;
--source include/start_slave.inc

--source include/rpl_end.inc
