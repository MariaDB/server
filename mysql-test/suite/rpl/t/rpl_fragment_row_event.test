#
#   This file tests that row events which are larger than a server's configured
# slave_max_allowed_packet will be fragmented into Partial_rows_log_event, that
# the slave re-assembles to execute the event.
#
#   The following use cases are tested when replaying transactions via
# traditional replication, as well as mysqlbinlog when applicable.
#
#   Test cases done:
#   1: Boundary testing of event size vs slave_max_allowed_packet
#     a) If full rows_log_event (ev metadta incl) <= slave_max_allowed_packet,
#        no fragmentation
#     b) If rows_data size is less than slave_max_allowed_packet, but adding
#        the metadata of the Rows_event would result in surpassing
#        slave_max_allowed_packet (by one byte), fragmentation should occur
#   2: Any Rows event type that surpasses slave_max_allowed_packet should be
#     fragmented:
#     a) Write_rows
#     b) Update_rows
#     c) Delete_rows
#     d) Write_rows_compressed
#     e) Update_rows_compressed
#     f) Delete_rows_compressed
#   3: SHOW BINLOG EVENTS should show Partial_rows_log_event fragment
#      sequencing
#   4: The parallel replication applier can re-assemble Rows_log_events and
#      apply them
#   5: A transaction with multiple Rows_log_events can be replicated
#   6: Using chain-replication, servers configured with different
#      slave_max_allowed_packet should binlog according to the configured
#      policy of that specific server
#   7: Replication filters will filter the re-constructed Rows_log_event,
#      when filtering either the target database or table.
#
#
#   Note this test users MTR variables to save old variables rather than user
# variables because slave_max_allowed_packet is reset dynamically, and
# connections are disconnected and reconnected to reset the value, as
# FLUSH STATUS doesn't reset this value.
#
#
# References:
#   MDEV-28768: mysqlbinlog can produce events larger than max_allowed_packet
#   MDEV-32570: Fragment ROW replication events larger than max_packet_size
#

--source include/have_sequence.inc
--source include/have_innodb.inc
--source include/have_binlog_format_row.inc
--let $rpl_topology=1->2, 2->3
--source include/rpl_init.inc


--echo #
--echo #
--echo # Test setup
--connection server_1
--let $server_1_old_slave_max_packet= `SELECT @@global.slave_max_allowed_packet`
--let $server_1_old_net_buf= `SELECT @@global.net_buffer_length`
set @@global.slave_max_allowed_packet= 1024;
set @@global.net_buffer_length= 1024;
--disconnect server_1
--source include/wait_until_disconnected.inc
--connect (server_1,127.0.0.1,root,,test,$SERVER_MYPORT_1,)

--connection server_2
--source include/stop_slave.inc
--let $server_2_old_slave_max_packet= `SELECT @@global.slave_max_allowed_packet`
--let $server_2_old_net_buf= `SELECT @@global.net_buffer_length`
set @@global.slave_max_allowed_packet= 1024;
set @@global.net_buffer_length= 1024;
--disconnect server_2
--source include/wait_until_disconnected.inc
--connect (server_2,127.0.0.1,root,,test,$SERVER_MYPORT_2,)
--source include/start_slave.inc

--connection server_3
--source include/stop_slave.inc
--let $server_3_old_slave_max_packet= `SELECT @@global.slave_max_allowed_packet`
--let $server_3_old_net_buf= `SELECT @@global.net_buffer_length`
set @@global.slave_max_allowed_packet= 1024;
set @@global.net_buffer_length= 1024;
--disconnect server_3
--source include/wait_until_disconnected.inc
--connect (server_3,127.0.0.1,root,,test,$SERVER_MYPORT_3,)
--source include/start_slave.inc


--echo #
--echo #
--echo # Test case 1) Boundary Testing
--let $log_ev_header_len= 19
--let $rows_header_len= 8
--let $binlog_checksum_len= 4
--let $ev_metadata_size=  `SELECT ($log_ev_header_len + $rows_header_len + $binlog_checksum_len)`
--let $max_unfragged_ev= `SELECT (1024 - $ev_metadata_size)`

--echo #
--echo # A rows event at its maximum unfragmented length (i.e. the length of
--echo # slave_max_allowed_packet minus the Rows_log event metadata (e.g.
--echo # headers)) should not fragment, and replication replay should work both
--echo # via traditional replication as well as mysqlbinlog.
--let $test_mysqlbinlog_replay= 1
--let $test_update=0
--let $test_delete=0
--let $insert_size=$max_unfragged_ev
--source rpl_fragment_row_event.inc

--echo #
--echo # If rows event surpasses its maximum unfragmented length by 1, it
--echo # should fragment into 2 pieces, and replication replay should work
--echo # both via traditional replication as well as mysqlbinlog.

--let $insert_size= `SELECT ($max_unfragged_ev + 1)`
--source rpl_fragment_row_event.inc

# Clear insert_size for future transactions to use default insertion logic
--let $insert_size=
--let $test_update=1
--let $test_delete=1


--echo #
--echo #
--echo # Test cases 2a-2c) Regular row events that surpass
--echo # slave_max_allowed_packet should be fragmented

--let $test_mysqlbinlog_replay= 1
--source rpl_fragment_row_event.inc


--echo #
--echo #
--echo # Test cases 2d-2f) Compressed row events that surpass
--echo # slave_max_allowed_packet should be fragmented
--connection server_1
--let $old_s1_compress= `SELECT @@global.log_bin_compress`
set @@global.log_bin_compress= 1;
--connection server_2
--let $old_s2_compress= `SELECT @@global.log_bin_compress`
set @@global.log_bin_compress= 1;
--connection server_3
--let $old_s3_compress= `SELECT @@global.log_bin_compress`
set @@global.log_bin_compress= 1;

--source rpl_fragment_row_event.inc
--let $test_mysqlbinlog_replay=

--connection server_1
--eval set @@global.log_bin_compress= $old_s1_compress
--connection server_2
--eval set @@global.log_bin_compress= $old_s2_compress
--connection server_3
--eval set @@global.log_bin_compress= $old_s3_compress


--echo #
--echo #
--echo # Test case 3) SHOW BINLOG EVENTS should show Partial_rows_log_event
--echo # fragment sequencing

--let $test_show_binlog_events= 1
--source rpl_fragment_row_event.inc
--let $test_show_binlog_events=


--echo #
--echo #
--echo # Test case 4) The parallel replication applier can re-assemble
--echo # Rows_log_events and apply them
--connection server_2
--source include/stop_slave.inc
--let $old_s2_threads= `SELECT @@global.slave_parallel_threads`
set @@global.slave_parallel_threads= 4;
--source include/start_slave.inc
--connection server_3
--source include/stop_slave.inc
--let $old_s3_threads= `SELECT @@global.slave_parallel_threads`
set @@global.slave_parallel_threads= 4;
--source include/start_slave.inc

--let $test_mysqlbinlog_replay= 1
--source rpl_fragment_row_event.inc

--connection server_2
--source include/stop_slave.inc
--eval set @@global.slave_parallel_threads= $old_s2_threads;
--source include/start_slave.inc
--connection server_3
--source include/stop_slave.inc
--eval set @@global.slave_parallel_threads= $old_s3_threads;
--source include/start_slave.inc


--echo #
--echo #
--echo # Test Case 5) A transaction with multiple Rows_log_events can be
--echo # replicated

--let $test_mysqlbinlog_replay= 1
--let $test_multi_table_trx= 1
--let $test_show_binlog_events= 1
--let $test_update= 0
--let $test_delete= 0
--source rpl_fragment_row_event.inc
--let $test_mysqlbinlog_replay=
--let $test_multi_table_trx=
--let $test_show_binlog_events=
--let $test_update= 1
--let $test_delete= 1


--echo #
--echo #
--echo # Test case 6) Chain replication with different slave_max_allowed_packet
--echo # configurations

--let $server_2_max_packet=16384
--let $server_3_max_packet=16384
--let $test_mysqlbinlog_replay= 0
--source rpl_fragment_row_event.inc
--let $server_2_max_packet=
--let $server_3_max_packet=

--echo #
--echo #
--echo # Test Case 7) Replication filters should be honored when executing a re-assembled Rows_log_event

--connection server_2
--source include/start_slave.inc
--connection server_3
--source include/start_slave.inc

--connection server_1
create table t1 (a int, b longblob) engine=innodb;
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc

--connection server_2
--source include/stop_slave.inc
set @@global.replicate_ignore_db="test";
--source include/start_slave.inc

--connection server_1
--disable_query_log
--eval insert into t1 values (1, repeat("a", 1024))
--enable_query_log
  --let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)
--source include/show_binlog_events.inc
--source include/save_master_gtid.inc

--connection server_2
--source include/sync_with_master_gtid.inc
--echo # Ensuring insert was ignored by replicate_ignore_db rule..
if (`SELECT count(*) FROM test.t1`)
{
  --echo # Insert should have been ignored by replicate_ignore_db
  --die Insert should have been ignored by replicate_ignore_db
}
--echo # ..done

--connection server_2
--source include/stop_slave.inc
set @@global.replicate_ignore_db="";
set @@global.replicate_ignore_table="test.t1";
--source include/start_slave.inc

--connection server_1
--disable_query_log
--eval insert into t1 values (1, repeat("b", 1024))
  --let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)
--source include/show_binlog_events.inc
--enable_query_log
--source include/save_master_gtid.inc

--connection server_2
--source include/sync_with_master_gtid.inc
--echo # Ensuring insert was ignored by replicate_ignore_table rule..
if (`SELECT count(*) FROM test.t1`)
{
  --echo # Insert should have been ignored by replicate_ignore_table
  --die Insert should have been ignored by replicate_ignore_table
}
--echo # ..done

--connection server_2
--source include/stop_slave.inc
set @@global.replicate_ignore_table="";
--source include/start_slave.inc

--connection server_1
drop table t1;
FLUSH LOGS;
--source include/save_master_gtid.inc
--connection server_2
--source include/sync_with_master_gtid.inc
--source include/save_master_gtid.inc
--connection server_3
--source include/sync_with_master_gtid.inc


--echo #
--echo #
--echo # Cleanup
--connection server_1
--eval set @@global.slave_max_allowed_packet= $server_1_old_slave_max_packet
--eval set @@global.net_buffer_length= $server_1_old_net_buf
--disconnect server_1
--source include/wait_until_disconnected.inc
--connect (server_1,127.0.0.1,root,,test,$SERVER_MYPORT_1,)

--connection server_2
--source include/stop_slave.inc
--eval set @@global.slave_max_allowed_packet= $server_2_old_slave_max_packet
--eval set @@global.net_buffer_length= $server_2_old_net_buf
--source include/start_slave.inc
--disconnect server_2
--source include/wait_until_disconnected.inc
--connect (server_2,127.0.0.1,root,,test,$SERVER_MYPORT_2,)

--connection server_3
--source include/stop_slave.inc
--eval set @@global.slave_max_allowed_packet= $server_3_old_slave_max_packet
--eval set @@global.net_buffer_length= $server_3_old_net_buf
--source include/start_slave.inc
--disconnect server_3
--source include/wait_until_disconnected.inc
--connect (server_3,127.0.0.1,root,,test,$SERVER_MYPORT_3,)

--source include/rpl_end.inc
--echo # End of rpl_fragment_row_event.test
