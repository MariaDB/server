CREATE TABLE t(a INT PRIMARY KEY, b INT, c INT, UNIQUE KEY `b_c` (`b`,`c`))
ENGINE=InnoDB, STATS_PERSISTENT=0;
INSERT INTO t(a) VALUES (1);
connect con1,localhost,root;
connection con1;
BEGIN;
INSERT INTO t SET a=2;
connection default;
BEGIN;
SET DEBUG_SYNC="lock_wait_start SIGNAL select_locked";
SELECT * FROM t FORCE INDEX(b) FOR UPDATE;
connection con1;
SET DEBUG_SYNC="now WAIT_FOR select_locked";
ROLLBACK;
connection default;
# If the bug is not fixed, and the both unique index key fields are
# NULL, there will be two (1, NULL, NULL) rows in the result,
# because cursor will be restored to (NULL, NULL, 1) position for
# secondary key instead of "supremum".
a	b	c
1	NULL	NULL
COMMIT;
connection con1;
BEGIN;
INSERT INTO t SET a=2, c=2;
connection default;
BEGIN;
SET DEBUG_SYNC="lock_wait_start SIGNAL select_locked";
SELECT * FROM t FORCE INDEX(b) FOR UPDATE;
connection con1;
SET DEBUG_SYNC="now WAIT_FOR select_locked";
ROLLBACK;
connection default;
a	b	c
1	NULL	NULL
COMMIT;
SET DEBUG_SYNC="RESET";
disconnect con1;
DROP TABLE t;
