#
# Test fetching from stats tables that are corrupted
#

-- source include/have_innodb.inc
# Various sizes printed in this test depend on the page size and the
# functionality tested here is not related to the page size, so we only
# test with 16k page size.
-- source include/have_innodb_16k.inc
# server restart
-- source include/not_embedded.inc

call mtr.add_suppression("InnoDB: Table `mysql`.`innodb_index_stats` not found");
call mtr.add_suppression("InnoDB: Fetch of persistent statistics requested for table.*");

-- vertical_results

CREATE TABLE test_ps_fetch_corrupted
(a INT, PRIMARY KEY (a))
ENGINE=INNODB STATS_PERSISTENT=1;

# write stats to mysql.innodb_table_stats
ANALYZE TABLE test_ps_fetch_corrupted;

# check that indeed stats were written by ANALYZE above
SELECT n_rows, clustered_index_size, sum_of_other_index_sizes
FROM mysql.innodb_table_stats WHERE table_name = 'test_ps_fetch_corrupted';

# corrupt the persistent storage
ALTER TABLE mysql.innodb_index_stats RENAME TO mysql.innodb_index_stats_;

# reopen the table, this will attept to read from the persistent storage
FLUSH TABLE test_ps_fetch_corrupted;

# check the stats (should have been generated using the old transient stats
# method)
SELECT seq_in_index, column_name, cardinality
FROM information_schema.statistics WHERE table_name = 'test_ps_fetch_corrupted'
ORDER BY index_name, seq_in_index;

SELECT table_rows, avg_row_length, max_data_length, index_length
FROM information_schema.tables WHERE table_name = 'test_ps_fetch_corrupted';

# restore the persistent storage
ALTER TABLE mysql.innodb_index_stats_ RENAME TO mysql.innodb_index_stats;

DROP TABLE test_ps_fetch_corrupted;

# force server restart to clean up log from above error
--source include/restart_mysqld.inc
