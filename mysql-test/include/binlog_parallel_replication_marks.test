# Test the markings on GTID events (ddl, waited, trans,
# @@skip_parallel_replication) that are used to control parallel
# replication on the slave.

--source include/have_innodb.inc

RESET MASTER;
--source include/wait_for_binlog_checkpoint.inc

CREATE TABLE t1 (a INT PRIMARY KEY, b INT) ENGINE=InnoDB;
--let $binlog_pos1=query_get_value(SHOW MASTER STATUS, Position, 1)
/* GTID */ INSERT INTO t1 VALUES (1,0);
/* GTID */ BEGIN;
/* GTID */ INSERT INTO t1 VALUES (2,0);
/* GTID */ ALTER TABLE t1 ADD c INT;
/* GTID */ INSERT INTO t1 VALUES (3,0,0);
/* GTID */ COMMIT;
/* GTID */ BEGIN;
/* GTID */ UPDATE t1 SET b=1, c=1 WHERE a=2;
/* GTID */ CREATE TEMPORARY TABLE t2 (a INT PRIMARY KEY, b INT) ENGINE=InnoDB;
/* GTID */ INSERT INTO t2 VALUES (4,10), (5,20);
/* GTID */ INSERT INTO t1 SELECT a, 2, b FROM t2;
/* GTID */ DROP TEMPORARY TABLE t2;
/* GTID */ INSERT INTO t1 VALUES (6, 3, 0);
/* GTID */ COMMIT;
/* GTID */ CREATE TEMPORARY TABLE t3 (a INT PRIMARY KEY) ENGINE=InnoDB;
/* GTID */ BEGIN;
/* GTID */ DELETE FROM t1 WHERE a=5;
/* GTID */ INSERT INTO t3 VALUES (7);
/* GTID */ INSERT INTO t1 SELECT a, 4, 0 FROM t3;
/* GTID */ UPDATE t1 SET c=1 WHERE a=7;
/* GTID */ DROP TEMPORARY TABLE t3;
/* GTID */ COMMIT;
/* GTID */ CREATE TEMPORARY TABLE t4 (a INT PRIMARY KEY) ENGINE=InnoDB;
/* GTID */ BEGIN;
/* GTID */ INSERT INTO t1 VALUES (8, 5, 0);
/* GTID */ ALTER TABLE t4 ADD b INT;
/* GTID */ INSERT INTO t1 VALUES (9, 5, 1);
/* GTID */ COMMIT;
connect (tmp_con,localhost,root,,);
/* GTID */ INSERT INTO t1 VALUES (10, 6, 0);
/* GTID */ BEGIN;
/* GTID */ CREATE TEMPORARY TABLE t5 (a INT PRIMARY KEY) ENGINE=InnoDB;
/* GTID */ INSERT INTO t1 VALUES (11, 7, 0);
/* GTID */ COMMIT;
--let $before_drop_pos=query_get_value(SHOW MASTER STATUS, Position, 1)
disconnect tmp_con;
connection default;

# We need to wait for the implicit DROP TEMPORARY TABLE to be logged after
# tmp_con disconnect, otherwise we get sporadic test failures.
# MDEV-20091: DROP TEMPORARY TABLE IF EXISTS statements will be written to
# binlog only if the corresponding temporary table exists. In row based
# replication temporary tables are not replicated hence their corresponding
# DROP TEMPORARY TABLE statement will be not be written to binary log upon
# session closure.

if (!`SELECT @@BINLOG_FORMAT = 'ROW'`) {
--let $wait_condition= SELECT variable_value > $before_drop_pos FROM information_schema.global_status WHERE variable_name = 'binlog_snapshot_position'
--source include/wait_condition.inc
}
--let $binlog_pos2=query_get_value(SHOW MASTER STATUS, Position, 1)

--let $binlog_file= query_get_value(SHOW MASTER STATUS, File, 1)
FLUSH LOGS;

--let $MYSQLD_DATADIR= `select @@datadir`
--let $file= $MYSQLTEST_VARDIR/tmp/binlog_parallel_replication_marks.out
--let OUTPUT_FILE=$file
exec $MYSQL_BINLOG --start_position=$binlog_pos1 --stop_position=$binlog_pos2 $MYSQLD_DATADIR/$binlog_file > $file;

perl;
my $file= $ENV{'OUTPUT_FILE'};
open F, "<", $file
  or die "Unable to open file '$file': $!\n";
while (<F>) {
  s/^#\d+ +\d+:\d+:\d+ /# /;
  s/GTID \d+-\d+-\d+/GTID #-#-#/;
  s/end_log_pos \d+/end_log_pos #/;
  s/table id \d+/table id #/;
  s/mapped to number \d+/mapped to number #/;
  s/CRC32 0x[0-9a-f]+/CRC32 0x########/;
  print if /\b(GTID|BEGIN|COMMIT|Table_map|Write_rows|Update_rows|Delete_rows|generated by server|40005 TEMPORARY)\b/;
}
close F;
EOF

DROP TABLE t1;
