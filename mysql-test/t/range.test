#
# Problem with range optimizer
#
--source include/have_innodb.inc
SET optimizer_use_condition_selectivity=1;

--disable_warnings
drop table if exists t1, t2, t3, t10, t100;
--enable_warnings

CREATE TABLE t1 (
  event_date date DEFAULT '0000-00-00' NOT NULL,
  type int(11) DEFAULT '0' NOT NULL,
  event_id int(11) DEFAULT '0' NOT NULL,
  PRIMARY KEY (event_date,type,event_id)
);

INSERT INTO t1 VALUES ('1999-07-10',100100,24), ('1999-07-11',100100,25),
('1999-07-13',100600,0), ('1999-07-13',100600,4), ('1999-07-13',100600,26),
('1999-07-14',100600,10), ('1999-07-15',100600,16), ('1999-07-15',100800,45),
('1999-07-15',101000,47), ('1999-07-16',100800,46), ('1999-07-20',100600,5),
('1999-07-20',100600,27), ('1999-07-21',100600,11), ('1999-07-22',100600,17),
('1999-07-23',100100,39), ('1999-07-24',100100,39), ('1999-07-24',100500,40),
('1999-07-25',100100,39), ('1999-07-27',100600,1), ('1999-07-27',100600,6),
('1999-07-27',100600,28), ('1999-07-28',100600,12), ('1999-07-29',100500,41),
('1999-07-29',100600,18), ('1999-07-30',100500,41), ('1999-07-31',100500,41),
('1999-08-01',100700,34), ('1999-08-03',100600,7), ('1999-08-03',100600,29),
('1999-08-04',100600,13), ('1999-08-05',100500,42), ('1999-08-05',100600,19),
('1999-08-06',100500,42), ('1999-08-07',100500,42), ('1999-08-08',100500,42),
('1999-08-10',100600,2), ('1999-08-10',100600,9), ('1999-08-10',100600,30),
('1999-08-11',100600,14), ('1999-08-12',100600,20), ('1999-08-17',100500,8),
('1999-08-17',100600,31), ('1999-08-18',100600,15), ('1999-08-19',100600,22),
('1999-08-24',100600,3), ('1999-08-24',100600,32), ('1999-08-27',100500,43),
('1999-08-31',100600,33), ('1999-09-17',100100,37), ('1999-09-18',100100,37),
('1999-09-19',100100,37), ('2000-12-18',100700,38);

select event_date,type,event_id from t1 WHERE event_date >= "1999-07-01" AND event_date < "1999-07-15" AND (type=100600 OR type=100100) ORDER BY event_date;
explain select event_date,type,event_id from t1 WHERE type = 100601 and event_date >= "1999-07-01" AND event_date < "1999-07-15" AND (type=100600 OR type=100100) ORDER BY event_date;
select event_date,type,event_id from t1 WHERE event_date >= "1999-07-01" AND event_date <= "1999-07-15" AND (type=100600 OR type=100100) or event_date >= "1999-07-01" AND event_date <= "1999-07-15" AND type=100099;
drop table t1;

CREATE TABLE t1 (
  PAPER_ID smallint(6) DEFAULT '0' NOT NULL,
  YEAR smallint(6) DEFAULT '0' NOT NULL,
  ISSUE smallint(6) DEFAULT '0' NOT NULL,
  CLOSED tinyint(4) DEFAULT '0' NOT NULL,
  ISS_DATE date DEFAULT '0000-00-00' NOT NULL,
  PRIMARY KEY (PAPER_ID,YEAR,ISSUE)
);
INSERT INTO t1 VALUES (3,1999,34,0,'1999-07-12'), (1,1999,111,0,'1999-03-23'),
                      (1,1999,222,0,'1999-03-23'), (3,1999,33,0,'1999-07-12'),
                      (3,1999,32,0,'1999-07-12'), (3,1999,31,0,'1999-07-12'),
                      (3,1999,30,0,'1999-07-12'), (3,1999,29,0,'1999-07-12'),
                      (3,1999,28,0,'1999-07-12'), (1,1999,40,1,'1999-05-01'),
                      (1,1999,41,1,'1999-05-01'), (1,1999,42,1,'1999-05-01'),
                      (1,1999,46,1,'1999-05-01'), (1,1999,47,1,'1999-05-01'),
                      (1,1999,48,1,'1999-05-01'), (1,1999,49,1,'1999-05-01'),
                      (1,1999,50,0,'1999-05-01'), (1,1999,51,0,'1999-05-01'),
                      (1,1999,200,0,'1999-06-28'), (1,1999,52,0,'1999-06-28'),
                      (1,1999,53,0,'1999-06-28'), (1,1999,54,0,'1999-06-28'),
                      (1,1999,55,0,'1999-06-28'), (1,1999,56,0,'1999-07-01'),
                      (1,1999,57,0,'1999-07-01'), (1,1999,58,0,'1999-07-01'),
                      (1,1999,59,0,'1999-07-01'), (1,1999,60,0,'1999-07-01'),
                      (3,1999,35,0,'1999-07-12');
select YEAR,ISSUE from t1 where PAPER_ID=3 and (YEAR>1999 or (YEAR=1999 and ISSUE>28))  order by YEAR,ISSUE;
check table t1;
repair table t1;
drop table t1;

CREATE TABLE t1 (
  id int(11) NOT NULL auto_increment,
  parent_id int(11) DEFAULT '0' NOT NULL,
  level tinyint(4) DEFAULT '0' NOT NULL,
  PRIMARY KEY (id),
  KEY parent_id (parent_id),
  KEY level (level)
);
INSERT INTO t1 VALUES (1,0,0), (3,1,1), (4,1,1), (8,2,2), (9,2,2), (17,3,2),
(22,4,2), (24,4,2), (28,5,2), (29,5,2), (30,5,2), (31,6,2), (32,6,2), (33,6,2),
(203,7,2), (202,7,2), (20,3,2), (157,0,0), (193,5,2), (40,7,2), (2,1,1),
(15,2,2), (6,1,1), (34,6,2), (35,6,2), (16,3,2), (7,1,1), (36,7,2), (18,3,2),
(26,5,2), (27,5,2), (183,4,2), (38,7,2), (25,5,2), (37,7,2), (21,4,2),
(19,3,2), (5,1,1), (179,5,2);
SELECT * FROM t1 WHERE level = 1 AND parent_id = 1;
# The following select returned 0 rows in 3.23.8
SELECT * FROM t1 WHERE level = 1 AND parent_id = 1 order by id;
drop table t1;

#
# Testing of bug in range optimizer with many key parts and > and <
#

create table t1(
		Satellite		varchar(25)	not null,
		SensorMode		varchar(25)	not null,
		FullImageCornersUpperLeftLongitude	double	not null,
		FullImageCornersUpperRightLongitude	double	not null,
		FullImageCornersUpperRightLatitude	double	not null,
		FullImageCornersLowerRightLatitude	double	not null,
	        index two (Satellite, SensorMode, FullImageCornersUpperLeftLongitude, FullImageCornersUpperRightLongitude, FullImageCornersUpperRightLatitude, FullImageCornersLowerRightLatitude));

insert into t1 values("OV-3","PAN1",91,-92,40,50);
insert into t1 values("OV-4","PAN1",91,-92,40,50);

select * from t1 where t1.Satellite = "OV-3" and t1.SensorMode = "PAN1" and t1.FullImageCornersUpperLeftLongitude > -90.000000 and t1.FullImageCornersUpperRightLongitude < -82.000000;
drop table t1;

create table t1 ( aString char(100) not null default "", key aString (aString(10)) );
insert t1 (aString) values ( "believe in myself" ), ( "believe" ), ("baaa" ), ( "believe in love");
select * from t1 where aString < "believe in myself" order by aString;
select * from t1 where aString > "believe in love" order by aString;
alter table t1 drop key aString;
select * from t1 where aString < "believe in myself" order by aString;
select * from t1 where aString > "believe in love" order by aString;
drop table t1;

#
# Problem with binary strings
#

CREATE TABLE t1 (
  t1ID int(10) unsigned NOT NULL auto_increment,
  art binary(1) NOT NULL default '',
  KNR char(5) NOT NULL default '',
  RECHNR char(6) NOT NULL default '',
  POSNR char(2) NOT NULL default '',
  ARTNR char(10) NOT NULL default '',
  TEX char(70) NOT NULL default '',
  PRIMARY KEY  (t1ID),
  KEY IdxArt (art),
  KEY IdxKnr (KNR),
  KEY IdxArtnr (ARTNR)
) ENGINE=MyISAM;

INSERT INTO t1 (art) VALUES ('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),('j'),('J'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),
('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j'),('j');
select count(*) from t1 where upper(art) = 'J';
select count(*) from t1 where art = 'J' or art = 'j';
select count(*) from t1 where art = 'j' or art = 'J';
select count(*) from t1 where art = 'j';
select count(*) from t1 where art = 'J';
drop table t1;
#
# BETWEEN problems
#
create table t1 (x int, y int, index(x), index(y));
insert into t1 (x) values (1),(2),(3),(4),(5),(6),(7),(8),(9);
update t1 set y=x;
# between with only one end fixed
explain select * from t1, t1 t2 where t1.y = 8 and t2.x between 7 and t1.y+0;
explain select * from t1, t1 t2 where t1.y = 8 and t2.x >= 7 and t2.x <= t1.y+0;
# between with both expressions on both ends
explain select * from t1, t1 t2 where t1.y = 2 and t2.x between t1.y-1 and t1.y+1;
explain select * from t1, t1 t2 where t1.y = 2 and t2.x >= t1.y-1 and t2.x <= t1.y+1;
# equation propagation
explain select * from t1, t1 t2 where t1.y = 2 and t2.x between 0 and t1.y;
explain select * from t1, t1 t2 where t1.y = 2 and t2.x >= 0 and t2.x <= t1.y;
# testing IN
explain select count(*) from t1 where x in (1);
explain select count(*) from t1 where x in (1,2);
drop table t1;

#
# bug #1172: "Force index" option caused server crash
#
CREATE TABLE t1 (key1 int(11) NOT NULL default '0', KEY i1 (key1));
INSERT INTO t1 VALUES (0),(0),(0),(0),(0),(1),(1);
CREATE TABLE t2 (keya int(11) NOT NULL default '0', KEY j1 (keya));
INSERT INTO t2 VALUES (0),(0),(1),(1),(2),(2);
explain select * from t1, t2 where (t1.key1 <t2.keya + 1) and t2.keya=3;
explain select * from t1 force index(i1), t2 force index(j1) where 
 (t1.key1 <t2.keya + 1) and t2.keya=3;
DROP TABLE t1,t2;

#
# bug #1724: use RANGE on more selective column instead of REF on less
# selective

CREATE TABLE t1 (
  a int(11) default NULL,
  b int(11) default NULL,
  KEY a (a),
  KEY b (b)
) ENGINE=MyISAM;


INSERT INTO t1 VALUES
(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,2),(10,2),
(13,2),(14,2),(15,2),(16,2),(17,3),(17,3),(16,3),(17,3),(19,3),(20,3),
(21,4),(22,5),(23,5),(24,5),(25,5),(26,5),(30,5),(31,5),(32,5),(33,5),
(33,5),(33,5),(33,5),(33,5),(34,5),(35,5);

# we expect that optimizer will choose index on A
EXPLAIN SELECT * FROM t1 WHERE a IN(1,2) AND b=5;
SELECT * FROM t1 WHERE a IN(1,2) AND b=5;
DROP TABLE t1;

#
# Test problem with range optimzer and sub ranges
#

CREATE TABLE t1 (a int, b int, c int, INDEX (c,a,b));
INSERT INTO t1 VALUES (1,0,0),(1,0,0),(1,0,0);
INSERT INTO t1 VALUES (0,1,0),(0,1,0),(0,1,0);
# -- First reports 3; second reports 6
SELECT COUNT(*) FROM t1 WHERE (c=0 and a=1) or (c=0 and b=1);
SELECT COUNT(*) FROM t1 WHERE (c=0 and b=1) or (c=0 and a=1);
DROP TABLE t1;

#
# Test problem with range optimization over overlapping ranges (#2448)
#

CREATE TABLE t1 ( a int not null, b int not null, INDEX ab(a,b) );
INSERT INTO t1 VALUES (47,1), (70,1), (15,1), (15, 4);
SELECT * FROM t1
WHERE
(
    ( b =1 AND a BETWEEN 14 AND 21 ) OR
    ( b =2 AND a BETWEEN 16 AND 18 ) OR
    ( b =3 AND a BETWEEN 15 AND 19 ) OR
    (a BETWEEN 19 AND 47)
);
DROP TABLE t1;

#
# Test of problem with IN on many different keyparts. (Bug #4157)
#

CREATE TABLE t1 (
id int( 11 ) unsigned NOT NULL AUTO_INCREMENT ,
line int( 5 ) unsigned NOT NULL default '0',
columnid int( 3 ) unsigned NOT NULL default '0',
owner int( 3 ) unsigned NOT NULL default '0',
ordinal int( 3 ) unsigned NOT NULL default '0',
showid smallint( 6 ) unsigned NOT NULL default '1',
tableid int( 1 ) unsigned NOT NULL default '1',
content int( 5 ) unsigned NOT NULL default '188',
PRIMARY KEY ( owner, id ) ,
KEY menu( owner, showid, columnid ) ,
KEY `COLUMN` ( owner, columnid, line ) ,
KEY `LINES` ( owner, tableid, content, id ) ,
KEY recount( owner, line ) 
) ENGINE = MYISAM;

INSERT into t1 (owner,id,columnid,line) values (11,15,15,1),(11,13,13,5);

SELECT id, columnid, tableid, content, showid, line, ordinal FROM t1 WHERE owner=11 AND ((columnid IN ( 15, 13, 14 ) AND line IN ( 1, 2, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 31 )) OR (columnid IN ( 13, 14 ) AND line IN ( 15 ))) LIMIT 0 , 30;
drop table t1;

#
# test for a bug with in() and unique key
#

create  table t1 (id int(10) primary key);
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8),(9);

select id from t1 where id in (2,5,9) ;
select id from t1 where id=2 or id=5 or id=9 ;
drop table t1;
create table t1 ( id1 int not null, id2 int not null, idnull int null, c char(20), primary key (id1,id2));
insert into t1 values (0,1,NULL,"aaa"), (1,1,NULL,"aaa"), (2,1,NULL,"aaa"),
                      (3,1,NULL,"aaa"), (4,1,NULL,"aaa"), (5,1,NULL,"aaa"),
                      (6,1,NULL,"aaa"), (7,1,NULL,"aaa"), (8,1,NULL,"aaa"),
                      (9,1,NULL,"aaa"), (10,1,NULL,"aaa"), (11,1,NULL,"aaa"),
                      (12,1,NULL,"aaa"), (13,1,NULL,"aaa"), (14,1,NULL,"aaa"),
                      (15,1,NULL,"aaa"), (16,1,NULL,"aaa"), (17,1,NULL,"aaa"),
                      (18,1,NULL,"aaa"), (19,1,NULL,"aaa"), (20,1,NULL,"aaa");
select a.id1, b.idnull from t1 as a, t1 as b where a.id2=1 and a.id1=1 and b.id1=a.idnull order by b.id2 desc limit 1;
drop table t1;


#
# Problem with optimizing !=
#

create table t1 (
  id int not null auto_increment,
  name char(1) not null,
  uid int not null,
  primary key (id),
  index uid_index (uid));
  
create table t2 (
  id int not null auto_increment,
  name char(1) not null,
  uid int not null,
  primary key (id),
  index uid_index (uid));
  
insert into t1(id, uid, name) values(1, 0, ' ');
insert into t1(uid, name) values(0, ' ');

insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;
insert into t2(uid, name) select uid, name from t1;
insert into t2(uid, name) select uid, name from t1;
insert into t2(uid, name) select uid, name from t1;
insert into t2(uid, name) select uid, name from t1;
insert into t1(uid, name) select uid, name from t2;

delete from t2;
insert into t2(uid, name) values 
  (1, CHAR(64+1)),
  (2, CHAR(64+2)),
  (3, CHAR(64+3)),
  (4, CHAR(64+4)),
  (5, CHAR(64+5)),
  (6, CHAR(64+6)),
  (7, CHAR(64+7)),
  (8, CHAR(64+8)),
  (9, CHAR(64+9)),
  (10, CHAR(64+10)),
  (11, CHAR(64+11)),
  (12, CHAR(64+12)),
  (13, CHAR(64+13)),
  (14, CHAR(64+14)),
  (15, CHAR(64+15)),
  (16, CHAR(64+16)),
  (17, CHAR(64+17)),
  (18, CHAR(64+18)),
  (19, CHAR(64+19)),
  (20, CHAR(64+20)),
  (21, CHAR(64+21)),
  (22, CHAR(64+22)),
  (23, CHAR(64+23)),
  (24, CHAR(64+24)),
  (25, CHAR(64+25)),
  (26, CHAR(64+26));

insert into t1(uid, name) select uid, name from t2 order by uid;

delete from t2;
insert into t2(id, uid, name) select id, uid, name from t1;

select count(*) from t1;  
select count(*) from t2;

analyze table t1,t2;

explain select * from t1, t2  where t1.uid=t2.uid AND t1.uid > 0;
explain select * from t1, t2  where t1.uid=t2.uid AND t2.uid > 0;
explain select * from t1, t2  where t1.uid=t2.uid AND t1.uid != 0;
explain select * from t1, t2  where t1.uid=t2.uid AND t2.uid != 0;

select * from t1, t2  where t1.uid=t2.uid AND t1.uid > 0;
select * from t1, t2  where t1.uid=t2.uid AND t1.uid != 0;

drop table t1,t2;

# Fix for bug#4488 
#
create table t1 (x bigint unsigned not null);
insert into t1(x) values (0xfffffffffffffff0);
insert into t1(x) values (0xfffffffffffffff1);
select * from t1;
select count(*) from t1 where x>0;
select count(*) from t1 where x=0;
select count(*) from t1 where x<0;
select count(*) from t1 where x < -16;
select count(*) from t1 where x = -16;
select count(*) from t1 where x > -16;
select count(*) from t1 where x = 18446744073709551601;


create table t2 (x bigint not null);
insert into t2(x) values (-16);
insert into t2(x) values (-15);
select * from t2;
select count(*) from t2 where x>0;
select count(*) from t2 where x=0;
select count(*) from t2 where x<0;
select count(*) from t2 where x < -16;
select count(*) from t2 where x = -16;
select count(*) from t2 where x > -16;
select count(*) from t2 where x = 18446744073709551601;
drop table t1,t2;

--disable_warnings
create table t1 (x bigint unsigned not null primary key) engine=innodb;
--enable_warnings
insert into t1(x) values (0xfffffffffffffff0);
insert into t1(x) values (0xfffffffffffffff1);
select * from t1;
select count(*) from t1 where x>0;
select count(*) from t1 where x=0;
select count(*) from t1 where x<0;
select count(*) from t1 where x < -16;
select count(*) from t1 where x = -16;
select count(*) from t1 where x > -16;
select count(*) from t1 where x = 18446744073709551601;

drop table t1;

#
# Bug #11185 incorrect comparison of unsigned int to signed constant
#
create table t1 (a bigint unsigned);
create index t1i on t1(a);
insert into t1 select 18446744073709551615;
insert into t1 select 18446744073709551614;

explain select * from t1 where a <> -1;
select * from t1 where a <> -1;
explain select * from t1 where a > -1 or a < -1;
select * from t1 where a > -1 or a < -1;
explain select * from t1 where a > -1;
select * from t1 where a > -1;
explain select * from t1 where a < -1;
select * from t1 where a < -1;

drop table t1;

#
# Bug #6045: Binary Comparison regression in MySQL 4.1
# Binary searches didn't use a case insensitive index.
#
set names latin1;
create table t1 (a char(10), b text, key (a)) character set latin1;
INSERT INTO t1 (a) VALUES
('111'),('222'),('222'),('222'),('222'),('444'),('aaa'),('AAA'),('bbb');
# all these three can be optimized
explain select * from t1 where a='aaa';
explain select * from t1 where a=binary 'aaa';
explain select * from t1 where a='aaa' collate latin1_bin;
# this one cannot:
explain select * from t1 where a='aaa' collate latin1_german1_ci;
drop table t1;

# Test for BUG#9348 "result for WHERE A AND (B OR C) differs from WHERE a AND (C OR B)"
--disable_warnings
CREATE TABLE t1 (
  `CLIENT` char(3) character set latin1 collate latin1_bin NOT NULL default '000',
  `ARG1` char(3) character set latin1 collate latin1_bin NOT NULL default '',
  `ARG2` char(3) character set latin1 collate latin1_bin NOT NULL default '',
  `FUNCTION` varchar(10) character set latin1 collate latin1_bin NOT NULL default '',
  `FUNCTINT` int(11) NOT NULL default '0',
  KEY `VERI_CLNT~2` (`ARG1`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
--enable_warnings

INSERT INTO t1 VALUES ('000',' 0',' 0','Text 001',0), ('000',' 0',' 1','Text 002',0),
  ('000',' 1',' 2','Text 003',0), ('000',' 2',' 3','Text 004',0),
  ('001',' 3',' 0','Text 017',0);

SELECT count(*) FROM t1 WHERE CLIENT='000' AND (ARG1 != ' 1' OR ARG1 != ' 2');

SELECT count(*) FROM t1 WHERE CLIENT='000' AND (ARG1 != ' 2' OR ARG1 != ' 1');
drop table t1;

# BUG#16168: Wrong range optimizer results, "Use_count: Wrong count ..."
#            warnings in server stderr.
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

CREATE TABLE t2 (
  pk1 int(11) NOT NULL,
  pk2 int(11) NOT NULL,
  pk3 int(11) NOT NULL,
  pk4 int(11) NOT NULL,
  filler char(82),
  PRIMARY KEY (pk1,pk2,pk3,pk4)
) DEFAULT CHARSET=latin1;

insert into t2 select 1, A.a+10*B.a, 432, 44, 'fillerZ' from t1 A, t1 B;
INSERT INTO t2 VALUES (2621, 2635, 0, 0,'filler'), (2621, 2635, 1, 0,'filler'),
  (2621, 2635, 10, 0,'filler'), (2621, 2635, 11, 0,'filler'),
  (2621, 2635, 14, 0,'filler'), (2621, 2635, 1000015, 0,'filler');

SELECT * FROM t2
WHERE ((((pk4 =0) AND (pk1 =2621) AND (pk2 =2635)))
OR ((pk4 =1) AND (((pk1 IN ( 7, 2, 1 ))) OR (pk1 =522)) AND ((pk2 IN ( 0, 2635))))
) AND (pk3 >=1000000);
drop table t1, t2;

#
# Bug #20732: Partial index and long sjis search with '>' fails sometimes
#

create table t1(a char(2), key(a(1)));
insert into t1 values ('x'), ('xx');
explain select a from t1 where a > 'x';
select a from t1 where a > 'x';
drop table t1;

#
# Bug #24776: assertion abort for 'range checked for each record' 
#

CREATE TABLE t1 (
  OXID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT '',
  OXPARENTID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT 'oxrootid',
  OXLEFT int NOT NULL DEFAULT '0',
  OXRIGHT int NOT NULL DEFAULT '0',
  OXROOTID varchar(32) COLLATE latin1_german2_ci NOT NULL DEFAULT '',
  PRIMARY KEY  (OXID),
  KEY OXNID (OXID),
  KEY OXLEFT (OXLEFT),
  KEY OXRIGHT (OXRIGHT),
  KEY OXROOTID (OXROOTID)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_german2_ci;

INSERT INTO t1 VALUES
('d8c4177d09f8b11f5.52725521','oxrootid',1,40,'d8c4177d09f8b11f5.52725521'),
('d8c4177d151affab2.81582770','d8c4177d09f8b11f5.52725521',2,3,
 'd8c4177d09f8b11f5.52725521'),
('d8c4177d206a333d2.74422679','d8c4177d09f8b11f5.52725521',4,5,
 'd8c4177d09f8b11f5.52725521'),
('d8c4177d225791924.30714720','d8c4177d09f8b11f5.52725521',6,7,
 'd8c4177d09f8b11f5.52725521'),
('d8c4177d2380fc201.39666693','d8c4177d09f8b11f5.52725521',8,9,
 'd8c4177d09f8b11f5.52725521'),
('d8c4177d24ccef970.14957924','d8c4177d09f8b11f5.52725521',10,11,
 'd8c4177d09f8b11f5.52725521');
INSERT INTO t1 VALUES
('d8c4177d09f8b11f5.52725522','oxrootid',1,40,'d8c4177d09f8b11f5.52725522'),
('d8c4177d151affab2.81582771','d8c4177d09f8b11f5.52725521',2,3,
 'd8c4177d09f8b11f5.52725522'),
('d8c4177d206a333d2.74422678','d8c4177d09f8b11f5.52725521',4,5,
 'd8c4177d09f8b11f5.52725522'),
('d8c4177d225791924.30714721','d8c4177d09f8b11f5.52725521',6,7,
 'd8c4177d09f8b11f5.52725522'),
('d8c4177d2380fc201.39666694','d8c4177d09f8b11f5.52725521',8,9,
 'd8c4177d09f8b11f5.52725522'),
('d8c4177d24ccef970.14957925','d8c4177d09f8b11f5.52725521',10,11,
 'd8c4177d09f8b11f5.52725522');

EXPLAIN
SELECT s.oxid FROM t1 v, t1 s 
  WHERE 
        v.oxrootid ='d8c4177d09f8b11f5.52725521' AND
        s.oxleft > v.oxleft AND s.oxleft < v.oxright;

SELECT s.oxid FROM t1 v, t1 s 
  WHERE
        v.oxrootid ='d8c4177d09f8b11f5.52725521' AND
        s.oxleft > v.oxleft AND s.oxleft < v.oxright;

DROP TABLE t1;

# BUG#26624 high mem usage (crash) in range optimizer (depends on order of fields in where)
create table t1 (
  c1  char(10), c2  char(10), c3  char(10), c4  char(10),
  c5  char(10), c6  char(10), c7  char(10), c8  char(10),
  c9  char(10), c10 char(10), c11 char(10), c12 char(10),
  c13 char(10), c14 char(10), c15 char(10), c16 char(10),
  index(c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12,c13,c14,c15,c16)
);
insert into t1 (c1) values ('1'),('1'),('1'),('1');

# This must run without crash and fast:
select * from t1 where
     c1 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4",
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c2 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4", 
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c3 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4", 
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c4 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4", 
            "abcdefg5", "123456785", "qwertyui5", "asddfg5", 
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c5 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4",
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c6 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4",
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c7 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4", 
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c8 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4", 
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c9 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4", 
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC")
 and c10 in ("abcdefgh", "123456789", "qwertyuio", "asddfgh", 
            "abcdefg1", "123456781", "qwertyui1", "asddfg1", 
            "abcdefg2", "123456782", "qwertyui2", "asddfg2", 
            "abcdefg3", "123456783", "qwertyui3", "asddfg3", 
            "abcdefg4", "123456784", "qwertyui4", "asddfg4", 
            "abcdefg5", "123456785", "qwertyui5", "asddfg5",
            "abcdefg6", "123456786", "qwertyui6", "asddfg6",
            "abcdefg7", "123456787", "qwertyui7", "asddfg7",
            "abcdefg8", "123456788", "qwertyui8", "asddfg8",
            "abcdefg9", "123456789", "qwertyui9", "asddfg9",
            "abcdefgA", "12345678A", "qwertyuiA", "asddfgA",
            "abcdefgB", "12345678B", "qwertyuiB", "asddfgB",
            "abcdefgC", "12345678C", "qwertyuiC", "asddfgC");
drop table t1;
--echo End of 4.1 tests

#
# Test for optimization request #10561: to use keys for
# NOT IN (c1,...,cn) and NOT BETWEEN c1 AND c2
#

CREATE TABLE t1 (
  id int(11) NOT NULL auto_increment,
  status varchar(20),
  PRIMARY KEY  (id),
  KEY (status)
);

INSERT INTO t1 VALUES
(1,'B'), (2,'B'), (3,'B'), (4,'B'), (5,'B'), (6,'B'),
(7,'B'), (8,'B'), (9,'B'), (10,'B'), (11,'B'), (12,'B'),
(13,'B'), (14,'B'), (15,'B'), (16,'B'), (17,'B'), (18,'B'),
(19,'B'), (20,'B'), (21,'B'), (22,'B'), (23,'B'), (24,'B'), 
(25,'A'), (26,'A'), (27,'A'), (28,'A'), (29,'A'), (30,'A'),
(31,'A'), (32,'A'), (33,'A'), (34,'A'), (35,'A'), (36,'A'),
(37,'A'), (38,'A'), (39,'A'), (40,'A'), (41,'A'), (42,'A'),
(43,'A'), (44,'A'), (45,'A'), (46,'A'), (47,'A'), (48,'A'),
(49,'A'), (50,'A'), (51,'A'), (52,'A'), (53,'C'), (54,'C'),
(55,'C'), (56,'C'), (57,'C'), (58,'C'), (59,'C'), (60,'C');

EXPLAIN SELECT * FROM t1 WHERE status <> 'A' AND status <> 'B';
EXPLAIN SELECT * FROM t1 WHERE status NOT IN ('A','B');

SELECT * FROM t1 WHERE status <> 'A' AND status <> 'B';
SELECT * FROM t1 WHERE status NOT IN ('A','B');

EXPLAIN SELECT status FROM t1 WHERE status <> 'A' AND status <> 'B';
EXPLAIN SELECT status FROM t1 WHERE status NOT IN ('A','B');

EXPLAIN SELECT * FROM t1 WHERE status NOT BETWEEN 'A' AND 'B';
EXPLAIN SELECT * FROM t1 WHERE status < 'A' OR status > 'B';

SELECT * FROM t1 WHERE status NOT BETWEEN 'A' AND 'B';
SELECT * FROM t1 WHERE status < 'A' OR status > 'B';

DROP TABLE t1;

#
# Test for bug #10031: range to be used over a view
#

CREATE TABLE  t1 (a int, b int, primary key(a,b));

INSERT INTO  t1 VALUES
  (1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3);

CREATE VIEW v1 as SELECT a,b FROM t1 WHERE b=3;

EXPLAIN SELECT a,b FROM t1 WHERE a < 2 and b=3;
EXPLAIN SELECT a,b FROM v1 WHERE a < 2 and b=3;

EXPLAIN SELECT a,b FROM t1 WHERE a < 2;
EXPLAIN SELECT a,b FROM v1 WHERE a < 2;

SELECT a,b FROM t1 WHERE a < 2 and b=3;
SELECT a,b FROM v1 WHERE a < 2 and b=3; 

DROP VIEW v1;
DROP TABLE t1;

#
# Bug #11853: DELETE statement with a NOT (LIKE/<=>) where condition
#             for an indexed attribute              
#             

CREATE TABLE t1 (name varchar(15) NOT NULL, KEY idx(name));
INSERT INTO t1 VALUES ('Betty'), ('Anna');

SELECT * FROM t1;
DELETE FROM t1 WHERE name NOT LIKE 'A%a';
SELECT * FROM t1;

DROP TABLE t1;

CREATE TABLE t1 (a int, KEY idx(a));
INSERT INTO t1 VALUES (NULL), (1), (2), (3);

SELECT * FROM t1;
DELETE FROM t1 WHERE NOT(a <=> 2);
SELECT * FROM t1;

DROP TABLE t1;

#
# BUG#13317: range optimization doesn't work for IN over VIEW.
#
create table t1 (a int, b int, primary key(a,b));
create view v1 as select a, b from t1;

INSERT INTO `t1` VALUES
(0,0),(1,0),(2,0),(3,0),(4,0),(5,1),(6,1),(7,1),(8,1),(9,1),(10,2),(11,2),(12,2)
,(13,2),(14,2),(15,3),(16,3),(17,3),(18,3),(19,3);

--replace_column 9 #
explain select * from t1 where a in (3,4)  and b in (1,2,3);
--replace_column 9 #
explain select * from v1 where a in (3,4)  and b in (1,2,3);
--replace_column 9 #
explain select * from t1 where a between 3 and 4 and b between 1 and 2;
--replace_column 9 #
explain select * from v1 where a between 3 and 4 and b between 1 and 2;
 
drop view v1;
drop table t1;

# BUG#13455: 
create table t3 (a int);
insert into t3 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table t1 (a varchar(10), filler char(200), key(a)) charset=binary;
insert into t1 values ('a','');
insert into t1 values ('a ','');
insert into t1 values ('a  ', '');
insert into t1 select concat('a', 1000 + A.a + 10 * (B.a + 10 * C.a)), ''
  from t3 A, t3 B, t3 C;

create table t2 (a varchar(10), filler char(200), key(a));
insert into t2 select * from t1;

--replace_column 9 #
explain select * from t1 where a between 'a' and 'a '; 
--replace_column 9 #
explain select * from t1 where a = 'a' or a='a ';

--replace_column 9 #
explain select * from t2 where a between 'a' and 'a '; 
--replace_column 9 #
explain select * from t2 where a = 'a' or a='a ';

update t1 set a='b' where a<>'a';
--replace_column 9 #
explain select * from t1 where a not between 'b' and 'b'; 
select a, hex(filler) from t1 where a not between 'b' and 'b'; 

drop table t1,t2,t3;

#
# BUG#21282
#
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a int, key(a));
insert into t2 select 2*(A.a + 10*(B.a + 10*C.a)) from t1 A, t1 B, t1 C;

set @a="select * from t2 force index (a) where a NOT IN(0";
select count(*) from (select @a:=concat(@a, ',', a) from t2 ) Z;
set @a=concat(@a, ')');

insert into t2 values (11),(13),(15);

set @b= concat("explain ", @a);

prepare stmt1 from @b;
execute stmt1;

prepare stmt1 from @a;
execute stmt1;

drop table t1, t2;

#
# Bug #18165: range access for BETWEEN with a constant for the first argument 
#

CREATE TABLE t1 (
  id int NOT NULL DEFAULT '0',
  b int NOT NULL DEFAULT '0',
  c int NOT NULL DEFAULT '0', 
  INDEX idx1(b,c), INDEX idx2(c));

INSERT INTO t1(id) VALUES (1), (2), (3), (4), (5), (6), (7), (8);

INSERT INTO t1(b,c) VALUES (3,4), (3,4);

SELECT * FROM t1 WHERE b<=3 AND 3<=c;
SELECT * FROM t1 WHERE 3 BETWEEN b AND c;

EXPLAIN  SELECT * FROM t1 WHERE b<=3 AND 3<=c;
EXPLAIN  SELECT * FROM t1 WHERE 3 BETWEEN b AND c;

SELECT * FROM t1 WHERE 0 < b OR 0 > c;
SELECT * FROM t1 WHERE 0 NOT BETWEEN b AND c;

EXPLAIN SELECT * FROM t1 WHERE 0 < b OR 0 > c;
EXPLAIN SELECT * FROM t1 WHERE 0 NOT BETWEEN b AND c;

DROP TABLE t1;

#
# Bug #16249: different results for a range with an without index 
#             when a range condition use an invalid datetime constant 
#

CREATE TABLE t1 (                                      
  item char(20) NOT NULL default '',                          
  started datetime NOT NULL default '0000-00-00 00:00:00', 
  price decimal(16,3) NOT NULL default '0.000',                 
  PRIMARY KEY (item,started)                     
) ENGINE=MyISAM;   

INSERT INTO t1 VALUES
('A1','2005-11-01 08:00:00',1000),
('A1','2005-11-15 00:00:00',2000),
('A1','2005-12-12 08:00:00',3000),
('A2','2005-12-01 08:00:00',1000);

EXPLAIN SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-02 00:00:00';

DROP INDEX `PRIMARY` ON t1;

EXPLAIN SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-01 24:00:00';
SELECT * FROM t1 WHERE item='A1' AND started<='2005-12-02 00:00:00';

DROP TABLE t1;

--echo
--echo BUG#32198 "Comparison of DATE with DATETIME still not using indexes correctly"
--echo
CREATE TABLE t1 (
  id int(11) NOT NULL auto_increment,
  dateval date default NULL,
  PRIMARY KEY  (id),
  KEY dateval (dateval)
) AUTO_INCREMENT=173;

INSERT INTO t1 VALUES
(1,'2007-01-01'),(2,'2007-01-02'),(3,'2007-01-03'),(4,'2007-01-04'),
(5,'2007-01-05'),(6,'2007-01-06'),(7,'2007-01-07'),(8,'2007-01-08'),
(9,'2007-01-09'),(10,'2007-01-10'),(11,'2007-01-11');

--echo This must use range access:
explain select * from t1 where dateval >= '2007-01-01 00:00:00' and dateval <= '2007-01-02 23:59:59';

drop table t1;

#
# Bug #33833: different or-ed predicates were erroneously merged into one that
# resulted in ref access instead of range access and  a wrong result set
#

CREATE TABLE t1 (
  a varchar(32), index (a)
) DEFAULT CHARSET=latin1 COLLATE=latin1_bin;

INSERT INTO t1 VALUES
  ('B'), ('A'), ('A'), ('C'), ('B'), ('A'), ('A');

SELECT a FROM t1 WHERE a='b' OR a='B';
EXPLAIN SELECT a FROM t1 WHERE a='b' OR a='B';

DROP TABLE t1;

#
# Bug #34731: highest possible value for INT erroneously filtered by WHERE
#

# test UNSIGNED. only occurs when indexed.
CREATE TABLE t1 (f1 TINYINT(11) UNSIGNED NOT NULL, PRIMARY KEY (f1));

INSERT INTO t1 VALUES (127),(254),(0),(1),(255);

# test upper bound
# count 5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 256;
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 256.0;
# count 4
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 255;

# show we don't fiddle with lower bound on UNSIGNED
# count 0
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < -1;
# count 5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -1;

DROP TABLE t1;


# test signed. only occurs when index.
CREATE TABLE t1 ( f1 TINYINT(11) NOT NULL, PRIMARY KEY (f1));

INSERT INTO t1 VALUES (127),(126),(0),(-128),(-127);

# test upper bound
# count 5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 128;
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 128.0;
# count 4
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 < 127;

# test lower bound
# count 5
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -129;
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -129.0;
# count 4
SELECT SQL_NO_CACHE COUNT(*) FROM t1 WHERE f1 > -128;

DROP TABLE t1;

# End of 5.0 tests

# BUG#22393 fix: Adjust 'ref' estimate if we have 'range' estimate for
#                a smaller scan interval
create table t1 (a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table t2 (a int, b int, filler char(100));
insert into t2 select A.a + 10 * (B.a + 10 * C.a), 10, 'filler' from t1 A,
t1 B, t1 C where A.a < 5;

insert into t2 select 1000, b, 'filler' from t2;
alter table t2 add index (a,b);
# t2 values 
#  ( 1  , 10, 'filler')
#  ( 2  , 10, 'filler')
#  ( 3  , 10, 'filler')
#  (... , 10, 'filler')
#   ...
#  (1000, 10, 'filler') - 500 times

# 500 rows, 1 row

select 'In following EXPLAIN the access method should be ref, #rows~=500 (and not 2)' Z;
explain select * from t2 where a=1000 and b<11;

drop table t1, t2;

#
# Bug#42846: wrong result returned for range scan when using covering index
#
CREATE TABLE t1( a INT, b INT, KEY( a, b ) );

CREATE TABLE t2( a INT, b INT, KEY( a, b ) );

CREATE TABLE t3( a INT, b INT, KEY( a, b ) );

INSERT INTO t1( a, b ) 
VALUES (0, 1), (1, 2), (1, 4), (2, 3), (5, 0), (9, 7);

INSERT INTO t2( a, b ) 
VALUES ( 1, 1), ( 2, 1), ( 3, 1), ( 4, 1), ( 5, 1),
       ( 6, 1), ( 7, 1), ( 8, 1), ( 9, 1), (10, 1), 
       (11, 1), (12, 1), (13, 1), (14, 1), (15, 1),
       (16, 1), (17, 1), (18, 1), (19, 1), (20, 1);

INSERT INTO t2 SELECT a, 2 FROM t2 WHERE b = 1;
INSERT INTO t2 SELECT a, 3 FROM t2 WHERE b = 1;

# To make range scan compelling to the optimizer
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t2 SELECT -1, -1 FROM t2;
INSERT INTO t2 SELECT -1, -1 FROM t2;

INSERT INTO t3
VALUES (1, 0), (2, 0), (3, 0), (4, 0), (5, 0),
       (6, 0), (7, 0), (8, 0), (9, 0), (10, 0);

# To make range scan compelling to the optimizer
INSERT INTO t3 SELECT * FROM t3 WHERE a = 10;
INSERT INTO t3 SELECT * FROM t3 WHERE a = 10;


#
# Problem#1 Test queries. Will give missing results unless Problem#1 is fixed.
# With one exception, they are independent of Problem#2.
#
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 < a AND b = 3 OR
3 <= a;

EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 < a AND b = 3 OR
3 <= a;

# Query below: Tests both Problem#1 and Problem#2 (EXPLAIN differs as well)
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 <= a AND b = 3 OR
3 <= a;

EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a < 5 OR 
5 <= a AND b = 3 OR
3 <= a;

SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
5 <= a AND b = 3 OR
3 <= a;

EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
5 <= a AND b = 3 OR
3 <= a;

SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
3 <= a;

EXPLAIN
SELECT * FROM t1 WHERE
3 <= a AND a <= 5 OR 
3 <= a;

#
# Problem#2 Test queries. 
# These queries will give missing results if Problem#1 is fixed.
# But Problem#1 also hides this bug.
#
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 1 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;

EXPLAIN
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 1 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;

SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 2 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;

EXPLAIN
SELECT * FROM t2 WHERE
5 <= a AND a < 10 AND b = 2 OR
15 <= a AND a < 20 AND b = 3
OR
1 <= a AND b = 1;

SELECT * FROM t3 WHERE
5 <= a AND a < 10 AND b = 3 OR 
a < 5 OR
a < 10;

EXPLAIN
SELECT * FROM t3 WHERE
5 <= a AND a < 10 AND b = 3 OR 
a < 5 OR
a < 10;

DROP TABLE t1, t2, t3;

--echo #
--echo # Bug #47123: Endless 100% CPU loop with STRAIGHT_JOIN
--echo #

CREATE TABLE t1(a INT, KEY(a));
INSERT INTO t1 VALUES (1), (NULL);
SELECT * FROM t1 WHERE a <> NULL and (a <> NULL or a <= NULL);
DROP TABLE t1;

--echo #
--echo # Bug#47925: regression of range optimizer and date comparison in 5.1.39!
--echo #
CREATE TABLE t1 ( a DATE,     KEY ( a ) );
CREATE TABLE t2 ( a DATETIME, KEY ( a ) );

--echo # Make optimizer choose range scan
INSERT INTO t1 VALUES ('2009-09-22'), ('2009-09-22'), ('2009-09-22');
INSERT INTO t1 VALUES ('2009-09-23'), ('2009-09-23'), ('2009-09-23');

INSERT INTO t2 VALUES ('2009-09-22 12:00:00'), ('2009-09-22 12:00:00'),
                      ('2009-09-22 12:00:00');
INSERT INTO t2 VALUES ('2009-09-23 12:00:00'), ('2009-09-23 12:00:00'),
                      ('2009-09-23 12:00:00');

--echo # DATE vs DATE
--replace_column 1 X 2 X 3 X 7 X 8 X 9 X 10 X
EXPLAIN
SELECT * FROM t1 WHERE a >= '2009/09/23';
SELECT * FROM t1 WHERE a >= '2009/09/23';
SELECT * FROM t1 WHERE a >= '20090923';
SELECT * FROM t1 WHERE a >=  20090923;
SELECT * FROM t1 WHERE a >= '2009-9-23';
SELECT * FROM t1 WHERE a >= '2009.09.23';
SELECT * FROM t1 WHERE a >= '2009:09:23';

--echo # DATE vs DATETIME
--replace_column 1 X 2 X 3 X 7 X 8 X 9 X 10 X
EXPLAIN
SELECT * FROM t2 WHERE a >= '2009/09/23';
SELECT * FROM t2 WHERE a >= '2009/09/23';
SELECT * FROM t2 WHERE a >= '2009/09/23';
SELECT * FROM t2 WHERE a >= '20090923';
SELECT * FROM t2 WHERE a >=  20090923;
SELECT * FROM t2 WHERE a >= '2009-9-23';
SELECT * FROM t2 WHERE a >= '2009.09.23';
SELECT * FROM t2 WHERE a >= '2009:09:23';

--echo # DATETIME vs DATETIME
--replace_column 1 X 2 X 3 X 7 X 8 X 9 X 10 X
EXPLAIN
SELECT * FROM t2 WHERE a >= '2009/09/23 12:00:00';
SELECT * FROM t2 WHERE a >= '2009/09/23 12:00:00';
SELECT * FROM t2 WHERE a >= '20090923120000';
SELECT * FROM t2 WHERE a >=  20090923120000;
SELECT * FROM t2 WHERE a >= '2009-9-23 12:00:00';
SELECT * FROM t2 WHERE a >= '2009.09.23 12:00:00';
SELECT * FROM t2 WHERE a >= '2009:09:23 12:00:00';

--echo # DATETIME vs DATE
--replace_column 1 X 2 X 3 X 7 X 8 X 9 X 10 X
EXPLAIN
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
SELECT * FROM t1 WHERE a >= '2009/09/23 00:00:00';
SELECT * FROM t1 WHERE a >= '20090923000000';
SELECT * FROM t1 WHERE a >=  20090923000000;
SELECT * FROM t1 WHERE a >= '2009-9-23 00:00:00';
SELECT * FROM t1 WHERE a >= '2009.09.23 00:00:00';
SELECT * FROM t1 WHERE a >= '2009:09:23 00:00:00';

--echo # Test of the new get_date_from_str implementation
--echo # Behavior differs slightly between the trunk and mysql-pe.
--echo # The former may give errors for the truncated values, while the latter
--echo # gives warnings. The purpose of this test is not to interfere, and only
--echo # preserve existing behavior.
SELECT str_to_date('2007-10-00', '%Y-%m-%d') >= '' AND 
       str_to_date('2007-10-00', '%Y-%m-%d') <= '2007/10/20';

SELECT str_to_date('2007-20-00', '%Y-%m-%d') >= '2007/10/20' AND 
       str_to_date('2007-20-00', '%Y-%m-%d') <= '';

SELECT str_to_date('2007-10-00', '%Y-%m-%d') BETWEEN '' AND '2007/10/20';
SELECT str_to_date('2007-20-00', '%Y-%m-%d') BETWEEN '2007/10/20' AND '';

SELECT str_to_date('', '%Y-%m-%d');

DROP TABLE t1, t2;

--echo #
--echo # Bug#48459: valgrind errors with query using 'Range checked for each 
--echo # record'
--echo #
CREATE TABLE t1 (
  a INT,
  b CHAR(2),
  c INT,
  d INT,
  KEY ( c ),
  KEY ( d, a, b ( 2 ) ),
  KEY ( b ( 1 ) )
);

INSERT INTO t1 VALUES ( NULL, 'a', 1, 2 ), ( NULL, 'a', 1, 2 ),
                      ( 1,    'a', 1, 2 ), ( 1,    'a', 1, 2 );

CREATE TABLE t2 (
  a INT,
  c INT,
  e INT,
  KEY ( e )
);

INSERT INTO t2 VALUES ( 1, 1, NULL ), ( 1, 1, NULL );

--echo # Should not give Valgrind warnings
SELECT 1
FROM t1, t2
WHERE t1.d <> '1' AND t1.b > '1'
AND t1.a = t2.a AND t1.c = t2.c;

DROP TABLE t1, t2;

--echo #
--echo # Bug #48665: sql-bench's insert test fails due to wrong result
--echo #

CREATE TABLE t1 (a INT, b INT, PRIMARY KEY (a));

INSERT INTO t1 VALUES (0,0), (1,1);

--replace_column 1 @ 2 @ 3 @ 5 @ 6 @ 7 @ 8 @ 9 @ 10 @
EXPLAIN 
SELECT * FROM t1 FORCE INDEX (PRIMARY) 
 WHERE (a>=1 AND a<=2) OR (a>=4 AND a<=5) OR (a>=0 AND a <=10);

--echo # Should return 2 rows
SELECT * FROM t1 FORCE INDEX (PRIMARY) 
 WHERE (a>=1 AND a<=2) OR (a>=4 AND a<=5) OR (a>=0 AND a <=10);

DROP TABLE t1;

--echo #
--echo # Bug #54802: 'NOT BETWEEN' evaluation is incorrect
--echo #

CREATE TABLE t1 (c_key INT, c_notkey INT, KEY(c_key));
INSERT INTO t1 VALUES (1, 1), (2, 2), (3, 3);

EXPLAIN SELECT * FROM t1 WHERE 2 NOT BETWEEN c_notkey AND c_key;
SELECT * FROM t1 WHERE 2 NOT BETWEEN c_notkey AND c_key;

DROP TABLE t1;

--echo #
--echo # Bug #57030: 'BETWEEN' evaluation is incorrect
--echo #

# Test some BETWEEN predicates which does *not* follow the
# 'normal' pattern of <field> BETWEEN <low const> AND <high const>

CREATE TABLE t1(pk INT PRIMARY KEY, i4 INT);
CREATE UNIQUE INDEX i4_uq ON t1(i4);

INSERT INTO t1 VALUES (1,10), (2,20), (3,30);

EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 10;
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 10;

EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND i4;
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND i4;

EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND i4;
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND i4;

EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND 10;
SELECT * FROM t1 WHERE 10 BETWEEN i4 AND 10;

EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND 10;
SELECT * FROM t1 WHERE 10 BETWEEN 10 AND 10;

EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 11 AND 11;
SELECT * FROM t1 WHERE 10 BETWEEN 11 AND 11;

EXPLAIN
SELECT * FROM t1 WHERE 10 BETWEEN 100 AND 0;
SELECT * FROM t1 WHERE 10 BETWEEN 100 AND 0;

EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 100 AND 0;
SELECT * FROM t1 WHERE i4 BETWEEN 100 AND 0;

EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 99999999999999999;
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND 99999999999999999;

EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 999999999999999 AND 30;
SELECT * FROM t1 WHERE i4 BETWEEN 999999999999999 AND 30;

EXPLAIN
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND '20';
SELECT * FROM t1 WHERE i4 BETWEEN 10 AND '20';

#Should detect the EQ_REF 't2.pk=t1.i4'
EXPLAIN
SELECT * FROM t1, t1 as t2 WHERE t2.pk BETWEEN t1.i4 AND t1.i4;
SELECT * FROM t1, t1 as t2 WHERE t2.pk BETWEEN t1.i4 AND t1.i4;

EXPLAIN
SELECT * FROM t1, t1 as t2 WHERE t1.i4 BETWEEN t2.pk AND t2.pk;
SELECT * FROM t1, t1 as t2 WHERE t1.i4 BETWEEN t2.pk AND t2.pk;

DROP TABLE t1;

--echo #
--echo # BUG#13519696 - 62940: SELECT RESULTS VARY WITH VERSION AND
--echo # WITH/WITHOUT INDEX RANGE SCAN
--echo #

create table t1 (id int unsigned not null auto_increment primary key);
insert into t1 values (null);  
insert into t1 select null from t1;  
insert into t1 select null from t1;  
insert into t1 select null from t1;  
insert into t1 select null from t1;  
insert into t1 select null from t1;  
insert into t1 select null from t1;  
insert into t1 select null from t1;  
insert into t1 select null from t1; 
create table t2 (
 id int unsigned not null auto_increment,
 val decimal(5,3) not null,
 primary key (id,val),
 unique key (val,id),
 unique key (id));  
--disable_warnings
insert into t2 select null,id*0.0009 from t1;
--enable_warnings

select count(val) from t2 ignore index (val) where val > 0.1155;
select count(val) from t2 force index (val)  where val > 0.1155;

drop table t2, t1;

--echo #
--echo # BUG#13453382 - REGRESSION SINCE 5.1.39, RANGE OPTIMIZER WRONG
--echo # RESULTS WITH DECIMAL CONVERSION
--echo #

create table t1 (a int,b int,c int,primary key (a,c));
insert into t1 values (1,1,2),(1,1,3),(1,1,4);
# show that the integer 3 is bigger than the decimal 2.9,
# which should also apply to comparing "c" with 2.9
# when c is 3.
select convert(3, signed integer) > 2.9;
select * from t1 force  index (primary) where a=1 and c>= 2.9;
select * from t1 ignore index (primary) where a=1 and c>= 2.9;
select * from t1 force  index (primary) where a=1 and c> 2.9;
select * from t1 ignore index (primary) where a=1 and c> 2.9;
drop table t1;

--echo #
--echo # BUG#13463488 - 63437: CHAR & BETWEEN WITH INDEX RETURNS WRONG
--echo # RESULT AFTER MYSQL 5.1.
--echo #

CREATE TABLE t1(
 F1 CHAR(5) NOT NULL,
 F2 CHAR(5) NOT NULL,
 F3 CHAR(5) NOT NULL,
 PRIMARY KEY(F1),
 INDEX IDX_F2(F2)
);

INSERT INTO t1 VALUES
('A','A','A'),('AA','AA','AA'),('AAA','AAA','AAA'),
('AAAA','AAAA','AAAA'),('AAAAA','AAAAA','AAAAA');

SELECT * FROM t1 WHERE F1 = 'A    ';
SELECT * FROM t1 IGNORE INDEX(PRIMARY) WHERE F1 = 'A    ';
SELECT * FROM t1 WHERE F1 >= 'A    ';
SELECT * FROM t1 WHERE F1 > 'A    ';
SELECT * FROM t1 WHERE F1 BETWEEN 'A    ' AND 'AAAAA';
SELECT * FROM t1 WHERE F2 BETWEEN 'A    ' AND 'AAAAA';
SELECT * FROM t1 WHERE F3 BETWEEN 'A    ' AND 'AAAAA';
SELECT * FROM t1 IGNORE INDEX(PRIMARY) WHERE F1 BETWEEN 'A    ' AND
'AAAAA';

DROP TABLE t1;

--echo #
--echo # mdev-4894:  Poor performance with unnecessary 
--echo # (bug#70021) 'Range checked for each record'
--echo #

create table t1( key1 int not null, INDEX i1(key1) );
insert into t1 values (1),(2),(3),(4),(5),(6),(7),(8);
insert into t1 select key1+8 from t1; 
insert into t1 select key1+16 from t1; 
insert into t1 select key1+32 from t1; 
insert into t1 select key1+64 from t1; 
insert into t1 select key1+128 from t1; 
insert into t1 select key1+256 from t1; 
insert into t1 select key1+512 from t1; 

alter table t1 add key2 int not null, add index i2(key2);
update t1 set key2=key1;
analyze table t1;

create table t2 (a int);
insert into t2 values (1),(2),(3),(4),(5),(6),(7),(8);
insert into t2 select a+16 from t2;
insert into t2 select a+32 from t2;
insert into t2 select a+64 from t2;

explain
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < 1000;
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < 1000;
explain
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < t2.a;
select count(*) from t2 left join t1 on (t1.key1 < 3 or t1.key1 > 1020) and t1.key2 < t2.a;

drop table t1,t2;

--echo End of 5.1 tests

--echo #
--echo # LP Bug #533117: Wrong use_count in SEL_ARG trees
--echo #   (Bug #58731)
--echo #

create table t1 (a int, b int, c int, key idx (a,b,c));
insert into t1 values (0,0,0), (2,2,0), (1,1,1), (2,2,1);

explain
select * from t1 force index (idx) where a >=1 and c <= 1 and a=b and b > 1;
select * from t1 force index (idx) where a >=1 and c <= 1 and a=b and b > 1;

drop table t1;

#
# lp:750117 Bogus warning with aggregate and datetime column
#
create table t1 (f1 datetime, key (f1));
insert into t1 values ('2000-03-09 15:56:59'),('2000-05-05 23:24:28'),('2000-06-13 13:12:06');
select  min(f1)  from t1 where f1 >= '2006-05-25 07:00:20' and f1 between '2003-11-23 10:00:09' and '2010-01-01 01:01:01' and f1 > '2001-01-01 01:01:01';
drop table t1;

--echo #
--echo # BUG#11765831: 'RANGE ACCESS' MAY INCORRECTLY FILTER 
--echo #               AWAY QUALIFYING ROWS
--echo #

CREATE TABLE t10(
  K INT NOT NULL AUTO_INCREMENT,
  I INT, J INT,
  PRIMARY KEY(K),
  KEY(I,J)
);
INSERT INTO t10(I,J) VALUES (6,1),(6,2),(6,3),(6,4),(6,5),
                            (6,6),(6,7),(6,8),(6,9),(6,0);

CREATE TABLE t100 LIKE t10;
INSERT INTO t100(I,J) SELECT X.I, X.K+(10*Y.K) FROM t10 AS X,t10 AS Y;

# Insert offending value:
INSERT INTO t100(I,J) VALUES(8,26);

let $query= SELECT * FROM t100 WHERE I <> 6 OR (I <> 8 AND J = 5);

#Verify that 'range' access will be used
--echo
--eval EXPLAIN $query

# Only row 101,8,26 should be returned
--echo
--eval $query

DROP TABLE t10,t100;

--echo #
--echo # lp:817363: Wrong result with sort_union and multipart key in maria-5.3
--echo # 
CREATE TABLE t1 (a int NOT NULL , b int, c int, d varchar(32), KEY (d,b), PRIMARY KEY (a)) ;
INSERT INTO t1 VALUES (7,7,NULL,'e'),(8,1,0,'p'),(9,7,1,'s'),(10,1,1,'j'),(12,2,0,'c'),(13,0,0,'a'),(14,1,1,'q');

SELECT c FROM t1                  WHERE d='q' OR d>='q' OR a > 97 OR (d IN ('j','s','i') AND b = 102);
SELECT c FROM t1 ignore index (d) WHERE d='q' OR d>='q' OR a > 97 OR (d IN ('j','s','i') AND b = 102);

SELECT * FROM t1 ignore index(d) WHERE d = 'q' OR d >= 'q' OR (d IN ( 'j' , 's' , 'i' ) AND ( b = 102 ));
SELECT * FROM t1 force index(d)  WHERE d = 'q' OR d >= 'q' OR (d IN ( 'j' , 's' , 'i' ) AND ( b = 102 ));

DROP TABLE t1;

--disable_parsing
# MariaDB: Moved the following to partition.test
--echo #
--echo # BUG#12912171 - ASSERTION FAILED: QUICK->HEAD->READ_SET ==
--echo # SAVE_READ_SET
--echo #
CREATE TABLE t1 (
 a INT,
 b INT,
 c INT,
 PRIMARY KEY (c,a), KEY (a),KEY (a)
) ENGINE=INNODB PARTITION BY KEY () PARTITIONS 2;
INSERT INTO t1 VALUES (1,5,1),(2,4,1),(3,3,1),(4,2,1),(5,1,1);
UPDATE t1 SET b = 0, c=1 WHERE a <=>0;
SELECT * FROM t1;
DROP TABLE t1;
--enable_parsing

--echo #
--echo # BUG#13256446 - ASSERTION QUICK->HEAD->READ_SET ==
--echo # SAVE_READ_SET' FAILED IN OPT_RANGE.CC:1606 
--echo #
CREATE TABLE t1 (
 f1 INT AUTO_INCREMENT,
 f2 INT,
 f3 INT,
 f4 INT,
 PRIMARY KEY (f1),KEY(f2)
) ENGINE=INNODB;
CREATE ALGORITHM=MERGE VIEW v2 AS SELECT f1,f2,f3,f4 FROM t1 WHERE f2=103;
INSERT INTO t1 VALUES (154,0,NULL,0),(0,NULL,9,0),
 (NULL,102,NULL,3),(0,3,NULL,0), (9,0,NULL,0),(0,9,NULL,157);
SELECT * FROM v2;
UPDATE v2 SET f4=0, f2=NULL, f1=NULL WHERE f1 > 16 ORDER BY f1;
SELECT * FROM v2;
DROP TABLE t1;
DROP VIEW v2;

CREATE TABLE t1 (
 f1 INT AUTO_INCREMENT,
 f2 INT,
 f3 INT,
 f4 INT,
 PRIMARY KEY (f1),KEY(f2)
) ENGINE=INNODB;
INSERT INTO t1 VALUES(1,NULL,NULL,0), (2,2,0,3), (9,0,107,18),
 (10,0,0,0), (231,0,0,0), (232,0,8,0), (234,0,0,NULL), (235,8,0,3);
CREATE ALGORITHM=MERGE VIEW v3 AS SELECT f1,f2,f3,f4 FROM t1 WHERE f1<=85 ;
SELECT * FROM v3;
UPDATE v3 SET f3=0, f4=4 WHERE f2=68 ORDER BY f1; 
SELECT * FROM v3;
DROP TABLE t1;
DROP VIEW v3;

--echo #
--echo # MDEV-6105: Emoji unicode character string search query makes mariadb performance down
--echo #
SET NAMES utf8;
DROP TABLE IF EXISTS t1;
CREATE TABLE t1(
id int AUTO_INCREMENT,
fd varchar(20),
primary key(id),
index ix_fd(fd)
)engine=innodb default charset=UTF8;
INSERT INTO t1(id, fd) VALUES (null, ''),(null, 'matt'),(null, 'pitt'),(null, 'lee'),(null, 'kim');
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
INSERT INTO t1 (fd) SELECT fd FROM t1;
--echo # The following should show "Impossible WHERE" :
explain
SELECT * FROM t1 WHERE fd='';
SELECT * FROM t1 WHERE fd='';

--echo # The following must not use range access:
--replace_column 9 #
explain select count(*) from t1 where fd <'';
select count(*) from t1 where fd <'';
select count(*) from t1 ignore index (ix_fd) where fd <'';

drop table t1;
set names default;

#
# Bug#17755540 VALGRIND ERROR WHEN SETTING UP ROW COMPARATORS
#
create table t2 (a int, b int, c int, d int, key x(a, b));
insert into t2 values (2, 2, 2, 2), (3, 3, 3, 3), (4, 4, 4, 4), (5, 5, 5, 5),
  (6, 6, 6, 6), (7, 7, 7, 7), (8, 8, 8, 8), (9, 9, 9, 9);
insert into t2 select * from t2;
insert into t2 values (0, 0, 0, 0), (1, 1, 1, 1);
analyze table t2;
select a, b from t2 where (a, b) in ((0, 0), (1, 1));
drop table t2;

--echo #
--echo # MDEV-10228: Delete missing rows with OR conditions
--echo #  (The example uses UPDATE, because UPDATE allows to use index hints
--echo #   and so it's possible to make an example that works with any storage
--echo #   engine)
--echo #

CREATE TABLE t1 (
  key1varchar varchar(14) NOT NULL,
  key2int int(11) NOT NULL DEFAULT '0',
  col1 int,
  PRIMARY KEY (key1varchar,key2int),
  KEY key1varchar (key1varchar),
  KEY key2int (key2int)
) DEFAULT CHARSET=utf8;
 
insert into t1 values 
  ('value1',0, 0),
  ('value1',1, 0),
  ('value1',1000685, 0),
  ('value1',1003560, 0),
  ('value1',1004807, 0);

update t1 force index (PRIMARY) set col1=12345
where (key1varchar='value1' AND (key2int <=1 OR  key2int > 1));
--echo # The following must show col1=12345 for all rows:
select * from t1;
drop table t1;

--echo #
--echo # MDEV-22191: Range access is not picked when index_merge_sort_union is turned off
--echo #

set @save_optimizer_switch=@@optimizer_switch;
set @save_optimizer_switch="index_merge_sort_union=OFF";
CREATE TABLE t1 (a INT, INDEX(a));
INSERT INTO t1 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
explain
SELECT * FROM t1 WHERE a > 5;
SELECT * FROM t1 WHERE a > 5;
set @@optimizer_switch=@save_optimizer_switch;
drop table t1;

--echo # End of 5.5 tests

--echo #
--echo # BUG#13731380: RANGE OPTIMIZER CALLS RECORDS_IN_RANGE() FOR OPEN RANGE
--echo #

CREATE TABLE t1 (pk INT PRIMARY KEY);
INSERT INTO t1 VALUES (1),(3),(5);
SELECT * FROM t1 WHERE pk <> 3 OR pk < 4;
DROP TABLE t1;

--echo #
--echo # BUG#13803810: TOO FEW ROWS RETURNED FOR RANGE ACCESS IN 
--echo #               VARCHAR INDEX USING DATETIME VALUE
--echo
CREATE TABLE t1 (a DATETIME);
INSERT INTO t1 VALUES ('2001-01-01 00:00:00');
INSERT INTO t1 VALUES ('2001-01-01 11:22:33');

CREATE TABLE t2 (b VARCHAR(64), KEY (b));
INSERT INTO t2 VALUES ('2001-01-01');
INSERT INTO t2 VALUES ('2001.01.01');
INSERT INTO t2 VALUES ('2001#01#01');
INSERT INTO t2 VALUES ('2001-01-01 00:00:00');
INSERT INTO t2 VALUES ('2001-01-01 11:22:33');


--echo
--echo # range/ref access cannot be used for this query
--echo
EXPLAIN SELECT * FROM t2 WHERE b=CAST('2001-01-01' AS DATE);
SELECT * FROM t2 WHERE b=CAST('2001-01-01' AS DATE);

let $query_ab=SELECT * FROM t1, t2 WHERE a=b ORDER BY BINARY a, BINARY b;
let $query_ba=SELECT * FROM t1, t2 WHERE b=a ORDER BY BINARY a, BINARY b;

--echo
--echo # range/ref access cannot be used for any of the queries below.
--echo # See BUG#13814468 about 'Range checked for each record'
--echo
eval EXPLAIN $query_ab;
eval $query_ab;
--echo
eval EXPLAIN $query_ba;
eval $query_ba;

--echo
DROP TABLE t1,t2;

--echo #
--echo #  MDEV-5606: range optimizer: "x < y" is sargable, while "y > x" is not
--echo #
create table t1(a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2(a int);
insert into t2 select A.a + B.a* 10 + C.a * 100 from t1 A, t1 B, t1 C;
alter table t2 add key(a);
--echo # Should have "range checked for each table" for second table:
explain select * from t1, t2 where t2.a < t1.a;
--echo # Should have "range checked for each table" for second table:
explain select * from t1, t2 where t1.a > t2.a;

create table t3 (a int primary key, b int);
insert into t3 select a,a from t1;
--echo # The second table should use 'range':
explain select * from t3, t2 where t2.a < t3.b  and t3.a=1;
--echo # The second table should use 'range':
explain select * from t3, t2 where t3.b > t2.a   and t3.a=1;
drop table t1,t2,t3;

--echo #
--echo # MDEV-6480: Remove conditions for which range optimizer returned SEL_ARG::IMPOSSIBLE.
--echo #
create table t1(a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);
create table t2 (a int, b int, c int, key(a), key(b));
insert into t2
select 
  A.a + B.a* 10 + C.a * 100,
  A.a + B.a* 10 + C.a * 100,
  12345
from 
  t1 A, t1 B, t1 C;

--echo # EXPLAIN EXTENDED should show that 'b > 25 and b < 15' is removed from the WHERE:
explain extended select * from t2 where (b > 25 and b < 15) or a<44;

--echo # EXPLAIN EXTENDED should show that 'b > 25 and b < 15' is removed from the WHERE:
explain extended select * from t2 where a < 44 or (b > 25 and b < 15);

--echo # Here, conditions b will not be removed, because "c<44" is not sargable
--echo #   and hence (b.. and .. b) part is not analyzed at all:
explain extended select * from t2 where c < 44 or (b > 25 and b < 15);

--echo # EXPLAIN EXTENDED should show that 'b > 25 and b < 15' is removed from the WHERE:
explain extended select * from t2 where (b > 25 and b < 15) or c < 44;

--echo # Try a case where both OR parts produce SEL_ARG::IMPOSSIBLE:
explain extended select * from t2 where (b > 25 and b < 15) or (a>55 and a<44);

drop table t1,t2;


--echo #
--echo # Start of 10.1 tests
--echo #

--echo #
--echo # MDEV-8189 field<>const and const<>field are not symmetric
--echo #
CREATE TABLE t1 (a INT, b INT, KEY(a));
INSERT INTO t1 (a) VALUES (10),(10),(10),(10),(10),(10),(10),(10),(10),(10),(70);
EXPLAIN SELECT * FROM t1 WHERE a<>10;
EXPLAIN SELECT * FROM t1 WHERE 10<>a;
SELECT * FROM t1 WHERE a<>10;
SELECT * FROM t1 WHERE 10<>a;
DROP TABLE t1;


--echo #
--echo # MDEV-8613 Full table scan for WHERE indexed_varchar_column <=> 'bad-character'
--echo #
SET NAMES utf8;
CREATE TABLE t1 (a VARCHAR(10) CHARACTER SET utf8, KEY(a)) ENGINE=MyISAM;
INSERT INTO t1 VALUES ('a'),('b'),('c'),('d'),('e');
EXPLAIN SELECT * FROM t1 WHERE a<=>'';
DROP TABLE t1;

--echo #
--echo # MDEV-10185: Assertion `tree1->keys[key_no] && tree2->keys[key_no]' failed in 
--echo #             sel_trees_can_be_ored(RANGE_OPT_PARAM*, SEL_TREE*, SEL_TREE*, key_map*)
--echo #
CREATE TABLE t1 (pk INT PRIMARY KEY);
INSERT INTO t1 VALUES (1),(2);
SELECT * FROM t1 WHERE pk != 1000 OR pk IN ( 1000, 0, 1, 100, 2 ) OR pk >= 5;
DROP TABLE t1;

--echo #
--echo # End of 10.1 tests
--echo #

--echo #
--echo # MDEV-10454: range access keys extracted
--echo #             from <row> IN (<row value list>) 
--echo #

create table t1(a int, b int, c varchar(16),  key idx(a,b)) engine=myisam;

insert into t1 values
  (1,1,'xx'), (2,2,'yyy'), (3,3,'zzzz'), (1,2,'zz'), (1,3,'x'),
  (2,3,'yy'), (4,5,'ww'), (7,8,'xxxxx'), (4,3,'zyx'), (1,2,'uuu'),
  (2,1,'w'), (5,5,'wx'), (2,3,'ww'), (7,7,'xxxyy'), (3,3,'zyxw'),
  (3,2,'uuuw'), (2,2,'wxz'), (5,5,'xw'), (12,12,'xx'), (12,12,'y'),
  (13,13,'z'), (11,12,'zz'), (11,13,'x'), (12,13,'y'), (14,15,'w'),
  (17,18,'xx'), (14,13,'zx'), (11,12,'u'), (12,11,'w'), (5,5,'wx'),
  (12,13,'ww'), (17,17,'xxxyy'), (13,13,'zyxw'), (13,12,'uuuw'), (12,12,'wxz'),
  (15,15,'xw'), (1,1,'xa'), (2,2,'yya'), (3,3,'zzza'), (1,2,'za'),
  (1,3,'xb'), (2,3,'ya'), (4,5,'wa'), (7,8,'xxxxa'), (4,3,'zya'),
  (1,2,'uua'), (2,1,'wb'), (5,5,'wc'), (2,3,'wa'), (7,7,'xxxya'),
  (3,3,'zyxa'), (3,2,'uuua'), (2,2,'wxa'), (5,5,'xa'), (12,12,'xa'),
  (22,12,'yb'), (23,13,'zb'), (21,12,'za'), (24,13,'c'), (32,13,'d'),
  (34,15,'wd'), (47,18,'xa'), (54,13,'za'), (51,12,'ub'), (52,11,'wc'),
  (5,5,'wd'), (62,13,'wa'), (67,17,'xxxya'), (63,13,'zyxa'), (73,12,'uuua'),
  (82,12,'wxa'), (85,15,'xd');

--echo # range access to t1 by 2-component keys for index idx
let $q1= 
select * from t1 where (a,b) IN ((2, 3),(3,3),(8,8),(7,7));
eval explain $q1;
eval explain format=json $q1;
eval $q1;
eval prepare stmt from "$q1";
execute stmt;
execute stmt;
deallocate prepare stmt;

--echo # range access to t1 by 1-component keys for index idx
let $q2=
select * from t1 where (a,b+a) IN ((4,9),(8,8),(7,7));
eval explain $q2;
eval explain format=json $q2;
eval $q2;

--echo # range access to t1 by 1-component keys for index idx
let $q3=
select * from t1 where (a,b) IN ((4,a-1),(8,a+8),(7,a+7));
eval explain $q3;
eval explain format=json $q3;
eval $q3;

# this setting should be removed after fixes for mdev-12186, mdev-12187
set @save_optimizer_switch=@@optimizer_switch;
set optimizer_switch='index_merge=off';
                
create table t2(
  d int, e int, key idx1(d), key idx2(e), f varchar(32)
) engine=myisam;

insert into t2 values
  (9,5,'a'), (9,8,'b'), (9,3,'c'), (9,2,'d'), (9,1,'e'),
  (6,5,'f'), (6,3,'g'), (6,7,'h'), (3,3,'i'), (6,2,'j'),
  (9,5,'aa'), (9,8,'ba'), (9,3,'ca'), (2,2,'da'), (9,1,'ea'),
  (6,5,'fa'), (6,3,'ga'), (6,7,'ha'), (9,3,'ia'), (6,2,'ja');
   
--echo # join order: (t2,t1) with ref access of t1
--echo # range access to t1 by keys for index idx1
let $q4=
select * from t1,t2
  where a = d and (a,e) in ((3,3),(7,7),(2,2));
eval explain $q4;
eval explain format=json $q4;
eval $q4;

insert into t2 values
  (4,5,'a'), (7,8,'b'), (4,3,'c'), (1,2,'d'), (2,1,'e'), (5,5,'f'),
  (2,3,'g'), (7,7,'h'), (3,3,'i'), (3,2,'j'), (2,2,'k'), (5,5,'l'),
  (4,5,'aa'), (7,8,'bb'), (4,3,'cc'), (1,2,'dd'), (2,1,'ee'), (9,5,'ff'),
  (2,3,'gg'), (7,7,'hh'), (3,3,'ii'), (3,2,'jj'), (2,2,'kk'), (9,5,'ll'),
  (4,5,'aaa'), (7,8,'bbb'), (4,3,'ccc'), (1,2,'ddd'), (2,1,'eee'), (5,5,'fff'),
  (2,3,'ggg'), (7,7,'hhh'), (3,3,'iii'), (3,2,'jjj'), (2,2,'kkk'), (5,5,'lll'),
  (14,15,'a'), (17,18,'b'), (14,13,'c'), (11,12,'d'), (12,11,'e'), (15,15,'f'),
  (12,13,'g'), (17,17,'h'), (13,13,'i'), (13,12,'j'), (12,12,'k'), (15,15,'l'),
  (24,25,'a'), (27,28,'b'), (24,23,'c'), (21,22,'d'), (22,21,'e'), (25,25,'f'),
  (22,23,'g'), (27,27,'h'), (23,23,'i'), (23,22,'j'), (22,22,'k'), (25,25,'l'),
  (34,35,'a'), (37,38,'b'), (34,33,'c'), (31,32,'d'), (32,31,'e'), (35,35,'f'),
  (32,33,'g'), (37,37,'h'), (33,33,'i'), (33,32,'j'), (32,32,'k'), (35,35,'l'),
  (44,45,'a'), (47,48,'b'), (44,43,'c'), (41,42,'d'), (42,41,'e'), (45,45,'f'),
  (42,43,'g'), (47,47,'h'), (43,43,'i'), (43,42,'j'), (42,42,'k'), (45,45,'l');

--echo # join order: (t1,t2) with ref access of t2 
--echo # range access to t1 by 1-component keys for index idx
let $q5=
select * from t1,t2
  where a = d and (a,e) in ((3,3),(7,7),(8,8)) and length(f) = 1;
eval explain $q5;
eval explain format=json $q5;
eval $q5;
eval prepare stmt from "$q5";
execute stmt;
execute stmt;
deallocate prepare stmt;
  
insert into t1 select * from t1;

--echo # join order: (t2,t1) with ref access of t1
--echo # range access to t2 by keys for index idx2
let $q6=
select * from t1,t2 
  where a = d and (a,e) in ((4,4),(7,7),(8,8)) and length(f) = 1;
eval explain $q6;
eval explain format=json $q6;
eval $q6;

alter table t2 drop index idx1, drop index idx2, add index idx3(d,e);

--echo # join order: (t2,t1) with ref access of t1
--echo # range access to t2 by 2-component keys for index idx3
let $q7=
select * from t1,t2 
  where a = d and (a,e) in ((4,4),(7,7),(8,8)) and length(f) = 1;
eval explain $q7;
eval explain format=json $q7;
eval $q7;

--echo # join order: (t1,t2) with ref access of t2
--echo # range access to t1 by 1-component keys for index idx
let $q8=
select * from t1,t2
  where a = d and (a,e) in ((4,d+1),(7,d+1),(8,d+1)) and length(f) = 1;
eval explain $q8;
eval explain format=json $q8;
eval $q8;

--echo # join order: (t1,t2) with ref access of t2
--echo # no range access
let $q9=
select * from t1,t2
  where a = d and (a,e) in ((e,d+1),(7,7),(8,8)) and length(f) = 1;
eval explain $q9;
eval explain format=json $q9;
eval $q9;

--echo # join order: (t1,t2) with ref access of t2
--echo # range access to t1 by 1-component keys for index idx
let $q10=
select * from t1,t2
  where a = d and (a,2) in ((2,2),(7,7),(8,8)) and
        length(c) = 1 and length(f) = 1;
eval explain $q10;
eval explain format=json $q10;
eval $q10;
eval prepare stmt from "$q10";
execute stmt;
execute stmt;
deallocate prepare stmt;

create table t3 (id int primary key, v int) engine=myisam;

insert into t3 values
  (3,2), (1,1), (4,12), (2,15);

--echo # join order: (t3,t1,t2) with const t3 and ref access of t2
--echo # range access to t1 by 1-component keys for index idx
let $q11=
select * from t1,t2,t3
  where id = 1 and a = d and
        (a,v+1) in ((2,2),(7,7),(8,8)) and
        length(c) = 1 and length(f) = 1;
eval explain $q11;
eval explain format=json $q11;
eval $q11;

--echo # IN predicate is always FALSE
let $q12=
select * from t1,t2,t3
  where id = 1 and a = d and
        (a,v+1) in ((9,9),(7,7),(8,8)) and
        length(c) = 1 and length(f) = 1;
eval explain $q12;
eval prepare stmt from "$q12";
execute stmt;
execute stmt;
deallocate prepare stmt;

set optimizer_switch=@save_optimizer_switch;

drop table t1,t2,t3;

--echo #
--echo # MDEV-16934: using system variable eq_range_index_dive_limit
--echo #             to reduce the number of index dives
--echo #

create table t1 (a int, b varchar(31), index idx(a));

insert into t1 values
  (7,'xxxx'), (1,'yy'), (3,'aaa'), (1,'bbb'), (2,'zz'),
  (4,'vvvvv'), (7,'ddd'), (9,'zzzzz'), (1,'cc'), (5,'ffff');
insert into t1 select a+10, concat(b,'zz') from t1;
insert into t1 select a+15, concat(b,'yy') from t1;
insert into t1 select a+100, concat(b,'xx') from t1;

analyze table t1;

select cast(count(a)/count(distinct a) as unsigned) as rec_per_key from t1;

let $q=
select * from t1 where a in (8, 15, 31, 1, 9);

set eq_range_index_dive_limit=0;
eval explain $q;
eval $q;

set eq_range_index_dive_limit=2;
eval explain $q;
eval $q;

set eq_range_index_dive_limit=default;

drop table t1;

--echo #
--echo # MDEV-24117: Memory management problem in statistics state...
--echo #  (just the testcase)
--echo #

create table t0(a int);
insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table t1(a int);

# 4K rows
insert into t1
select A.a + B.a* 10 + C.a * 100 + D.a * 1000
from t0 A, t0 B, t0 C, t0 D
where D.a<4;

create table t2 (
  a int,
  b int,
  key(a)
);

insert into t2 values (1,1),(2,2),(3,3);

set @query=(select group_concat(a) from t1);

set @tmp_24117= @@max_session_mem_used;

--echo #
--echo # On debug build, the usage was
--echo #  - 2.8M without the bug
--echo #  - 1G with the bug.

set max_session_mem_used=64*1024*1024;

set @query=concat('explain select * from t2 where a in (', @query, ')');

prepare s from @query;

--echo # This should not fail with an error:
execute s;
set max_session_mem_used=@tmp_24117;

deallocate prepare s;

drop table t0,t1,t2;
--echo #
--echo # MDEV-23811: Both disjunct of WHERE condition contain range conditions
--echo #             for the same index such that the second range condition
--echo #             fully covers the first one. Additionally one of the disjuncts
--echo #             contains a range condition for the other index.
--echo #

create table t1 (
  pk int primary key auto_increment, a int, b int,
  index idx1(a), index idx2(b)
);
insert into t1(a,b) values
  (5,50), (1,10), (3,30), (7,70), (8,80), (4,40), (2,20), (6,60);
insert into t1(a,b) select a+10, b+100 from t1;
insert into t1(a,b) select a+20, b+200 from t1;
insert into t1(a,b) select a+30, b+300 from t1;
insert into t1(a,b) select a,b from t1;

analyze table t1;

let $q1=
select * from t1 where ((a between 3 and 4) and b < 100) or (a between 2 and 5);
eval explain $q1;
eval $q1;

let $q2=
select * from t1 where (a between 2 and 5) or ((a between 3 and 4) and b < 100);
eval explain $q2;
eval $q2;

let $q3=
select * from t1 where (a between 3 and 4) or ((a between 2 and 5) and b < 100);
eval explain $q3;
eval $q3;

let $q4=
select * from t1 where ((a between 2 and 5) and b < 100) or (a between 3 and 4);
eval explain $q4;
eval $q4;

drop table t1;

#
# MDEV-21958: Query having many NOT-IN clauses running forever (testcase 2)
#
create table t1(a int);
insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);

create table t2 (
  pk int primary key,
  key1 int,
  col1 varchar(255),
  key (key1, pk)
);

insert into t2 (pk, key1)
select A.a+10 *B.a + 100*C.a, A.a+10 *B.a +100*C.a from t1 A, t1 B, t1 C;

--echo # This must use ALL, not range:
explain select * from t2 force index (primary) where pk not in (1,2,3);

drop table t1,t2;

--echo #
--echo # MDEV-24444: ASAN use-after-poison in Item_func_in::get_func_mm_tree with NOT IN
--echo #
CREATE TABLE t1 (id INT, a CHAR(3), b INT, PRIMARY KEY(id), KEY(b), KEY(a));
INSERT INTO t1 VALUES (1,'foo',10),(2,'bar',20);

CREATE TABLE t2 (code CHAR(8), num INT, PRIMARY KEY (code));
INSERT INTO t2 VALUES ('100',1),('111',2);

SELECT * FROM t1 JOIN t2 ON (t2.code = t1.b) WHERE t1.a NOT IN ('baz', 'qux') OR t2.num != 3;

DROP TABLE t1, t2;


--echo #
--echo # MDEV-22251: get_key_scans_params: Conditional jump or move depends on uninitialised value
--echo #

create table t1 (pk int, i int, v int, primary key (pk), key(v));
insert into t1 (pk,i,v) values (1,1,2),(2,2,4),(3,3,6),(4,4,8),(5,5,10),(6,6,12),(7,7,14),(8,8,16);
create table t2 (a int, b int);
insert into t2 values (1,2),(2,4);
EXPLAIN
select * from t1 inner join t2 on ( t2.b = t1.v or t2.a = t1.pk);
select * from t1 inner join t2 on ( t2.b = t1.v or t2.a = t1.pk);
drop table t1, t2;

--echo #
--echo # MDEV-26553: Always FALSE/NULL disjunct on top level of WHERE is removed
--echo #

create table t1 (a int, b int, index idx(a,b));
insert into t1 values (1,1), (1,2), (2,1), (2,2), (3,3);

create table t2 (c int);
insert into t2 values (5), (2), (3), (4);

select 1 from t1 s1
  where 1 not in (select 1 from t1
                    where ((a = 1 or a = 2) and b = 1) or (b > 5 and b < 1));

select 1 from t1 s1
  where 1 not in (select 1 from t1
                    where ((a = 1 or a = 2) and b = 1) or b = NULL);

select c from t2
  where 2 not in (select 1 from t1
                    where ((a=1 or a=2) and b = 1) or (b > 5 and b < 1));

drop table t1,t2;

--echo #
--echo # End of 10.2 tests
--echo #
