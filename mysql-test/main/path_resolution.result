#
# MDEV-34391 Path resolution
#
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: X | path set: no
#
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT func();
ERROR 42000: FUNCTION func does not exist
USE test;
DROP FUNCTION func;
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: X | path set: yes
#
USE test;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
SELECT func();
func()
Invoke from Db: test, Rt: func
USE test;
DROP FUNCTION func;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: test2 | path set: no
#
USE test;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
CREATE DATABASE test2;
USE test2;
SELECT func();
ERROR 42000: FUNCTION test2.func does not exist
DROP DATABASE test2;
USE test;
DROP FUNCTION func;
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: test2 | path set: yes
#
USE test;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT func();
func()
Invoke from Db: test, Rt: func
DROP DATABASE test2;
USE test;
DROP FUNCTION func;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: X | path set: yes
# lookup in between 2 unqualified functions with exactly the same name in different 2 databases
#
USE test;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
SELECT func();
func()
Invoke from Db: test, Rt: func
SET path 'test2,test';
SELECT func();
func()
Invoke from Db: test2, Rt: func
DROP FUNCTION test2.func;
SELECT func();
func()
Invoke from Db: test, Rt: func
DROP FUNCTION test.func;
SELECT func();
ERROR 42000: FUNCTION func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: test2 | path set: yes
# lookup in between 2 unqualified functions with exactly the same name in different 2 databases
#
USE test;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT func();
func()
Invoke from Db: test, Rt: func
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func';
SELECT func();
func()
Invoke from Db: test2, Rt: func
DROP FUNCTION func;
SELECT func();
func()
Invoke from Db: test, Rt: func
DROP FUNCTION test.func;
SELECT func();
ERROR 42000: FUNCTION test2.func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: X | path set: yes
# to test unqualified function invocation in an unqualified function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func';
USE test;
CREATE FUNCTION func_call_func() RETURNS TEXT RETURN func();
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
USE test;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT func_call_func();
func_call_func()
Invoke from Db: test, Rt: func
DROP FUNCTION test.func;
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
DROP FUNCTION test2.func;
SELECT func_call_func();
ERROR 42000: FUNCTION test.func does not exist
DROP DATABASE test2;
USE test;
DROP FUNCTION func_call_func;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is unqualified
# curr db: test | path set: yes
# to test unqualified function invocation in an unqualified function
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func';
USE test;
CREATE FUNCTION func_call_func() RETURNS TEXT RETURN func();
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func';
SELECT func_call_func();
func_call_func()
Invoke from Db: test, Rt: func
DROP FUNCTION func;
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
DROP FUNCTION test2.func;
SELECT func_call_func();
ERROR 42000: FUNCTION test.func does not exist
DROP DATABASE test2;
USE test;
DROP FUNCTION func_call_func;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: X | path set: no
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: X | path set: yes
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test2 | path set: no
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test2 | path set: yes
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: X | path set: yes
# lookup in between 2 qualified packages function with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
SET path 'test2,test';
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack, Rt: func
DROP PACKAGE BODY test2.pack;
DROP PACKAGE test2.pack;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test2 | path set: yes
# lookup in between 2 qualified packages function with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Pack: pack, Rt: func';
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack, Rt: func
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: X | path set: yes
# to test unqualified function invocation in an qualified package function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_local() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func_local';
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN func_local();
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
USE test;
CREATE FUNCTION func_local() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func_local';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test, Rt: func_local
DROP FUNCTION test.func_local;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
DROP FUNCTION test2.func_local;
SELECT pack.func();
ERROR 42000: FUNCTION test.func_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test | path set: yes
# to test unqualified function invocation in an qualified package function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_local() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func_local';
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN func_local();
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
CREATE FUNCTION func_local() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func_local';
SELECT pack.func();
pack.func()
Invoke from Db: test, Rt: func_local
DROP FUNCTION func_local;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
DROP FUNCTION test2.func_local;
SELECT pack.func();
ERROR 42000: FUNCTION test.func_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: X | path set: yes
# to test qualified package function invocation in an qualified package function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack2
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Pack: pack2, Rt: func';
END;
$$
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN pack2.func();
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
USE test;
CREATE PACKAGE pack2
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack2
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack2, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack2, Rt: func
DROP PACKAGE BODY test.pack2;
DROP PACKAGE test.pack2;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
SELECT pack.func();
ERROR 42000: FUNCTION pack2.func does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test | path set: yes
# to test qualified package function invocation in an qualified package function
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack2
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test2, Pack: pack2, Rt: func';
END;
$$
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN pack2.func();
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
CREATE PACKAGE pack2
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack2
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack2, Rt: func';
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack2, Rt: func
DROP PACKAGE BODY pack2;
DROP PACKAGE pack2;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
SELECT pack.func();
ERROR 42000: FUNCTION pack2.func does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: X | path set: yes
# resolution priority in between qualified package function vs qualified db function resolution
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: pack, Rt: func';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
SET path 'sys,test';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
DROP FUNCTION pack.func;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test | path set: yes
# resolution priority in between qualified package function vs qualified db function resolution
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: pack, Rt: func';
USE test;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
DROP FUNCTION pack.func;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test2 | path set: yes
# resolution priority in between qualified package function vs qualified db function resolution
#
USE test;
CREATE PACKAGE pack
FUNCTION func() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE FUNCTION func() RETURNS TEXT RETURN 'Invoke from Db: pack, Rt: func';
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
SET path 'sys,test';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
DROP FUNCTION pack.func;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE pack;
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: X | path set: yes
# qualified package function invoke internal private function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_prv() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func_prv';
USE test;
CREATE FUNCTION func_prv() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func_prv';
CREATE PACKAGE pack
FUNCTION func_pub() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func_prv() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func_prv';
FUNCTION func_pub() RETURNS TEXT RETURN func_prv();
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func_pub();
pack.func_pub()
Invoke from Db: test, Pack: pack, Rt: func_prv
DROP FUNCTION test2.func_prv;
DROP DATABASE test2;
USE test;
DROP FUNCTION func_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | function | is qualified
# curr db: test2 | path set: yes
# qualified package function invoke internal private function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_prv() RETURNS TEXT RETURN 'Invoke from Db: test2, Rt: func_prv';
USE test;
CREATE FUNCTION func_prv() RETURNS TEXT RETURN 'Invoke from Db: test, Rt: func_prv';
CREATE PACKAGE pack
FUNCTION func_pub() RETURNS TEXT;
END;
$$
CREATE PACKAGE BODY pack
FUNCTION func_prv() RETURNS TEXT RETURN 'Invoke from Db: test, Pack: pack, Rt: func_prv';
FUNCTION func_pub() RETURNS TEXT RETURN func_prv();
END;
$$
USE test2;
SELECT pack.func_pub();
pack.func_pub()
Invoke from Db: test, Pack: pack, Rt: func_prv
DROP FUNCTION func_prv;
DROP DATABASE test2;
USE test;
DROP FUNCTION func_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: X | path set: no
#
USE test;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL proc;
ERROR 3D000: No database selected
USE test;
DROP PROCEDURE proc;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: X | path set: yes
#
USE test;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
USE test;
DROP PROCEDURE proc;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: test2 | path set: no
#
USE test;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
CREATE DATABASE test2;
USE test2;
CALL proc;
ERROR 42000: PROCEDURE test2.proc does not exist
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: test2 | path set: yes
#
USE test;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: X | path set: yes
# lookup in between 2 unqualified procedures with exactly the same name in different 2 databases
#
USE test;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test2, Rt: proc';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
SET path 'test2,test';
CALL proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE test2.proc;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE test.proc;
CALL proc;
ERROR 3D000: No database selected
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: test2 | path set: yes
# lookup in between 2 unqualified procedures with exactly the same name in different 2 databases
#
USE test;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test2, Rt: proc';
CALL proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE proc;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE test.proc;
CALL proc;
ERROR 42000: PROCEDURE test2.proc does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: X | path set: yes
# to test unqualified procedure invocation in an unqualified procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test2, Rt: proc';
USE test;
CREATE PROCEDURE proc_call_proc() CALL proc;
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
USE test;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL proc_call_proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE test.proc;
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE test2.proc;
CALL proc_call_proc;
ERROR 42000: PROCEDURE test.proc does not exist
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_call_proc;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is unqualified
# curr db: test | path set: yes
# to test unqualified procedure invocation in an unqualified procedure
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test2, Rt: proc';
USE test;
CREATE PROCEDURE proc_call_proc() CALL proc;
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
CREATE PROCEDURE proc() SELECT 'Invoke from Db: test, Rt: proc';
CALL proc_call_proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE proc;
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE test2.proc;
CALL proc_call_proc;
ERROR 42000: PROCEDURE test.proc does not exist
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_call_proc;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: X | path set: no
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: X | path set: yes
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test2 | path set: no
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test2 | path set: yes
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: X | path set: yes
# lookup in between 2 qualified packages procedure with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test2, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
SET path 'test2,test';
CALL pack.proc;
Invoke from Db: test2, Pack: pack, Rt: proc
Invoke from Db: test2, Pack: pack, Rt: proc
DROP PACKAGE BODY test2.pack;
DROP PACKAGE test2.pack;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test2 | path set: yes
# lookup in between 2 qualified packages procedure with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test2, Pack: pack, Rt: proc';
END;
$$
CALL pack.proc;
Invoke from Db: test2, Pack: pack, Rt: proc
Invoke from Db: test2, Pack: pack, Rt: proc
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: X | path set: yes
# to test unqualified procedure invocation in an qualified package procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_local() SELECT 'Invoke from Db: test2, Rt: proc_local';
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() CALL proc_local;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
USE test;
CREATE PROCEDURE proc_local() SELECT 'Invoke from Db: test, Rt: proc_local';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test, Rt: proc_local
Invoke from Db: test, Rt: proc_local
DROP PROCEDURE test.proc_local;
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
DROP PROCEDURE test2.proc_local;
CALL pack.proc;
ERROR 42000: PROCEDURE test.proc_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test | path set: yes
# to test unqualified procedure invocation in an qualified package procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_local() SELECT 'Invoke from Db: test2, Rt: proc_local';
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() CALL proc_local;
END;
$$
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
CREATE PROCEDURE proc_local() SELECT 'Invoke from Db: test, Rt: proc_local';
CALL pack.proc;
Invoke from Db: test, Rt: proc_local
Invoke from Db: test, Rt: proc_local
DROP PROCEDURE proc_local;
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
DROP PROCEDURE test2.proc_local;
CALL pack.proc;
ERROR 42000: PROCEDURE test.proc_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: X | path set: yes
# to test qualified package procedure invocation in an qualified package procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2
PROCEDURE proc() SELECT 'Invoke from Db: test2, Pack: pack2, Rt: proc';
END;
$$
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() CALL pack2.proc;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
USE test;
CREATE PACKAGE pack2
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack2, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test, Pack: pack2, Rt: proc
Invoke from Db: test, Pack: pack2, Rt: proc
DROP PACKAGE BODY test.pack2;
DROP PACKAGE test.pack2;
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
CALL pack.proc;
ERROR 42000: PROCEDURE pack2.proc does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test | path set: yes
# to test qualified package procedure invocation in an qualified package procedure
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2
PROCEDURE proc() SELECT 'Invoke from Db: test2, Pack: pack2, Rt: proc';
END;
$$
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() CALL pack2.proc;
END;
$$
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
CREATE PACKAGE pack2
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack2, Rt: proc';
END;
$$
CALL pack.proc;
Invoke from Db: test, Pack: pack2, Rt: proc
Invoke from Db: test, Pack: pack2, Rt: proc
DROP PACKAGE BODY pack2;
DROP PACKAGE pack2;
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
CALL pack.proc;
ERROR 42000: PROCEDURE pack2.proc does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: X | path set: yes
# resolution priority in between qualified package procedure vs qualified db procedure resolution
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: pack, Rt: proc';
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
SET path 'sys,test';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
DROP PROCEDURE pack.proc;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test | path set: yes
# resolution priority in between qualified package procedure vs qualified db procedure resolution
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: pack, Rt: proc';
USE test;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
DROP PROCEDURE pack.proc;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test2 | path set: yes
# resolution priority in between qualified package procedure vs qualified db procedure resolution
#
USE test;
CREATE PACKAGE pack
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE PROCEDURE proc() SELECT 'Invoke from Db: pack, Rt: proc';
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
SET path 'sys,test';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
DROP PROCEDURE pack.proc;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE pack;
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: X | path set: yes
# qualified package procedure invoke internal private procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_prv() SELECT 'Invoke from Db: test2, Rt: proc_prv';
USE test;
CREATE PROCEDURE proc_prv()
SELECT 'Invoke from Db: test, Rt: proc_prv';
CREATE PACKAGE pack
PROCEDURE proc_pub();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc_prv() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc_prv';
PROCEDURE proc_pub() CALL proc_prv;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc_pub;
Invoke from Db: test, Pack: pack, Rt: proc_prv
Invoke from Db: test, Pack: pack, Rt: proc_prv
DROP PROCEDURE test2.proc_prv;
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: DEFAULT | procedure | is qualified
# curr db: test2 | path set: yes
# qualified package procedure invoke internal private procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_prv()
SELECT 'Invoke from Db: test2, Rt: proc_prv';
USE test;
CREATE PROCEDURE proc_prv() SELECT 'Invoke from Db: test, Rt: proc_prv';
CREATE PACKAGE pack
PROCEDURE proc_pub();
END;
$$
CREATE PACKAGE BODY pack
PROCEDURE proc_prv() SELECT 'Invoke from Db: test, Pack: pack, Rt: proc_prv';
PROCEDURE proc_pub() CALL proc_prv;
END;
$$
USE test2;
CALL pack.proc_pub;
Invoke from Db: test, Pack: pack, Rt: proc_prv
Invoke from Db: test, Pack: pack, Rt: proc_prv
DROP PROCEDURE proc_prv;
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: X | path set: no
#
SET sql_mode = ORACLE;
USE test;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT func();
ERROR 42000: FUNCTION func does not exist
USE test;
DROP FUNCTION func;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: X | path set: yes
#
USE test;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
SELECT func();
func()
Invoke from Db: test, Rt: func
USE test;
DROP FUNCTION func;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: test2 | path set: no
#
USE test;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
CREATE DATABASE test2;
USE test2;
SELECT func();
ERROR 42000: FUNCTION test2.func does not exist
DROP DATABASE test2;
USE test;
DROP FUNCTION func;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: test2 | path set: yes
#
USE test;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT func();
func()
Invoke from Db: test, Rt: func
DROP DATABASE test2;
USE test;
DROP FUNCTION func;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: X | path set: yes
# lookup in between 2 unqualified functions with exactly the same name in different 2 databases
#
USE test;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
SELECT func();
func()
Invoke from Db: test, Rt: func
SET path 'test2,test';
SELECT func();
func()
Invoke from Db: test2, Rt: func
DROP FUNCTION test2.func;
SELECT func();
func()
Invoke from Db: test, Rt: func
DROP FUNCTION test.func;
SELECT func();
ERROR 42000: FUNCTION func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: test2 | path set: yes
# lookup in between 2 unqualified functions with exactly the same name in different 2 databases
#
USE test;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT func();
func()
Invoke from Db: test, Rt: func
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func';
END;
$$
SELECT func();
func()
Invoke from Db: test2, Rt: func
DROP FUNCTION func;
SELECT func();
func()
Invoke from Db: test, Rt: func
DROP FUNCTION test.func;
SELECT func();
ERROR 42000: FUNCTION test2.func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: X | path set: yes
# to test unqualified function invocation in an unqualified function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func';
END;
$$
USE test;
CREATE FUNCTION func_call_func()
RETURN TEXT AS
BEGIN
RETURN func();
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
USE test;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT func_call_func();
func_call_func()
Invoke from Db: test, Rt: func
DROP FUNCTION test.func;
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
DROP FUNCTION test2.func;
SELECT func_call_func();
ERROR 42000: FUNCTION test.func does not exist
DROP DATABASE test2;
USE test;
DROP FUNCTION func_call_func;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is unqualified
# curr db: test | path set: yes
# to test unqualified function invocation in an unqualified function
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func';
END;
$$
USE test;
CREATE FUNCTION func_call_func()
RETURN TEXT AS
BEGIN
RETURN func();
END;
$$
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func';
END;
$$
SELECT func_call_func();
func_call_func()
Invoke from Db: test, Rt: func
DROP FUNCTION func;
SELECT func_call_func();
func_call_func()
Invoke from Db: test2, Rt: func
DROP FUNCTION test2.func;
SELECT func_call_func();
ERROR 42000: FUNCTION test.func does not exist
DROP DATABASE test2;
USE test;
DROP FUNCTION func_call_func;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: X | path set: no
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: ORACLE | function | is qualified
# curr db: X | path set: yes
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test2 | path set: no
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test2 | path set: yes
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: X | path set: yes
# lookup in between 2 qualified packages function with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
SET path 'test2,test';
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack, Rt: func
DROP PACKAGE BODY test2.pack;
DROP PACKAGE test2.pack;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test2 | path set: yes
# lookup in between 2 qualified packages function with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Pack: pack, Rt: func';
END;
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack, Rt: func
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: X | path set: yes
# to test unqualified function invocation in an qualified package function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_local()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func_local';
END;
$$
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN func_local();
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
USE test;
CREATE FUNCTION func_local()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func_local';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test, Rt: func_local
DROP FUNCTION test.func_local;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
DROP FUNCTION test2.func_local;
SELECT pack.func();
ERROR 42000: FUNCTION test.func_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test | path set: yes
# to test unqualified function invocation in an qualified package function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_local()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func_local';
END;
$$
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN func_local();
END;
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
CREATE FUNCTION func_local()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func_local';
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test, Rt: func_local
DROP FUNCTION func_local;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Rt: func_local
DROP FUNCTION test2.func_local;
SELECT pack.func();
ERROR 42000: FUNCTION test.func_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: X | path set: yes
# to test qualified package function invocation in an qualified package function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2 AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack2 AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Pack: pack2, Rt: func';
END;
END;
$$
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN pack2.func();
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
USE test;
CREATE PACKAGE pack2 AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack2 AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack2, Rt: func';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack2, Rt: func
DROP PACKAGE BODY test.pack2;
DROP PACKAGE test.pack2;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
SELECT pack.func();
ERROR 42000: FUNCTION pack2.func does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test | path set: yes
# to test qualified package function invocation in an qualified package function
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2 AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack2 AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Pack: pack2, Rt: func';
END;
END;
$$
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN pack2.func();
END;
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
CREATE PACKAGE pack2 AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack2 AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack2, Rt: func';
END;
END;
$$
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack2, Rt: func
DROP PACKAGE BODY pack2;
DROP PACKAGE pack2;
SELECT pack.func();
pack.func()
Invoke from Db: test2, Pack: pack2, Rt: func
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
SELECT pack.func();
ERROR 42000: FUNCTION pack2.func does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: X | path set: yes
# resolution priority in between qualified package function vs qualified db function resolution
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: pack, Rt: func';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
SET path 'sys,test';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
DROP FUNCTION pack.func;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test | path set: yes
# resolution priority in between qualified package function vs qualified db function resolution
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: pack, Rt: func';
END;
$$
USE test;
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
DROP FUNCTION pack.func;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test2 | path set: yes
# resolution priority in between qualified package function vs qualified db function resolution
#
USE test;
CREATE PACKAGE pack AS
FUNCTION func() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func';
END;
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE FUNCTION func()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: pack, Rt: func';
END;
$$
CREATE DATABASE test2;
USE test2;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
SET path 'sys,test';
SELECT pack.func();
pack.func()
Invoke from Db: test, Pack: pack, Rt: func
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
SELECT pack.func();
pack.func()
Invoke from Db: pack, Rt: func
DROP FUNCTION pack.func;
SELECT pack.func();
ERROR 42000: FUNCTION pack.func does not exist
DROP DATABASE pack;
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: X | path set: yes
# qualified package function invoke internal private function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_prv()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func_prv';
END;
$$
USE test;
CREATE FUNCTION func_prv()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func_prv';
END;
$$
CREATE PACKAGE pack AS
FUNCTION func_pub() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func_prv() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func_prv';
END;
FUNCTION func_pub() RETURN TEXT AS
BEGIN
RETURN func_prv();
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SELECT pack.func_pub();
pack.func_pub()
Invoke from Db: test, Pack: pack, Rt: func_prv
DROP FUNCTION test2.func_prv;
DROP DATABASE test2;
USE test;
DROP FUNCTION func_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | function | is qualified
# curr db: test2 | path set: yes
# qualified package function invoke internal private function
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE FUNCTION func_prv()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test2, Rt: func_prv';
END;
$$
USE test;
CREATE FUNCTION func_prv()
RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Rt: func_prv';
END;
$$
CREATE PACKAGE pack AS
FUNCTION func_pub() RETURN TEXT;
END;
$$
CREATE PACKAGE BODY pack AS
FUNCTION func_prv() RETURN TEXT AS
BEGIN
RETURN 'Invoke from Db: test, Pack: pack, Rt: func_prv';
END;
FUNCTION func_pub() RETURN TEXT AS
BEGIN
RETURN func_prv();
END;
END;
$$
USE test2;
SELECT pack.func_pub();
pack.func_pub()
Invoke from Db: test, Pack: pack, Rt: func_prv
DROP FUNCTION func_prv;
DROP DATABASE test2;
USE test;
DROP FUNCTION func_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: X | path set: no
#
USE test;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL proc;
ERROR 3D000: No database selected
USE test;
DROP PROCEDURE proc;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: X | path set: yes
#
USE test;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
USE test;
DROP PROCEDURE proc;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: test2 | path set: no
#
USE test;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
CREATE DATABASE test2;
USE test2;
CALL proc;
ERROR 42000: PROCEDURE test2.proc does not exist
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: test2 | path set: yes
#
USE test;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: X | path set: yes
# lookup in between 2 unqualified procedures with exactly the same name in different 2 databases
#
USE test;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
SET path 'test2,test';
CALL proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE test2.proc;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE test.proc;
CALL proc;
ERROR 3D000: No database selected
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: test2 | path set: yes
# lookup in between 2 unqualified procedures with exactly the same name in different 2 databases
#
USE test;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc';
END;
$$
CALL proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE proc;
CALL proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE test.proc;
CALL proc;
ERROR 42000: PROCEDURE test2.proc does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: X | path set: yes
# to test unqualified procedure invocation in an unqualified procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc';
END;
$$
USE test;
CREATE PROCEDURE proc_call_proc() AS
BEGIN
CALL proc;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
USE test;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL proc_call_proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE test.proc;
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE test2.proc;
CALL proc_call_proc;
ERROR 42000: PROCEDURE test.proc does not exist
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_call_proc;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is unqualified
# curr db: test | path set: yes
# to test unqualified procedure invocation in an unqualified procedure
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc';
END;
$$
USE test;
CREATE PROCEDURE proc_call_proc() AS
BEGIN
CALL proc;
END;
$$
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc';
END;
$$
CALL proc_call_proc;
Invoke from Db: test, Rt: proc
Invoke from Db: test, Rt: proc
DROP PROCEDURE proc;
CALL proc_call_proc;
Invoke from Db: test2, Rt: proc
Invoke from Db: test2, Rt: proc
DROP PROCEDURE test2.proc;
CALL proc_call_proc;
ERROR 42000: PROCEDURE test.proc does not exist
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_call_proc;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: X | path set: no
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: X | path set: yes
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'sys,test';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test2 | path set: no
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test2 | path set: yes
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: X | path set: yes
# lookup in between 2 qualified packages procedure with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
SET path 'test,test2';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
SET path 'test2,test';
CALL pack.proc;
Invoke from Db: test2, Pack: pack, Rt: proc
Invoke from Db: test2, Pack: pack, Rt: proc
DROP PACKAGE BODY test2.pack;
DROP PACKAGE test2.pack;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test2 | path set: yes
# lookup in between 2 qualified packages procedure with exactly the same name in different 2 databases
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
SET path 'sys,test';
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Pack: pack, Rt: proc';
END;
END;
$$
CALL pack.proc;
Invoke from Db: test2, Pack: pack, Rt: proc
Invoke from Db: test2, Pack: pack, Rt: proc
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: X | path set: yes
# to test unqualified procedure invocation in an qualified package procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_local() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc_local';
END;
$$
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
CALL proc_local;
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
USE test;
CREATE PROCEDURE proc_local() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc_local';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test, Rt: proc_local
Invoke from Db: test, Rt: proc_local
DROP PROCEDURE test.proc_local;
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
DROP PROCEDURE test2.proc_local;
CALL pack.proc;
ERROR 42000: PROCEDURE test.proc_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test | path set: yes
# to test unqualified procedure invocation in an qualified package procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_local() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc_local';
END;
$$
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
CALL proc_local;
END;
END;
$$
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
CREATE PROCEDURE proc_local() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc_local';
END;
$$
CALL pack.proc;
Invoke from Db: test, Rt: proc_local
Invoke from Db: test, Rt: proc_local
DROP PROCEDURE proc_local;
CALL pack.proc;
Invoke from Db: test2, Rt: proc_local
Invoke from Db: test2, Rt: proc_local
DROP PROCEDURE test2.proc_local;
CALL pack.proc;
ERROR 42000: PROCEDURE test.proc_local does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: X | path set: yes
# to test qualified package procedure invocation in an qualified package procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2 AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2 AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Pack: pack2, Rt: proc';
END;
END;
$$
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
CALL pack2.proc;
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
USE test;
CREATE PACKAGE pack2 AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2 AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack2, Rt: proc';
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: test, Pack: pack2, Rt: proc
Invoke from Db: test, Pack: pack2, Rt: proc
DROP PACKAGE BODY test.pack2;
DROP PACKAGE test.pack2;
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
CALL pack.proc;
ERROR 42000: PROCEDURE pack2.proc does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test | path set: yes
# to test qualified package procedure invocation in an qualified package procedure
#
SET path 'sys,test2';
CREATE DATABASE test2;
USE test2;
CREATE PACKAGE pack2 AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2 AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test2, Pack: pack2, Rt: proc';
END;
END;
$$
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
CALL pack2.proc;
END;
END;
$$
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
CREATE PACKAGE pack2 AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack2 AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack2, Rt: proc';
END;
END;
$$
CALL pack.proc;
Invoke from Db: test, Pack: pack2, Rt: proc
Invoke from Db: test, Pack: pack2, Rt: proc
DROP PACKAGE BODY pack2;
DROP PACKAGE pack2;
CALL pack.proc;
Invoke from Db: test2, Pack: pack2, Rt: proc
Invoke from Db: test2, Pack: pack2, Rt: proc
DROP PACKAGE BODY test2.pack2;
DROP PACKAGE test2.pack2;
CALL pack.proc;
ERROR 42000: PROCEDURE pack2.proc does not exist
DROP DATABASE test2;
USE test;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: X | path set: yes
# resolution priority in between qualified package procedure vs qualified db procedure resolution
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: pack, Rt: proc';
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
SET path 'sys,test';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
DROP PROCEDURE pack.proc;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test | path set: yes
# resolution priority in between qualified package procedure vs qualified db procedure resolution
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: pack, Rt: proc';
END;
$$
USE test;
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
DROP PROCEDURE pack.proc;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE pack;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test2 | path set: yes
# resolution priority in between qualified package procedure vs qualified db procedure resolution
#
USE test;
CREATE PACKAGE pack AS
PROCEDURE proc();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc';
END;
END;
$$
CREATE DATABASE pack;
USE pack;
CREATE PROCEDURE proc() AS
BEGIN
SELECT 'Invoke from Db: pack, Rt: proc';
END;
$$
CREATE DATABASE test2;
USE test2;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
SET path 'sys,test';
CALL pack.proc;
Invoke from Db: test, Pack: pack, Rt: proc
Invoke from Db: test, Pack: pack, Rt: proc
DROP PACKAGE BODY test.pack;
DROP PACKAGE test.pack;
CALL pack.proc;
Invoke from Db: pack, Rt: proc
Invoke from Db: pack, Rt: proc
DROP PROCEDURE pack.proc;
CALL pack.proc;
ERROR 42000: PROCEDURE pack.proc does not exist
DROP DATABASE pack;
DROP DATABASE test2;
USE test;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: X | path set: yes
# qualified package procedure invoke internal private procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_prv() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc_prv';
END;
$$
USE test;
CREATE PROCEDURE proc_prv() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc_prv';
END;
$$
CREATE PACKAGE pack AS
PROCEDURE proc_pub();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc_prv() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc_prv';
END;
PROCEDURE proc_pub() AS
BEGIN
CALL proc_prv;
END;
END;
$$
CREATE DATABASE deselect_db;
USE deselect_db;
DROP DATABASE deselect_db;
CALL pack.proc_pub;
Invoke from Db: test, Pack: pack, Rt: proc_prv
Invoke from Db: test, Pack: pack, Rt: proc_prv
DROP PROCEDURE test2.proc_prv;
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# sql_mode: ORACLE | procedure | is qualified
# curr db: test2 | path set: yes
# qualified package procedure invoke internal private procedure
#
SET path 'test,test2';
CREATE DATABASE test2;
USE test2;
CREATE PROCEDURE proc_prv() AS
BEGIN
SELECT 'Invoke from Db: test2, Rt: proc_prv';
END;
$$
USE test;
CREATE PROCEDURE proc_prv() AS
BEGIN
SELECT 'Invoke from Db: test, Rt: proc_prv';
END;
$$
CREATE PACKAGE pack AS
PROCEDURE proc_pub();
END;
$$
CREATE PACKAGE BODY pack AS
PROCEDURE proc_prv() AS
BEGIN
SELECT 'Invoke from Db: test, Pack: pack, Rt: proc_prv';
END;
PROCEDURE proc_pub() AS
BEGIN
CALL proc_prv;
END;
END;
$$
USE test2;
CALL pack.proc_pub;
Invoke from Db: test, Pack: pack, Rt: proc_prv
Invoke from Db: test, Pack: pack, Rt: proc_prv
DROP PROCEDURE proc_prv;
DROP DATABASE test2;
USE test;
DROP PROCEDURE proc_prv;
DROP PACKAGE BODY pack;
DROP PACKAGE pack;
SET @@path = DEFAULT;
#
# End of 11.8 tests
#
