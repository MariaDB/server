set use_sort_nest=1;
CREATE TABLE t0 (a int);
INSERT INTO t0 SELECT seq-1 from seq_1_to_10;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 SELECT a, a from t0 where a <5;
CREATE TABLE t2 as SELECT * from t1 where a < 5;
CREATE TABLE t3(a int, b int, c int, key(a));
INSERT INTO t3  SELECT seq-1, seq-1, seq-1 from seq_1_to_100;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;
#
# sort nest on (t2,t1)
# ref(sort-nest.b) access on table t3
#
EXPLAIN SELECT t1.a, t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a=t2.a AND t2.b=t3.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	5	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	5	Using filesort
1	SIMPLE	t3	ref	a	a	5	sort-nest.b	1	Using index
EXPLAIN FORMAT=JSON SELECT t1.a, t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a=t2.a AND t2.b=t3.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 5,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 5,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL",
      "attached_condition": "t2.a = t1.a"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b desc, `sort-nest`.b desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 5,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ref",
      "possible_keys": ["a"],
      "key": "a",
      "key_length": "5",
      "used_key_parts": ["a"],
      "ref": ["sort-nest.b"],
      "rows": 1,
      "filtered": 100,
      "using_index": true
    }
  }
}
SELECT t1.a, t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a=t2.a AND t2.b=t3.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5;
a	b	b	a
4	4	4	4
3	3	3	3
2	2	2	2
1	1	1	1
0	0	0	0
DROP TABLE t0,t1,t2,t3;
CREATE TABLE t1(a int, b int);
INSERT INTO t1 SELECT seq-1, seq-1 from seq_1_to_100;
CREATE TABLE t2(a int, b int);
INSERT INTO t2(a,b) VALUES (1,1), (2,2);
INSERT INTO t2   SELECT seq-1, seq-1 from seq_1_to_100;
CREATE TABLE t3(a int, b int);
INSERT INTO t3 SELECT seq-1, seq-1 from seq_1_to_1000;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;
CREATE FUNCTION f1(a int) RETURNS INT
BEGIN
DECLARE b INT DEFAULT 0;
RETURN a + b;
END|
Covering 3 table joins

# sorting on table t2
# t2.a > 95 would be attached to table t2
# t1.b=t2.a would be attached to table t1;
# t3.a= sort-nest.b would be attached to table t3

EXPLAIN SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND  t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using where; Using filesort
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND  t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "read_sorted_file": {
      "filesort": {
        "sort_key": "t2.b",
        "table": {
          "table_name": "t2",
          "access_type": "ALL",
          "rows": 102,
          "filtered": 4.6875,
          "attached_condition": "t2.a > 95"
        }
      }
    },
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 4.6875,
      "attached_condition": "t1.a = t2.a"
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.a = t1.b"
    }
  }
}
SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND  t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b
LIMIT 5;
a	b	a	b	a	b
96	96	96	96	96	96
97	97	97	97	97	97
98	98	98	98	98	98
99	99	99	99	99	99
# {t1,t2} part of the nest
# t1.a > 95 would be attached to table t1
# t1.b=t2.a would be attached to table t2;
# t3.a= sort-nest.b would be attached to table t3

ALTER TABLE t2 ADD KEY(a);
EXPLAIN SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
1	SIMPLE	t2	ref	a	a	5	test.t1.a	1	
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 4.6875,
      "attached_condition": "t1.a > 95 and t1.a is not null"
    },
    "table": {
      "table_name": "t2",
      "access_type": "ref",
      "possible_keys": ["a"],
      "key": "a",
      "key_length": "5",
      "used_key_parts": ["a"],
      "ref": ["test.t1.a"],
      "rows": 1,
      "filtered": 100
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.a = `sort-nest`.b"
    }
  }
}
SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b
LIMIT 5;
a	b	a	b	a	b
96	96	96	96	96	96
97	97	97	97	97	97
98	98	98	98	98	98
99	99	99	99	99	99
ALTER TABLE t2 DROP KEY a;

# {t1,t2} part of the sort nest
# (t2.a < 2 or t1.b > 98) would be attached to table t2

EXPLAIN SELECT * FROM t1,t2,t3
WHERE (t3.a < 2 and t2.a < 2) OR (t1.b > 98 and t3.b > 98)
ORDER BY t1.a, t2.b
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE (t3.a < 2 and t2.a < 2) OR (t1.b > 98 and t3.b > 98)
ORDER BY t1.a, t2.b
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 102,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "1Kb",
      "join_type": "BNL",
      "attached_condition": "t2.a < 2 or t1.b > 98"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.a, `sort-nest`.b",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.a < 2 and `sort-nest`.a < 2 or `sort-nest`.b > 98 and t3.b > 98"
    }
  }
}
SELECT * FROM t1,t2,t3
WHERE (t3.a < 2 and t2.a < 2) OR (t1.b > 98 and t3.b > 98)
ORDER BY t1.a, t2.b
LIMIT 5;
a	b	a	b	a	b
0	0	1	1	0	0
0	0	1	1	1	1
1	1	1	1	0	0
1	1	1	1	1	1
2	2	1	1	0	0

# {t1,t2} part of the nest
# t2.a < 2 or f1(t1.b) attached to table t2
# t1.b=t2.a would be attached to table t2;

EXPLAIN SELECT * FROM t1,t2,t3
WHERE (t3.a<2  AND t2.a <2) OR (f1(t1.b) > 98 AND t3.b > 98)
ORDER BY t1.a,t2.b
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE (t3.a<2  AND t2.a <2) OR (f1(t1.b) > 98 AND t3.b > 98)
ORDER BY t1.a,t2.b
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 102,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "1Kb",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.a, `sort-nest`.b",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.a < 2 and `sort-nest`.a < 2 or f1(`sort-nest`.b) > 98 and t3.b > 98"
    }
  }
}
SELECT * FROM t1,t2,t3
WHERE (t3.a<2  AND t2.a <2) OR (f1(t1.b) > 98 AND t3.b > 98)
ORDER BY t1.a,t2.b
LIMIT 5;
a	b	a	b	a	b
0	0	0	0	0	0
0	0	0	0	1	1
0	0	1	1	0	0
0	0	1	1	1	1
0	0	1	1	0	0
#
# Removing constant from the order by clause
#
EXPLAIN SELECT * FROM t1,t2
WHERE t1.a > 95 AND t1.a=t2.a
ORDER BY t2.a
LIMIT 4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where; Using filesort
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using where
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2
WHERE t1.a > 95 AND t1.a=t2.a
ORDER BY t2.a
LIMIT 4;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "read_sorted_file": {
      "filesort": {
        "sort_key": "t2.a",
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "rows": 100,
          "filtered": 4.6875,
          "attached_condition": "t1.a > 95"
        }
      }
    },
    "table": {
      "table_name": "t2",
      "access_type": "ALL",
      "rows": 102,
      "filtered": 4.6875,
      "attached_condition": "t2.a = t1.a"
    }
  }
}
SELECT * FROM t1,t2
WHERE t1.a > 95 AND t1.a=t2.a
ORDER BY t2.a
LIMIT 4;
a	b	a	b
96	96	96	96
97	97	97	97
98	98	98	98
99	99	99	99
EXPLAIN SELECT * FROM t1,t2
WHERE t1.a > 95  and t1.a=t2.a
ORDER BY 1+2,t2.a limit 4;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where; Using filesort
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using where
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2
WHERE t1.a > 95  and t1.a=t2.a
ORDER BY 1+2,t2.a limit 4;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "read_sorted_file": {
      "filesort": {
        "sort_key": "t2.a",
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "rows": 100,
          "filtered": 4.6875,
          "attached_condition": "t1.a > 95"
        }
      }
    },
    "table": {
      "table_name": "t2",
      "access_type": "ALL",
      "rows": 102,
      "filtered": 4.6875,
      "attached_condition": "t2.a = t1.a"
    }
  }
}
SELECT * FROM t1,t2
WHERE t1.a > 95  and t1.a=t2.a
ORDER BY 1+2,t2.a limit 4;
a	b	a	b
96	96	96	96
97	97	97	97
98	98	98	98
99	99	99	99
#
# Equality propagation, both the queries should use a
# sort nest on {t1,t2}
#
EXPLAIN SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t1.b DESC, t2.a DESC limit 3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t1.b DESC, t2.a DESC limit 3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 102,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "1Kb",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.b = `sort-nest`.b"
    }
  }
}
SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t1.b DESC, t2.a DESC limit 3;
b	a	b	a
99	99	99	99
99	98	99	99
99	97	99	99
EXPLAIN SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t3.b DESC, t2.a DESC
LIMIT 3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t3.b DESC, t2.a DESC
LIMIT 3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 102,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "1Kb",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.b = `sort-nest`.b"
    }
  }
}
SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t3.b DESC, t2.a DESC
LIMIT 3;
b	a	b	a
99	99	99	99
99	98	99	99
99	97	99	99
#
# Equality propagation also for arguments of expressions,
# the plan should use a sort nest on {t1,t2}
#
EXPLAIN SELECT t3.b,t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t3.b + 1 DESC, t2.a DESC
LIMIT 3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT t3.b,t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t3.b + 1 DESC, t2.a DESC
LIMIT 3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 102,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "1Kb",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b + 1 desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.b = `sort-nest`.b"
    }
  }
}
SELECT t3.b,t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.b=t3.b
ORDER BY t3.b + 1 DESC, t2.a DESC
LIMIT 3;
b	a	b	a
99	99	99	99
99	98	99	99
99	97	99	99
#
# Rows for the sort-nest should be the cardinality of the join of
# inner tables of the sort-nest
#
# Rows for sort nest would be 9894 here
ALTER TABLE t1 ADD KEY(a);
EXPLAIN SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.a > 5 and t1.b=t3.b
ORDER BY t1.b DESC, t2.a DESC
LIMIT 3;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	a	NULL	NULL	NULL	100	Using where
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
SELECT t3.b, t2.a, t1.b, t1.a
FROM t1,t2,t3
WHERE t1.a > 5 and t1.b=t3.b
ORDER BY t1.b DESC, t2.a DESC
LIMIT 3;
b	a	b	a
99	99	99	99
99	98	99	99
99	97	99	99
ALTER TABLE t1 DROP KEY a;
#
# With having clause we can't have a sort-nest
#
EXPLAIN SELECT * FROM t1,t2,t3
WHERE t1.a=t2.a AND t1.b = t3.a
HAVING t1.a > 95
ORDER BY t2.b,t1.b
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using temporary; Using filesort
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where; Using join buffer (incremental, BNL join)
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE t1.a=t2.a AND t1.b = t3.a
HAVING t1.a > 95
ORDER BY t2.b,t1.b
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "having_condition": "t1.a > 95",
    "filesort": {
      "sort_key": "t2.b, t1.b",
      "temporary_table": {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "rows": 100,
          "filtered": 100
        },
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "rows": 102,
            "filtered": 100
          },
          "buffer_type": "flat",
          "buffer_size": "1Kb",
          "join_type": "BNL",
          "attached_condition": "t2.a = t1.a"
        },
        "block-nl-join": {
          "table": {
            "table_name": "t3",
            "access_type": "ALL",
            "rows": 1000,
            "filtered": 100
          },
          "buffer_type": "incremental",
          "buffer_size": "149Kb",
          "join_type": "BNL",
          "attached_condition": "t3.a = t1.b"
        }
      }
    }
  }
}
SELECT * FROM t1,t2,t3
WHERE t1.a=t2.a AND t1.b = t3.a
HAVING t1.a > 95
ORDER BY t2.b,t1.b
LIMIT 5;
a	b	a	b	a	b
96	96	96	96	96	96
97	97	97	97	97	97
98	98	98	98	98	98
99	99	99	99	99	99
EXPLAIN SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b,t1.b
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	100	Using where
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	102	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b,t1.b
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 100,
      "filtered": 4.6875,
      "attached_condition": "t1.a > 95"
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 102,
        "filtered": 4.6875
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL",
      "attached_condition": "t2.a = t1.a"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b, `sort-nest`.b",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.a = `sort-nest`.b"
    }
  }
}
SELECT * FROM t1,t2,t3
WHERE t1.a > 95 AND t1.a=t2.a AND t1.b = t3.a
ORDER BY t2.b,t1.b
LIMIT 5;
a	b	a	b	a	b
96	96	96	96	96	96
97	97	97	97	97	97
98	98	98	98	98	98
99	99	99	99	99	99
#
# Selectivity estimates taken into account for sort-nest{t1,t2}
#
CREATE INDEX idx1 ON t1(b);
CREATE INDEX idx2 ON t2(a);
CREATE INDEX idx3 ON t3(b);
EXPLAIN SELECT * from t1,t2,t3
WHERE t1.a=t2.a AND t1.b = t3.a AND t1.b < 5 AND t3.b < 900
ORDER BY t2.b
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx1	idx1	5	NULL	3	Using index condition; Using where
1	SIMPLE	t2	ref	idx2	idx2	5	test.t1.a	1	
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	idx3	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT * from t1,t2,t3
WHERE t1.a=t2.a AND t1.b = t3.a AND t1.b < 5 AND t3.b < 900
ORDER BY t2.b
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "range",
      "possible_keys": ["idx1"],
      "key": "idx1",
      "key_length": "5",
      "used_key_parts": ["b"],
      "rows": 3,
      "filtered": 100,
      "index_condition": "t1.b < 5",
      "attached_condition": "t1.a is not null"
    },
    "table": {
      "table_name": "t2",
      "access_type": "ref",
      "possible_keys": ["idx2"],
      "key": "idx2",
      "key_length": "5",
      "used_key_parts": ["a"],
      "ref": ["test.t1.a"],
      "rows": 1,
      "filtered": 100
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "possible_keys": ["idx3"],
      "rows": 1000,
      "filtered": 0.6953,
      "attached_condition": "t3.a = `sort-nest`.b and t3.b < 900"
    }
  }
}
SELECT * from t1,t2,t3
WHERE t1.a=t2.a AND t1.b = t3.a AND t1.b < 5 AND t3.b < 900
ORDER BY t2.b
LIMIT 5;
a	b	a	b	a	b
0	0	0	0	0	0
1	1	1	1	1	1
1	1	1	1	1	1
2	2	2	2	2	2
2	2	2	2	2	2
DROP INDEX idx1 ON t1;
DROP INDEX idx2 ON t2;
DROP INDEX idx3 ON t3;
DROP TABLE t1,t2,t3;
DROP FUNCTION f1;
Derived table inside a sort-nest
CREATE TABLE t1 (f1 varchar(1), f2 varchar(1), KEY (f2));
INSERT INTO t1 VALUES
('r','x'), ('x','x'), ('x','x'), ('r','x'), ('x','x');
CREATE TABLE t2 (f1 varchar(1), f2 varchar(1));
INSERT INTO t2 VALUES ('s','x');
CREATE TABLE t3 (f1 varchar(1), f2 varchar(1), KEY (f2));
INSERT INTO t3 VALUES
(NULL,'x'), (NULL,'f'), ('t','x'), (NULL,'j'), ('g','x');
CREATE TABLE t4 (f1 int, f2 varchar(1), KEY (f2,f1)) ;
INSERT INTO t4 VALUES (2,'x'), (1,'x');
EXPLAIN SELECT t.f1 as f
FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1
ORDER BY f LIMIT 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	index	f2	f2	9	NULL	2	Using where; Using index
1	PRIMARY	<derived2>	ref	key1	key1	4	test.t4.f2	2	
1	PRIMARY	<sort-nest>	ALL	NULL	NULL	NULL	NULL	4	Using filesort
1	PRIMARY	t3	ref	f2	f2	4	sort-nest.f2	2	Using index
2	DERIVED	t2	system	NULL	NULL	NULL	NULL	1	Using temporary
2	DERIVED	t1	ALL	f2	NULL	NULL	NULL	5	Using where
EXPLAIN FORMAT=JSON SELECT t.f1 as f
FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1
ORDER BY f LIMIT 10;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t4",
      "access_type": "index",
      "possible_keys": ["f2"],
      "key": "f2",
      "key_length": "9",
      "used_key_parts": ["f2", "f1"],
      "rows": 2,
      "filtered": 100,
      "attached_condition": "t4.f2 is not null",
      "using_index": true
    },
    "table": {
      "table_name": "<derived2>",
      "access_type": "ref",
      "possible_keys": ["key1"],
      "key": "key1",
      "key_length": "4",
      "used_key_parts": ["f1"],
      "ref": ["test.t4.f2"],
      "rows": 2,
      "filtered": 100,
      "materialized": {
        "query_block": {
          "select_id": 2,
          "temporary_table": {
            "table": {
              "table_name": "t2",
              "access_type": "system",
              "rows": 1,
              "filtered": 100
            },
            "table": {
              "table_name": "t1",
              "access_type": "ALL",
              "possible_keys": ["f2"],
              "rows": 5,
              "filtered": 100,
              "attached_condition": "t1.f2 = 'x'"
            }
          }
        }
      }
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.f1",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 4,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ref",
      "possible_keys": ["f2"],
      "key": "f2",
      "key_length": "4",
      "used_key_parts": ["f2"],
      "ref": ["sort-nest.f2"],
      "rows": 2,
      "filtered": 100,
      "using_index": true
    }
  }
}
SELECT t.f1 as f
FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1
ORDER BY f LIMIT 10;
f
x
x
x
x
x
x
should use the sort-nest too like the query above
EXPLAIN SELECT t4.f1 as f, t.f1 as g
FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1 ORDER BY f,g
LIMIT 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t4	index	f2	f2	9	NULL	2	Using where; Using index
1	PRIMARY	<derived2>	ref	key1	key1	4	test.t4.f2	2	
1	PRIMARY	<sort-nest>	ALL	NULL	NULL	NULL	NULL	4	Using filesort
1	PRIMARY	t3	ref	f2	f2	4	sort-nest.f2	2	Using index
2	DERIVED	t2	system	NULL	NULL	NULL	NULL	1	Using temporary
2	DERIVED	t1	ALL	f2	NULL	NULL	NULL	5	Using where
EXPLAIN FORMAT=JSON SELECT t4.f1 as f, t.f1 as g
FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1 ORDER BY f,g
LIMIT 10;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t4",
      "access_type": "index",
      "possible_keys": ["f2"],
      "key": "f2",
      "key_length": "9",
      "used_key_parts": ["f2", "f1"],
      "rows": 2,
      "filtered": 100,
      "attached_condition": "t4.f2 is not null",
      "using_index": true
    },
    "table": {
      "table_name": "<derived2>",
      "access_type": "ref",
      "possible_keys": ["key1"],
      "key": "key1",
      "key_length": "4",
      "used_key_parts": ["f1"],
      "ref": ["test.t4.f2"],
      "rows": 2,
      "filtered": 100,
      "materialized": {
        "query_block": {
          "select_id": 2,
          "temporary_table": {
            "table": {
              "table_name": "t2",
              "access_type": "system",
              "rows": 1,
              "filtered": 100
            },
            "table": {
              "table_name": "t1",
              "access_type": "ALL",
              "possible_keys": ["f2"],
              "rows": 5,
              "filtered": 100,
              "attached_condition": "t1.f2 = 'x'"
            }
          }
        }
      }
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.f1, `sort-nest`.f1",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 4,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ref",
      "possible_keys": ["f2"],
      "key": "f2",
      "key_length": "4",
      "used_key_parts": ["f2"],
      "ref": ["sort-nest.f2"],
      "rows": 2,
      "filtered": 100,
      "using_index": true
    }
  }
}
SELECT t4.f1 as f, t.f1 as g
FROM (SELECT DISTINCT t1.* FROM t1,t2 WHERE t2.f2 = t1.f2) t,t3,t4
WHERE t4.f2 = t3.f2  AND t4.f2 = t.f1 ORDER BY f,g
LIMIT 10;
f	g
1	x
1	x
1	x
2	x
2	x
2	x
DROP TABLE t1,t2,t3,t4;
views inside a sort-nest
CREATE TABLE t0 (x int);
CREATE TABLE t1 (a int);
CREATE TABLE t2 (b int, c int default 0);
INSERT t0 (x) VALUES (0),(10);
INSERT t1 (a) VALUES (1), (2);
INSERT t2 (b) VALUES (1), (2);
CREATE VIEW v1 as SELECT t2.b,t2.c FROM t1, t2
WHERE t1.a=t2.b and t2.b < 3 WITH CHECK OPTION;
EXPLAIN SELECT * FROM v1,t0
WHERE b<3
ORDER BY x,b DESC
LIMIT 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	2	Using where
1	SIMPLE	t0	ALL	NULL	NULL	NULL	NULL	2	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	2	Using where
EXPLAIN FORMAT=JSON SELECT * FROM v1,t0
WHERE b<3
ORDER BY x,b DESC
LIMIT 2;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 2,
      "filtered": 100,
      "attached_condition": "t1.a < 3 and t1.a < 3"
    },
    "block-nl-join": {
      "table": {
        "table_name": "t0",
        "access_type": "ALL",
        "rows": 2,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "65",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.x, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t2",
      "access_type": "ALL",
      "rows": 2,
      "filtered": 100,
      "attached_condition": "t2.b = `sort-nest`.a"
    }
  }
}
SELECT * FROM v1,t0
WHERE b<3
ORDER BY x,b DESC
LIMIT 2;
b	c	x
2	0	0
1	0	0
DROP TABLE t0,t1,t2;
DROP VIEW v1;
# Primary key considered as the key that could achieve ordering
CREATE TABLE t1 (id char(32) NOT NULL primary key);
INSERT INTO t1 VALUES (0), (1), (2), (3), (4), (5), (6), (7), (8), (9);
CREATE TABLE t2 (id char(32) NOT NULL primary key);
INSERT INTO t2 VALUES (0), (1), (2), (3);
EXPLAIN SELECT t1.id
FROM t1 INNER JOIN t2 ON t1.id=t2.id
ORDER BY t2.id LIMIT 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	index	PRIMARY	PRIMARY	32	NULL	2	Using index
1	SIMPLE	t1	eq_ref	PRIMARY	PRIMARY	32	test.t2.id	1	Using index
EXPLAIN FORMAT=JSON SELECT t1.id
FROM t1 INNER JOIN t2 ON t1.id=t2.id
ORDER BY t2.id LIMIT 2;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t2",
      "access_type": "index",
      "possible_keys": ["PRIMARY"],
      "key": "PRIMARY",
      "key_length": "32",
      "used_key_parts": ["id"],
      "rows": 2,
      "filtered": 100,
      "using_index": true
    },
    "table": {
      "table_name": "t1",
      "access_type": "eq_ref",
      "possible_keys": ["PRIMARY"],
      "key": "PRIMARY",
      "key_length": "32",
      "used_key_parts": ["id"],
      "ref": ["test.t2.id"],
      "rows": 1,
      "filtered": 100,
      "using_index": true
    }
  }
}
SELECT t1.id
FROM t1 INNER JOIN t2 ON t1.id=t2.id
ORDER BY t2.id LIMIT 2;
id
0
1
DROP TABLE t1,t2;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 SELECT seq-1, seq-1 from seq_1_to_10;
CREATE TABLE t2 as SELECT * from t1;
CREATE TABLE t3 (a int, b int);
INSERT INTO t3 SELECT seq-1, seq-1 from seq_1_to_1000;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;
#
# Outer Join
#
# sort-nest(t2,t1) and t3 outside the nest
EXPLAIN SELECT * from t2,t1 left join t3 on t3.a=t1.b
order by t2.a desc,t1.a desc limit 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	10	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT * from t2,t1 left join t3 on t3.a=t1.b
order by t2.a desc,t1.a desc limit 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "const_condition": "1",
    "table": {
      "table_name": "t2",
      "access_type": "ALL",
      "rows": 10,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t1",
        "access_type": "ALL",
        "rows": 10,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.a desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "trigcond(t3.a = `sort-nest`.b)"
    }
  }
}
SELECT * from t2,t1 left join t3 on t3.a=t1.b
order by t2.a desc,t1.a desc limit 5;
a	b	a	b	a	b
9	9	9	9	9	9
9	9	8	8	8	8
9	9	7	7	7	7
9	9	6	6	6	6
9	9	5	5	5	5
#
# no sort-nest as all the inner tables of the outer join will be
# inside the nest, this should use temporary table to sort after the
# entire join is computed
#
EXPLAIN SELECT * FROM t2 LEFT JOIN (t1 LEFT JOIN t3 ON t3.a=t1.b)
ON t2.b=t1.a
ORDER BY t2.a DESC,t1.a DESC LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	Using temporary; Using filesort
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	10	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where; Using join buffer (incremental, BNL join)
EXPLAIN FORMAT=JSON SELECT * FROM t2 LEFT JOIN (t1 LEFT JOIN t3 ON t3.a=t1.b)
ON t2.b=t1.a
ORDER BY t2.a DESC,t1.a DESC LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "const_condition": "1",
    "filesort": {
      "sort_key": "t2.a desc, t1.a desc",
      "temporary_table": {
        "table": {
          "table_name": "t2",
          "access_type": "ALL",
          "rows": 10,
          "filtered": 100
        },
        "block-nl-join": {
          "table": {
            "table_name": "t1",
            "access_type": "ALL",
            "rows": 10,
            "filtered": 100
          },
          "buffer_type": "flat",
          "buffer_size": "141",
          "join_type": "BNL",
          "attached_condition": "trigcond(t1.a = t2.b)"
        },
        "block-nl-join": {
          "table": {
            "table_name": "t3",
            "access_type": "ALL",
            "rows": 1000,
            "filtered": 100
          },
          "buffer_type": "incremental",
          "buffer_size": "1Kb",
          "join_type": "BNL",
          "attached_condition": "trigcond(t3.a = t1.b)"
        }
      }
    }
  }
}
SELECT * FROM t2 LEFT JOIN (t1 LEFT JOIN t3 ON t3.a=t1.b)
ON t2.b=t1.a
ORDER BY t2.a DESC,t1.a DESC LIMIT 5;
a	b	a	b	a	b
9	9	9	9	9	9
8	8	8	8	8	8
7	7	7	7	7	7
6	6	6	6	6	6
5	5	5	5	5	5
DROP TABLE t1,t2,t3;
#
# Sort-nest with prepared statements
#
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 SELECT seq-1,seq-1 from seq_1_to_10;
CREATE TABLE t2 as SELECT * from t1;
CREATE TABLE t3 (a int, b int);
INSERT INTO t3 SELECT seq-1, seq-1 from seq_1_to_1000;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;
# sort-nest on table t1,t2
prepare ps1 from "EXPLAIN SELECT * FROM t2,t1,t3
                  WHERE t3.a=t1.b+1
                  ORDER BY t2.a DESC,t1.a DESC
                  LIMIT 5";
EXECUTE ps1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	10	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXECUTE ps1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	10	Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	1000	Using where
# sort-nest on table t1,t2
PREPARE ps2 from "EXPLAIN FORMAT=JSON
                  SELECT * from t2,t1,t3
                  WHERE t3.a=t1.b+1
                  ORDER BY t2.a DESC, t1.a DESC
                  LIMIT 5";
EXECUTE ps2;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t2",
      "access_type": "ALL",
      "rows": 10,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t1",
        "access_type": "ALL",
        "rows": 10,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.a desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.a = `sort-nest`.b + 1"
    }
  }
}
EXECUTE ps2;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t2",
      "access_type": "ALL",
      "rows": 10,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t1",
        "access_type": "ALL",
        "rows": 10,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.a desc, `sort-nest`.a desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100,
      "attached_condition": "t3.a = `sort-nest`.b + 1"
    }
  }
}
# sort-nest on table t1,t2
PREPARE ps3 from "SELECT * from t2,t1,t3
                  WHERE t3.a=t1.b+1
                  ORDER BY t2.a DESC, t1.a DESC
                  LIMIT 5";
EXECUTE ps3;
a	b	a	b	a	b
9	9	9	9	10	10
9	9	8	8	9	9
9	9	7	7	8	8
9	9	6	6	7	7
9	9	5	5	6	6
EXECUTE ps3;
a	b	a	b	a	b
9	9	9	9	10	10
9	9	8	8	9	9
9	9	7	7	8	8
9	9	6	6	7	7
9	9	5	5	6	6
DEALLOCATE PREPARE ps1;
DEALLOCATE PREPARE ps2;
DEALLOCATE PREPARE ps3;
DROP TABLE t1,t2,t3;
# INDEPENDENT SUBQUERIES
CREATE TABLE t0 (a int);
INSERT INTO t0 SELECT seq-1 from seq_1_to_10;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 SELECT a,a from t0 where a <5;
CREATE TABLE t2 as SELECT * from t1 where a < 5;
CREATE TABLE t3 (a int, b int, c int);
INSERT INTO t3 SELECT seq-1, seq-1, seq-1 from seq_1_to_1000;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;
#
# sort-nest(t2,t1) and independent subquery in the SELECT list
#
EXPLAIN SELECT (SELECT A.a FROM t3 A WHERE A.a > 5 limit 1) as x,
t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a = t2.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	5	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	PRIMARY	<sort-nest>	ALL	NULL	NULL	NULL	NULL	1	Using filesort
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	1000	
2	SUBQUERY	A	ALL	NULL	NULL	NULL	NULL	1000	Using where
EXPLAIN FORMAT=JSON SELECT (SELECT A.a FROM t3 A WHERE A.a > 5 limit 1) as x,
t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a = t2.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "table": {
      "table_name": "t1",
      "access_type": "ALL",
      "rows": 5,
      "filtered": 100
    },
    "block-nl-join": {
      "table": {
        "table_name": "t2",
        "access_type": "ALL",
        "rows": 5,
        "filtered": 100
      },
      "buffer_type": "flat",
      "buffer_size": "119",
      "join_type": "BNL",
      "attached_condition": "t2.a = t1.a"
    },
    "read_sorted_file": {
      "filesort": {
        "sort_key": "`sort-nest`.b desc, `sort-nest`.b desc",
        "table": {
          "table_name": "<sort-nest>",
          "access_type": "ALL",
          "rows": 1,
          "filtered": 100
        }
      }
    },
    "table": {
      "table_name": "t3",
      "access_type": "ALL",
      "rows": 1000,
      "filtered": 100
    },
    "subqueries": [
      {
        "query_block": {
          "select_id": 2,
          "table": {
            "table_name": "A",
            "access_type": "ALL",
            "rows": 1000,
            "filtered": 99.219,
            "attached_condition": "A.a > 5"
          }
        }
      }
    ]
  }
}
SELECT (SELECT A.a FROM t3 A WHERE A.a > 5 limit 1) as x,
t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a = t2.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5;
x	b	b	a
6	4	4	0
6	4	4	1
6	4	4	2
6	4	4	3
6	4	4	4
DROP TABLE t0,t1,t2,t3;
#
#  Const table should not form the sort-nest
#
CREATE TABLE t1 (i1 integer NOT NULL PRIMARY KEY);
CREATE TABLE t2 (i2 integer NOT NULL PRIMARY KEY);
CREATE TABLE t3 (i3 integer);
INSERT INTO t1 VALUES (1), (2), (3), (4), (5), (6), (7), (8),
(9), (10), (11), (12);
INSERT INTO t2 SELECT * FROM t1;
EXPLAIN SELECT t1.*, t2.*
FROM t1 JOIN t2 ON t1.i1 = t2.i2
LEFT JOIN t3 ON t2.i2 = t3.i3
ORDER BY t1.i1
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t3	system	NULL	NULL	NULL	NULL	0	Const row not found
1	SIMPLE	t1	index	PRIMARY	PRIMARY	4	NULL	12	Using index
1	SIMPLE	t2	eq_ref	PRIMARY	PRIMARY	4	test.t1.i1	1	Using index
SELECT t1.*, t2.*
FROM t1 JOIN t2 ON t1.i1 = t2.i2
LEFT JOIN t3 ON t2.i2 = t3.i3
ORDER BY t1.i1
LIMIT 5;
i1	i2
1	1
2	2
3	3
4	4
5	5
DROP TABLE t1,t2,t3;
# All tables are const tables
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 VALUES (0,0);
CREATE TABLE t2(a int, b int);
INSERT INTO t2 VALUES (0,0);
CREATE TABLE t3(a int, b int);
INSERT INTO t3 VALUES (0,0);
EXPLAIN SELECT t1.a,t2.a,t3.a
FROM t1,t2,t3
WHERE t1.b = t2.b AND t3.b=t1.b
ORDER BY t2.a DESC,t1.a DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	system	NULL	NULL	NULL	NULL	1	
1	SIMPLE	t2	system	NULL	NULL	NULL	NULL	1	
1	SIMPLE	t3	system	NULL	NULL	NULL	NULL	1	
SELECT t1.a,t2.a,t3.a
FROM t1,t2,t3
WHERE t1.b = t2.b AND t3.b=t1.b
ORDER BY t2.a DESC,t1.a DESC
LIMIT 5;
a	a	a
0	0	0
DROP TABLE t1,t2,t3;
#
# Tests where Index(scan, ref or range access) satisfies the ORDERING
#
CREATE TABLE t1 (a int, b int, c int, KEY a_b (a,b), KEY a_c (a,c));
INSERT INTO t1 VALUES (0,1,0), (0,2,0), (0,3,0), (0,4,0), (0,5,0), (0,6,0);
INSERT INTO t1 values (1,7,1), (1,8,1), (1,9,1), (1,10,1), (1,11,1), (1,12,1);
INSERT INTO t1 VALUES (1,7,2), (1,8,2), (1,9,2), (1,10,2), (1,11,2), (1,12,2);
INSERT INTO t1 VALUES (1,7,2), (1,8,2), (1,9,2), (1,10,2), (1,11,2), (1,12,2);
INSERT INTO t1 VALUES (1,1,2);
# index key a_b, no need for filesort
EXPLAIN SELECT a,b,c FROM t1
WHERE a=1 and c=2
ORDER BY b
LIMIT 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	a_b,a_c	a_b	5	NULL	19	Using index condition; Using where
SELECT a,b,c FROM t1
WHERE a=1 and c=2
ORDER BY b
LIMIT 10;
a	b	c
1	1	2
1	7	2
1	7	2
1	8	2
1	8	2
1	9	2
1	9	2
1	10	2
1	10	2
1	11	2
DROP TABLE t1;
#
# Testing ORDER BY LIMIT with OFFSET, should show the same plan and same
# estimate of rows for the sort-nest
#
CREATE TABLE t0 (a int);
INSERT INTO t0 SELECT seq-1 from seq_1_to_10;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 SELECT a, a from t0;
CREATE TABLE t2 as SELECT * from t1;
CREATE TABLE t3(a int, b int, c int, key(a));
INSERT INTO t3  SELECT seq-1, seq-1, seq-1 from seq_1_to_100;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;
EXPLAIN SELECT t1.a, t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a=t2.a AND t3.a = t2.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 10;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	10	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	10	Using filesort
1	SIMPLE	t3	ref	a	a	5	sort-nest.a	1	Using index
SELECT t1.a, t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a=t2.a AND t3.a = t2.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 10;
a	b	b	a
9	9	9	9
8	8	8	8
7	7	7	7
6	6	6	6
5	5	5	5
4	4	4	4
3	3	3	3
2	2	2	2
1	1	1	1
0	0	0	0
EXPLAIN SELECT t1.a, t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a=t2.a AND t3.a=t2.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5 OFFSET 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	10	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	10	Using filesort
1	SIMPLE	t3	ref	a	a	5	sort-nest.a	1	Using index
SELECT t1.a, t2.b, t1.b, t3.a
FROM t1,t2,t3
WHERE t1.a=t2.a AND t3.a=t2.a
ORDER BY t2.b DESC, t1.b DESC
LIMIT 5 OFFSET 5;
a	b	b	a
4	4	4	4
3	3	3	3
2	2	2	2
1	1	1	1
0	0	0	0
drop table t0,t1,t2,t3;
#
# Constant removed from ORDER BY , so no need of sorting
#
CREATE TABLE t0 (a int);
INSERT INTO t0 SELECT seq-1 from seq_1_to_10;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 SELECT a, a from t0;
CREATE TABLE t2 as SELECT * from t1;
set use_sort_nest=1;
EXPLAIN SELECT *
FROM t1,t2
WHERE t1.a=t2.a and t1.b= 4 
ORDER BY t1.b DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	10	Using where
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	10	Using where
SELECT *
FROM t1,t2
WHERE t1.a=t2.a and t1.b= 4 
ORDER BY t1.b DESC
LIMIT 5;
a	b	a	b
4	4	4	4
drop table t0,t1,t2;
#
# ORDER BY clause containing expressions
#
CREATE TABLE t0 (a int);
INSERT INTO t0 SELECT seq-1 from seq_1_to_10;
CREATE TABLE t1 (a int, b int);
INSERT INTO t1 SELECT a, a from t0 where a <5;
CREATE TABLE t2 as SELECT * from t1 where a < 5;
CREATE TABLE t3(a int, b int, c int, key(a));
INSERT INTO t3  SELECT seq-1, seq-1, seq-1 from seq_1_to_10;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
ANALYZE TABLE t2 PERSISTENT FOR ALL;
ANALYZE TABLE t3 PERSISTENT FOR ALL;
set use_sort_nest=1;
EXPLAIN SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY abs(t3.a+t1.b) DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	5	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	<sort-nest>	ALL	NULL	NULL	NULL	NULL	5	Using filesort
1	SIMPLE	t3	ref	a	a	5	sort-nest.a	1	Using index
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY abs(t3.a+t1.b) DESC
LIMIT 5;
a	b	b	t1.b + t2.b
4	4	4	8
3	3	3	6
2	2	2	4
1	1	1	2
0	0	0	0
set use_sort_nest=0;
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY abs(t3.a+t1.b) DESC
LIMIT 5;
a	b	b	t1.b + t2.b
4	4	4	8
3	3	3	6
2	2	2	4
1	1	1	2
0	0	0	0
#
# No sort nest where ORDER BY item are expensive to compute like 
# stored functions, subqueries etc
CREATE FUNCTION f1(a INT) RETURNS INT
BEGIN
RETURN a;
END|
set use_sort_nest=1;
EXPLAIN SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY f1(t3.a+t1.b) DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	5	Using temporary; Using filesort
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	t3	ref	a	a	5	test.t2.a	1	Using index
EXPLAIN FORMAT=JSON SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY f1(t3.a+t1.b) DESC
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "filesort": {
      "sort_key": "f1(t3.a + t1.b) desc",
      "temporary_table": {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "rows": 5,
          "filtered": 100
        },
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "rows": 5,
            "filtered": 100
          },
          "buffer_type": "flat",
          "buffer_size": "119",
          "join_type": "BNL",
          "attached_condition": "t2.b = t1.a and t2.a is not null"
        },
        "table": {
          "table_name": "t3",
          "access_type": "ref",
          "possible_keys": ["a"],
          "key": "a",
          "key_length": "5",
          "used_key_parts": ["a"],
          "ref": ["test.t2.a"],
          "rows": 1,
          "filtered": 100,
          "using_index": true
        }
      }
    }
  }
}
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY f1(t3.a+t1.b) DESC
LIMIT 5;
a	b	b	t1.b + t2.b
4	4	4	8
3	3	3	6
2	2	2	4
1	1	1	2
0	0	0	0
set use_sort_nest=0;
EXPLAIN SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY f1(t3.a+t1.b) DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	5	Using temporary; Using filesort
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	t3	ref	a	a	5	test.t2.a	1	Using index
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY f1(t3.a+t1.b) DESC
LIMIT 5;
a	b	b	t1.b + t2.b
4	4	4	8
3	3	3	6
2	2	2	4
1	1	1	2
0	0	0	0
drop function f1;
#
# Window function in order by clause, sort-nest not allowed
#
set use_sort_nest=1;
EXPLAIN SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b AND t2.a=t3.a
ORDER BY row_number() OVER (ORDER BY t1.a) DESC
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	5	Using temporary; Using filesort
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	t3	ref	a	a	5	test.t2.a	1	Using index
EXPLAIN FORMAT=JSON SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b AND t2.a=t3.a
ORDER BY row_number() OVER (ORDER BY t1.a) DESC
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "filesort": {
      "sort_key": "row_number() over ( order by t1.a) desc",
      "window_functions_computation": {
        "sorts": {
          "filesort": {
            "sort_key": "t1.a"
          }
        },
        "temporary_table": {
          "table": {
            "table_name": "t1",
            "access_type": "ALL",
            "rows": 5,
            "filtered": 100
          },
          "block-nl-join": {
            "table": {
              "table_name": "t2",
              "access_type": "ALL",
              "rows": 5,
              "filtered": 100
            },
            "buffer_type": "flat",
            "buffer_size": "119",
            "join_type": "BNL",
            "attached_condition": "t2.b = t1.a and t2.a is not null"
          },
          "table": {
            "table_name": "t3",
            "access_type": "ref",
            "possible_keys": ["a"],
            "key": "a",
            "key_length": "5",
            "used_key_parts": ["a"],
            "ref": ["test.t2.a"],
            "rows": 1,
            "filtered": 100,
            "using_index": true
          }
        }
      }
    }
  }
}
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b AND t2.a=t3.a
ORDER BY row_number() OVER (ORDER BY t1.a) DESC
LIMIT 5;
a	b	b	t1.b + t2.b
4	4	4	8
3	3	3	6
2	2	2	4
1	1	1	2
0	0	0	0
set use_sort_nest=0;
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b AND t2.a=t3.a
ORDER BY row_number() OVER (ORDER BY t1.a) DESC
LIMIT 5;
a	b	b	t1.b + t2.b
4	4	4	8
3	3	3	6
2	2	2	4
1	1	1	2
0	0	0	0
#
# Subqueries used in order by clause
#
set use_sort_nest=1;
EXPLAIN SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY (select A.a+t1.b from t1 A limit 1)
LIMIT 5;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	5	Using temporary; Using filesort
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
1	PRIMARY	t3	ref	a	a	5	test.t2.a	1	Using index
2	DEPENDENT SUBQUERY	A	ALL	NULL	NULL	NULL	NULL	5	
EXPLAIN FORMAT=JSON SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY (select A.a+t1.b from t1 A limit 1)
LIMIT 5;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "filesort": {
      "sort_key": "(subquery#2)",
      "temporary_table": {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "rows": 5,
          "filtered": 100
        },
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "rows": 5,
            "filtered": 100
          },
          "buffer_type": "flat",
          "buffer_size": "119",
          "join_type": "BNL",
          "attached_condition": "t2.b = t1.a and t2.a is not null"
        },
        "table": {
          "table_name": "t3",
          "access_type": "ref",
          "possible_keys": ["a"],
          "key": "a",
          "key_length": "5",
          "used_key_parts": ["a"],
          "ref": ["test.t2.a"],
          "rows": 1,
          "filtered": 100,
          "using_index": true
        },
        "subqueries": [
          {
            "expression_cache": {
              "state": "uninitialized",
              "query_block": {
                "select_id": 2,
                "table": {
                  "table_name": "A",
                  "access_type": "ALL",
                  "rows": 5,
                  "filtered": 100
                }
              }
            }
          }
        ]
      }
    }
  }
}
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY (select A.a+t1.b from t1 A limit 1)
LIMIT 5;
a	b	b	t1.b + t2.b
0	0	0	0
1	1	1	2
2	2	2	4
3	3	3	6
4	4	4	8
set use_sort_nest=0;
SELECT t1.a, t2.b, t1.b, t1.b + t2.b
FROM t1,t2, t3
WHERE t1.a=t2.b and t2.a=t3.a
ORDER BY (select A.a+t1.b from t1 A limit 1)
LIMIT 5;
a	b	b	t1.b + t2.b
0	0	0	0
1	1	1	2
2	2	2	4
3	3	3	6
4	4	4	8
drop table t0,t1,t2,t3;
