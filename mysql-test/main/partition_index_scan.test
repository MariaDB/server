--source include/have_partition.inc
--source include/have_sequence.inc

--echo # Index scans with PARTITION BY RANGE

CREATE TABLE t1 (
  c int,
  d INT,
  INDEX idx1(c, d)
) PARTITION BY RANGE COLUMNS(d) (
 PARTITION `p1` VALUES LESS THAN (10),
 PARTITION `p2` VALUES LESS THAN (20),
 PARTITION `p3` VALUES LESS THAN (30),
 PARTITION `p4` VALUES LESS THAN (40),
 PARTITION `p5` VALUES LESS THAN MAXVALUE
);

insert into t1 select t2.seq, t3.seq from seq_100_to_200 t2, seq_1_to_50 t3;

--disable_ps2_protocol
--echo # ordered scans (DESC ordering)
flush status;
select * from t1 where c = 120 ORDER BY d DESC LIMIT 1;
show status like 'handler_read_%';
flush status;
select * from t1 where c = 120 ORDER BY d DESC LIMIT 2;
show status like 'handler_read_%';
flush status;
select * from t1 where c = 120 ORDER BY d DESC LIMIT 16;
show status like 'handler_read_%';

--echo # select * from t1 where c = 120 ORDER BY d DESC LIMIT 2
let $out=`analyze format=json select * from t1 where c = 120 ORDER BY d DESC LIMIT 2`;
evalp set @js='$out';
select json_extract(@js,'$**.partitions_index_scan_method');

--echo # Unordered scans (PARTITION BY RANGE expression is identical
--echo # to ORDER BY expression)
flush status;
select * from t1 where c = 120 ORDER BY d LIMIT 1;
show status like 'handler_read_%';
flush status;
select * from t1 where c = 120 ORDER BY d LIMIT 2;
show status like 'handler_read_%';
flush status;
select * from t1 where c = 120 ORDER BY d LIMIT 16;
show status like 'handler_read_%';

select * from t1 where c = 120 LIMIT 2;

--echo # select * from t1 where c = 120 ORDER BY d LIMIT 2
let $out=`analyze format=json select * from t1 where c = 120 ORDER BY d LIMIT 2`;
evalp set @js='$out';
select json_extract(@js,'$**.partitions_index_scan_method');

drop table t1;

--echo # PARTITION BY RANGE (expr)
CREATE TABLE t1 (
  c int,
  d INT,
  INDEX idx1(c, d)
) PARTITION BY RANGE (d % 5) (
 PARTITION `p1` VALUES LESS THAN (1),
 PARTITION `p2` VALUES LESS THAN (2),
 PARTITION `p3` VALUES LESS THAN (3),
 PARTITION `p4` VALUES LESS THAN (4),
 PARTITION `p5` VALUES LESS THAN MAXVALUE
);

insert into t1 select t2.seq, t3.seq from seq_100_to_200 t2, seq_1_to_50 t3;

flush status;
select * from t1 where c = 120 ORDER BY d DESC LIMIT 1;
show status like 'handler_read_%';
flush status;
select * from t1 where c = 120 ORDER BY d DESC LIMIT 2;
show status like 'handler_read_%';
flush status;
select * from t1 where c = 120 ORDER BY d LIMIT 2;
show status like 'handler_read_%';
flush status;
--echo ## Unordered scan (filesort + mrr)
select * from t1 where c = 120 ORDER BY d % 5 LIMIT 2;
show status like 'handler_read_%';
flush status;
select * from t1 where c = 120 LIMIT 2;
show status like 'handler_read_%';

--echo # select * from t1 where c = 120 ORDER BY d LIMIT 2
let $out=`analyze format=json select * from t1 where c = 120 ORDER BY d LIMIT 2`;
evalp set @js='$out';
select json_extract(@js,'$**.partitions_index_scan_method');

--echo # select * from t1 where c = 120 ORDER BY d % 5 LIMIT 2
let $out=`analyze format=json select * from t1 where c = 120 ORDER BY d % 5 LIMIT 2`;
evalp set @js='$out';
select json_extract(@js,'$**.partitions_index_scan_method');

drop table t1;

--echo # Unordered scan (partition table is the second in the join
--echo # order after optimization) extracted and minimised from the
--echo # test main.partition

CREATE TABLE t1 (
  id int(8),
  PRIMARY KEY (id)
);

INSERT INTO t1 VALUES (11), (22), (33);

CREATE TABLE t2 (
  taken int,
  id int,
  PRIMARY KEY (id,taken),
  KEY taken (taken)
)
PARTITION BY RANGE (taken)
(
  PARTITION p1 VALUES LESS THAN (50),
  PARTITION p2 VALUES LESS THAN (60),
  PARTITION p3 VALUES LESS THAN MAXVALUE
);

INSERT INTO t2 VALUES
  (51,11), /* p2 */
  (63,11), /* p3 */
  (51,22), /* p2 */
  (53,22), /* p2 */
  (55,22), /* p2 */
  (57,22), /* p2 */
  (61,22), /* p3 */
  (63,22), /* p3 */
  (51,33), /* p2 */
  (55,33) /* p2 */
  ;

set @ff=53;
set @tt=64;

flush status;
SELECT t1.id
FROM t1
WHERE t1.id IN (
    SELECT distinct id
    FROM t2
    WHERE taken BETWEEN @ff AND @tt)
ORDER BY t1.id;
show status like 'handler_read_%';

--echo # same statement as above
let $out=`analyze format=json
SELECT t1.id
FROM t1
WHERE t1.id IN (
    SELECT distinct id
    FROM t2
    WHERE taken BETWEEN @ff AND @tt)
ORDER BY t1.id`;
evalp set @js='$out';
select json_extract(@js,'$**.partitions_index_scan_method');

--echo # ordered scan (partition table is the first in the join
--echo # order after optimization and ORDER BY differs from
--echo # PARTITION BY RANGE)
flush status;
SELECT t1.id
FROM t1
WHERE t1.id IN (
    SELECT distinct id
    FROM t2
    WHERE taken BETWEEN 53 AND 64)
ORDER BY t1.id;
show status like 'handler_read_%';

--echo # same statement as above
let $out=`analyze format=json
SELECT t1.id
FROM t1
WHERE t1.id IN (
    SELECT distinct id
    FROM t2
    WHERE taken BETWEEN 53 AND 64)
ORDER BY t1.id`;
evalp set @js='$out';
select json_extract(@js,'$**.partitions_index_scan_method');

--echo # ordered scan again (only one table and no ORDER BY)
flush status;
select distinct id from t2 where taken between @ff and @tt;
show status like 'handler_read_%';
--enable_ps2_protocol

--echo # same statement as above
let $out=`analyze format=json
select distinct id from t2 where taken between @ff and @tt`;
evalp set @js='$out';
select json_extract(@js,'$**.partitions_index_scan_method');

drop table t1, t2;
