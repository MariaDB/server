--source include/have_sequence.inc

--echo # Small driving table
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1, 1), (2, 2000),(3,300);

analyze table t1 persistent for all;

--echo # Table that will be accessed by an index lookup (`ref` access)
CREATE TABLE t2 (a INT, b INT, KEY key_b(b));
--echo # All t11.b values are NULL
INSERT INTO t2 SELECT seq/100,  NULL FROM seq_1_to_1000;

analyze table t2 persistent for all;

--echo # NULL-rejecting equality t1.b = t2.b will not return any matches
--echo # because all values of t2.b are NULL. So "rows" = 1 for t2 where 1 is
--echo # a special value meaning "very few" rows
EXPLAIN EXTENDED SELECT * FROM t1 JOIN t2 ON t1.a = t2.a AND t1.b = t2.b;

--echo # However, rows estimation for not NULL-rejecting conditions
--echo # must not be affected ("rows" > 1 is expected)
EXPLAIN EXTENDED SELECT * FROM t1 JOIN t2 ON t1.a = t2.a AND t1.b <=> t2.b;

ANALYZE SELECT * FROM t1 JOIN t2 ON t1.a = t2.a AND t1.b <=> t2.b;

--echo # Test composite index for two columns. Key prefix is used for access
CREATE TABLE t3 (a INT, b INT, KEY key_ab(a,b));
--echo # All t3.b values are NULL
INSERT INTO t3 SELECT seq/100,  NULL FROM seq_1_to_1000;

analyze table t3 persistent for all;

--echo # NULL-rejecting equality t1.b = t3.b, same as above.
--echo # "rows" must be estimated to 1
EXPLAIN EXTENDED SELECT * FROM t1 JOIN t3 ON t1.a = t3.a AND t1.b = t3.b;

--echo # Rows estimation for not NULL-rejecting conditions are not affected
--echo # ("rows" > 1 is expected)
EXPLAIN EXTENDED SELECT * FROM t1 JOIN t3 ON t1.a = t3.a;

EXPLAIN EXTENDED SELECT * FROM t1 JOIN t3 ON t1.a = t3.a AND t1.b <=> t3.b;

EXPLAIN EXTENDED SELECT * FROM t1 JOIN t3 ON t1.a = t3.a AND t3.b is NULL;

--echo OLEGS: update t2 so that there are not only NULLs, collect the stats and re-test

--echo # Test composite index for 3 columns. Key prefix is used for access
CREATE TABLE t4 (a INT, b INT, c INT, KEY key_abc(a,b,c));

--echo # All t3.b values are NULL
INSERT INTO t4 SELECT seq/10,  NULL, seq/10 FROM seq_1_to_1000;

analyze table t4 persistent for all;

--echo # NULL-rejecting equality t1.b = t3.b, same as above.
--echo # "rows" must be estimated to 1
EXPLAIN EXTENDED SELECT * FROM t1 JOIN t4 ON t1.a = t4.a AND t1.b = t4.b;

EXPLAIN EXTENDED SELECT * FROM t1 JOIN t4 ON t1.a = t4.a AND t1.b = t4.b and t1.b = t4.c;

--echo # "rows" expected to be > 1
EXPLAIN EXTENDED SELECT * FROM t1 JOIN t4 ON t1.a = t4.a;

EXPLAIN EXTENDED SELECT * FROM t1 JOIN t4 ON t1.a = t4.a AND t1.b <=> t4.c;

drop table t1, t2, t3, t4;

