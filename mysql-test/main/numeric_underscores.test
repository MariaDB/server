--source include/have_innodb.inc

--echo #
--echo # MDEV-34228: Underscores in numeric literals
--echo #

--echo # Standard integers
SELECT 1_000;
SELECT 1_234_567;
SELECT +1_000, -1_000;

--echo # Consecutive underscores -> Identifier
CREATE TABLE t1 (1__000 INT);
INSERT INTO t1 VALUES (5);
SELECT 1__000 AS val FROM t1;
DROP TABLE t1;

--echo # Hexadecimal
SELECT 0x_FF;
SELECT 0x_FFFF_FFFF;
SELECT 0x1_F;
SELECT 0xABCD_EF01;

--echo # Binary
SELECT 0b_1010;
SELECT 0b_1111_0000;
SELECT 0b1_0;
SELECT 0b1111_0000;

--echo # Decimal
SELECT 1_000.001;
SELECT 1000.000_5;
SELECT 1_000.000_001;

--echo # Floating point
SELECT 1_2.3_4e1_0;
SELECT 1.2e+1_0;
SELECT 1.2e-1_0;

--echo # Digit start, contains letter -> Identifier
CREATE TABLE t1 (1a INT);
INSERT INTO t1 VALUES (3);
SELECT 1a FROM t1;
DROP TABLE t1;

--echo # This should fail because 1_000 is now a number, not an identifier
--error ER_PARSE_ERROR
CREATE TABLE t1 (1_000 INT);

--echo # Mixed tests
SELECT 1_000 + 0x_FF;
SELECT 1_2.3_4e1 + 1_0;

--echo #
--echo # Boundary cases and negative tests
--echo #

--echo # Underscore adjacent to decimal point (should NOT be a single number)
--error ER_PARSE_ERROR
SELECT (1._0);
--error ER_UNKNOWN_TABLE
SELECT (1_.0);

--echo # Hex and Binary prefixes (leading underscore is valid per T662)
SELECT 0x_FF, 0b_1010;

--echo # 1_e10 -> should be an identifier, so (1_e10) fails if no such column
--error ER_BAD_FIELD_ERROR
SELECT (1_e10);

--echo # 1.0_e10 -> (1.0_e10) should fail as syntax error if split
--error ER_PARSE_ERROR
SELECT (1.0_e10);

--echo # 1e_10 -> identifier or error
--error ER_BAD_FIELD_ERROR
SELECT (1e_10);

--echo # Start with underscore
--error ER_BAD_FIELD_ERROR,ER_UNKNOWN_TABLE
SELECT _1.0;

--echo # Valid cases for comparison
SELECT 1_0.0_1e1_0;
SELECT 0x1_F, 0b1_0;

--echo #
--echo # MDEV-34228: Underscores in CAST and string-to-number conversions
--echo #

--echo # =========================================
--echo # CAST to UNSIGNED — reuse literal patterns
--echo # =========================================
SELECT CAST('1_000' AS UNSIGNED);
SELECT CAST('1_234_567' AS UNSIGNED);
SELECT CAST('+1_000' AS UNSIGNED);

--echo # CAST to SIGNED
SELECT CAST('-1_000' AS SIGNED);
SELECT CAST('1_000' AS SIGNED);
SELECT CAST('+1_234_567' AS SIGNED);

--echo # CAST to DECIMAL — from the decimal/float literals above
SELECT CAST('1_000.001' AS DECIMAL(10,3));
SELECT CAST('1000.000_5' AS DECIMAL(10,4));
SELECT CAST('1_000.000_001' AS DECIMAL(13,6));

--echo # CAST to DOUBLE — from the float literals above
SELECT CAST('1_2.3_4e1_0' AS DOUBLE);
SELECT CAST('1.2e+1_0' AS DOUBLE);
SELECT CAST('1.2e-1_0' AS DOUBLE);

--echo # =================================
--echo # Invalid underscores in CAST input
--echo # =================================

--echo # Consecutive underscores — should truncate after first digit group
SELECT CAST('1__234' AS UNSIGNED);
SELECT CAST('1__234' AS SIGNED);
SELECT CAST('1__234' AS DECIMAL(10,0));
SELECT CAST('1__234' AS DOUBLE);

--echo # Trailing underscore — should truncate
SELECT CAST('1000_' AS UNSIGNED);

--echo # Leading underscore — should be 0 with warning
SELECT CAST('_1000' AS UNSIGNED);

--echo # Underscore adjacent to decimal point
SELECT CAST('1_.0' AS DECIMAL(10,1));
SELECT CAST('1._0' AS DECIMAL(10,1));

--echo # Underscore adjacent to exponent marker
SELECT CAST('1.0_e10' AS DOUBLE);
SELECT CAST('1.0e_10' AS DOUBLE);

--echo # ============================
--echo # Implicit string-to-number
--echo # ============================
SELECT '1_000' + 0;
SELECT '1_234_567' + 0;
SELECT '-1_000' + 0;
SELECT '1_000.50' + 0.0;
SELECT '1_2.3_4e1_0' + 0e0;

--echo # Invalid underscore in implicit conversion
SELECT '1__234' + 0;
SELECT '1000_' + 0;
SELECT '_1000' + 0;

--echo # ============================
--echo # Hex/Binary strings via CAST
--echo # ============================
--echo # Note: CAST('0xFF' as UNSIGNED) itself returns 0, hence CAST('0x_FF' AS UNSIGNED) also doesn't work yet.
SELECT CAST('0x_FF' AS UNSIGNED);
