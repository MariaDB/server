--echo #
--echo # The following entries are meant for testing the parser, ensuring
--echo # the right values are passed down to the executor, for all possible
--echo # syntax combinations.
--echo #
--echo # Test basic syntax.
--echo #

create table t1 (a int);
create table t_keyword (`offset` int);

insert into t1 values (1), (1), (2), (3), (2);
insert into t_keyword values (1), (1), (2), (3), (2);

--echo #
--echo # Make sure the FETCH clause addition didn't introduce problems with
--echo # the offset keyword.
--echo #
--error 1064
select * from t1
order by a
offset 2;

--echo #
--echo # Offset is now a reserved keyword. Column names can not have that name
--echo # without escaping the identifier.
--echo #
--error 1064
select * from t_keyword
order by offset;

select * from t_keyword
order by `offset`;


--echo #
--echo # Test syntax without a specific limit. (implicit one row)
--echo # Test the alias between row / rows and first / next.
--echo # Test ONLY vs WITH TIES.
--echo #
--echo # Cover also the presence of offset before or after FETCH clause.
--echo #
select * from t1
fetch first row only;

select * from t1
fetch first rows only;

select * from t1
fetch next row only;

select * from t1
fetch next rows only;

--echo #
--echo # Include offset before fetch clause.
--echo #
select * from t1
order by a
offset 2
fetch first row only;

select * from t1
order by a
offset 2
fetch first rows only;

select * from t1
offset 2
fetch next row only;

select * from t1
offset 2
fetch next rows only;


--echo #
--echo # Include offset after fetch clause.
--echo #
select * from t1
order by a
fetch first row only
offset 2;

select * from t1
order by a
fetch first rows only
offset 2;

select * from t1
order by a
fetch next row only
offset 2;

select * from t1
order by a
fetch next rows only
offset 2;

--echo #
--echo # Repeat the tests, but now with WITH TIES.
--echo # WITH TIES requires order by.
--echo #

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch first row with ties;

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch first rows with ties;

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch next row with ties;

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch next rows with ties;

select * from t1
order by a
fetch first row with ties;

select * from t1
order by a
fetch first rows with ties;

select * from t1
order by a
fetch next row with ties;

select * from t1
order by a
fetch next rows with ties;

--echo #
--echo # Include offset before fetch clause.
--echo #

select * from t1
order by a
offset 2
fetch first row with ties;

select * from t1
order by a
offset 2
fetch first rows with ties;

select * from t1
order by a
offset 2
fetch next row with ties;

select * from t1
order by a
offset 2
fetch next rows with ties;


--echo #
--echo # Include offset after fetch clause.
--echo #

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch first row with ties
offset 2;

select * from t1
order by a
fetch first row with ties
offset 2;

select * from t1
order by a
fetch first rows with ties
offset 2;

select * from t1
order by a
fetch next row with ties
offset 2;

select * from t1
order by a
fetch next rows with ties
offset 2;

--echo #
--echo # Test syntax with a specific limit
--echo #
select * from t1
fetch first 3 row only;

select * from t1
fetch first 3 rows only;

select * from t1
fetch next 3 row only;

select * from t1
fetch next 3 rows only;

--echo #
--echo # Include offset before fetch clause.
--echo #
select * from t1
order by a
offset 2
fetch first 3 row only;

select * from t1
order by a
offset 2
fetch first 3 rows only;

select * from t1
offset 2
fetch next 3 row only;

select * from t1
offset 2
fetch next 3 rows only;


--echo #
--echo # Include offset after fetch clause.
--echo #
select * from t1
order by a
fetch first 3 row only
offset 2;

select * from t1
order by a
fetch first 3 rows only
offset 2;

select * from t1
order by a
fetch next 3 row only
offset 2;

select * from t1
order by a
fetch next 3 rows only
offset 2;

--echo #
--echo # Repeat the tests, but now with WITH TIES.
--echo # WITH TIES requires order by.
--echo #

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch first 3 row with ties;

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch first 3 rows with ties;

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch next 3 row with ties;

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch next 3 rows with ties;

select * from t1
order by a
fetch first 3 row with ties;

select * from t1
order by a
fetch first 3 rows with ties;

select * from t1
order by a
fetch next 3 row with ties;

select * from t1
order by a
fetch next 3 rows with ties;

--echo #
--echo # Include offset before fetch clause.
--echo #

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
offset 2
fetch first row with ties;

select * from t1
order by a
offset 2
fetch first 3 row with ties;

select * from t1
order by a
offset 2
fetch first 3 rows with ties;

select * from t1
order by a
offset 2
fetch next 3 row with ties;

select * from t1
order by a
offset 2
fetch next 3 rows with ties;


--echo #
--echo # Include offset after fetch clause.
--echo #

--error ER_WITH_TIES_NEEDS_ORDER
select * from t1
fetch first row with ties
offset 2;

select * from t1
order by a
fetch first 3 row with ties
offset 2;

select * from t1
order by a
fetch first 3 rows with ties
offset 2;

select * from t1
order by a
fetch next 3 row with ties
offset 2;

select * from t1
order by a
fetch next 3 rows with ties
offset 2;

drop table t1;
drop table t_keyword;

--echo #
--echo # Test behaviour with a simple select.
--echo #

create table t1 (id int, first_name varchar(100), last_name varchar(100), score double);
insert into t1 values
  (1, 'Alice', 'Fowler', 5),
  (2, 'John', 'Doe', 6),
  (3, 'John', 'Smith', 6),
  (4, 'John', 'Smith', 6),
  (5, 'John', 'Smith', 7),
  (6, 'John', 'Elton', 8.1),
  (7, 'Bob',  'Trasc', 9),
  (8, 'Silvia', 'Ganush', 10);

create table t2
  (id int,
   location varchar(100),
   fk int,
   constraint `fk_t1`
     FOREIGN KEY (fk) REFERENCES t1 (id)
     ON DELETE CASCADE
     ON UPDATE RESTRICT);
insert into t2 values
  (1, 'L1', 1),
  (2, 'L2', 2),
  (3, 'L3', 3),
  (4, 'L3', 4),
  (5, 'L4', 5),
  (6, 'L4', 6),
  (7, 'L4', 7),
  (7, null, 8);


select * from t1
order by id
fetch first 3 rows only;

select * from t1
order by id
fetch first 3 rows with ties;

select * from t1
order by first_name
fetch first 3 rows only;

select * from t1
order by first_name
fetch first 3 rows with ties;

--echo #
--echo # Test multi-part order by.
--echo #
select * from t1
order by first_name, last_name
fetch first 3 rows with ties;

select * from t1
order by first_name, last_name
fetch first 4 rows with ties;


select * from t1
order by first_name, last_name
offset 1
fetch first 3 rows with ties;

select * from t1
order by first_name, last_name
offset 1
fetch first 3 rows only;

select * from t1
order by first_name, last_name
fetch first 3 rows with ties
offset 1;

select * from t1
order by first_name, last_name
offset 2
fetch first 3 rows only;

select * from t1
order by first_name, last_name
offset 2
fetch first 3 rows with ties;

select * from t1
order by first_name, last_name
offset 3
fetch first 3 rows only;

select * from t1
order by first_name, last_name
offset 3
fetch first 3 rows with ties;

select * from t1
order by first_name, last_name
offset 4
fetch first 3 rows only;

select * from t1
order by first_name, last_name
offset 4
fetch first 3 rows with ties;

--echo #
--echo # Test offset crossing into a new peer-group.
--echo #
select * from t1
order by first_name, last_name
offset 5
fetch first 3 rows with ties;

select * from t1
order by first_name, last_name
offset 5
fetch first 3 rows only;

--echo #
--echo # Simple join with 2 tables, order by without columns in the
--echo # second table and also with columns in the second table.
--echo #
--echo # Cover both only and with ties.
--echo #
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t1.first_name, t1.last_name
fetch first 3 rows only;

select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location, t1.first_name, t1.last_name
fetch first 3 rows only;

select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t1.first_name, t1.last_name
fetch first 3 rows with ties;

select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location, t1.first_name, t1.last_name
fetch first 3 rows with ties;

--echo #
--echo # Test descending order by.
--echo #
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location desc, t1.first_name, t1.last_name
fetch first 3 rows only;

--sorted_result
select * from t2
order by t2.location desc
fetch first 2 rows with ties;

--sorted_result
select * from t2
order by t2.location desc
offset 1
fetch first 2 rows with ties;

--sorted_result
select * from t2
order by t2.location desc
offset 2
fetch first 2 rows with ties;

--echo #
--echo # Test a join with descending order by.
--echo #
select t1.id, t1.first_name, t1.last_name, t1.score, t2.location
from t1 inner join t2 on t1.id = t2.fk
order by t2.location desc, t1.first_name, t1.last_name
fetch first 3 rows with ties;

--echo #
--echo # Test subqueries.
--echo #
select * from (
  select * from t2
  order by t2.location desc
  offset 2
  fetch first 2 rows with ties
) temp;


drop table t1;
drop table t2;


#(select * from t1
#order by a
#fetch first 3 rows with ties
#offset 1)
#union all
#select * from t1
#order by a;



# Test variables referenced.
# Subqueries
# Aggregation
# views
# derived tables
# CTEs
# recursive CTEs
# window functions
# multiple order by
# In stored functions.
# With indexes / without indexes
# With sequences?
# Replication
