drop table if exists t1,t2,t3;
ALTER DATABASE test CHARACTER SET latin1 COLLATE latin1_swedish_ci;
set @save_derived_optimizer_switch=@@optimizer_switch;
set optimizer_switch='derived_merge=off,derived_with_keys=off';
select * from (select 2 from DUAL) b;
2
2
SELECT 1 as a FROM (SELECT 1 UNION SELECT a) b;
ERROR 42S22: Unknown column 'a' in 'SELECT'
SELECT 1 as a FROM (SELECT a UNION SELECT 1) b;
ERROR 42S22: Unknown column 'a' in 'SELECT'
CREATE TABLE t1 (a int not null, b char (10) not null);
insert into t1 values(1,'a'),(2,'b'),(3,'c'),(3,'c');
CREATE TABLE t2 (a int not null, b char (10) not null);
insert into t2 values (3,'c'),(4,'d'),(5,'f'),(6,'e');
select t1.a,t3.y from t1,(select a as y from t2  where b='c') as t3  where t1.a = t3.y;
a	y
3	3
3	3
select t1.a,t3.a from t1,(select * from t2  where b='c') as t3  where t1.a = t3.a;
a	a
3	3
3	3
CREATE TABLE t3 (a int not null, b char (10) not null);
insert into t3 values (3,'f'),(4,'y'),(5,'z'),(6,'c');
select t1.a,t4.y from t1,(select t2.a as y from t2,(select t3.b from t3 where t3.a>3) as t5  where t2.b=t5.b) as t4  where t1.a = t4.y;
a	y
3	3
3	3
SELECT a FROM (SELECT 1 FROM (SELECT 1) a HAVING a=1) b;
ERROR 42S22: Unknown column 'a' in 'HAVING'
SELECT a,b as a FROM (SELECT '1' as a,'2' as b) b  HAVING a=1;
ERROR 23000: Column 'a' in HAVING is ambiguous
SELECT a,2 as a FROM (SELECT '1' as a) b HAVING a=2;
a	a
1	2
SELECT a,2 as a FROM (SELECT '1' as a) b HAVING a=1;
a	a
SELECT 1 FROM (SELECT 1) a WHERE a=2;
ERROR 42S22: Unknown column 'a' in 'WHERE'
SELECT (SELECT 1) as a FROM (SELECT 1 FROM t1  HAVING a=1) as a;
ERROR 42S22: Unknown column 'a' in 'HAVING'
select * from t1 as x1, (select * from t1) as x2;
a	b	a	b
1	a	1	a
2	b	1	a
3	c	1	a
3	c	1	a
1	a	2	b
2	b	2	b
3	c	2	b
3	c	2	b
1	a	3	c
2	b	3	c
3	c	3	c
3	c	3	c
1	a	3	c
2	b	3	c
3	c	3	c
3	c	3	c
explain select * from t1 as x1, (select * from t1) as x2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	x1	ALL	NULL	NULL	NULL	NULL	4	
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	4	Using join buffer (flat, BNL join)
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	4	
drop table if exists  t2,t3;
select * from (select 1) as a;
1
1
select a from (select 1 as a) as b;
a
1
select 1 from (select 1) as a;
1
1
select * from (select * from t1 union select * from t1) a;
a	b
1	a
2	b
3	c
select * from (select * from t1 union all select * from t1) a;
a	b
1	a
2	b
3	c
3	c
1	a
2	b
3	c
3	c
select * from (select * from t1 union all select * from t1 limit 2) a;
a	b
1	a
2	b
explain select * from (select * from t1 union select * from t1) a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	8	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	4	
3	UNION	t1	ALL	NULL	NULL	NULL	NULL	4	
NULL	UNION RESULT	<union2,3>	ALL	NULL	NULL	NULL	NULL	NULL	
explain select * from (select * from t1 union all select * from t1) a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	8	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	4	
3	UNION	t1	ALL	NULL	NULL	NULL	NULL	4	
CREATE TABLE t2 (a int not null);
insert into t2 values(1);
select * from (select * from t1 where t1.a=(select a from t2 where t2.a=t1.a)) a;
a	b
1	a
select * from (select * from t1 where t1.a=(select t2.a from t2 where t2.a=t1.a) union select t1.a, t1.b from t1) a;
a	b
1	a
2	b
3	c
explain select * from (select t1.*, t2.a as t2a from t1,t2 where t1.a=t2.a) t1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	4	
2	DERIVED	t2	system	NULL	NULL	NULL	NULL	1	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
drop table t1, t2;
create table t1(a int not null, t char(8), index(a));
SELECT * FROM (SELECT * FROM t1) as b ORDER BY a  ASC LIMIT 0,20;
a	t
1	1
2	2
3	3
4	4
5	5
6	6
7	7
8	8
9	9
10	10
11	11
12	12
13	13
14	14
15	15
16	16
17	17
18	18
19	19
20	20
explain select count(*) from t1 as tt1, (select * from t1) as tt2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	tt1	index	NULL	a	4	NULL	10000	Using index
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	10000	Using join buffer (flat, BNL join)
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	10000	
drop table t1;
SELECT * FROM (SELECT (SELECT * FROM (SELECT 1 as a) as a )) as b;
(SELECT * FROM (SELECT 1 as a) as a )
1
select * from (select 1 as a) b  left join (select 2 as a) c using(a);
a
1
SELECT * FROM (SELECT 1 UNION SELECT a) b;
ERROR 42S22: Unknown column 'a' in 'SELECT'
SELECT 1 as a FROM (SELECT a UNION SELECT 1) b;
ERROR 42S22: Unknown column 'a' in 'SELECT'
SELECT 1 as a FROM (SELECT 1 UNION SELECT a) b;
ERROR 42S22: Unknown column 'a' in 'SELECT'
select 1 from  (select 2) a order by 0;
ERROR 42S22: Unknown column '0' in 'ORDER BY'
create table t1 (id int);
insert into t1 values (1),(2),(3);
describe select * from (select * from t1 group by id) bar;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	3	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	3	Using temporary; Using filesort
drop table t1;
create table t1 (mat_id MEDIUMINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, matintnum CHAR(6) NOT NULL, test MEDIUMINT UNSIGNED NULL);
create table t2 (mat_id MEDIUMINT UNSIGNED NOT NULL, pla_id MEDIUMINT UNSIGNED NOT NULL);
insert into t1 values (NULL, 'a', 1), (NULL, 'b', 2), (NULL, 'c', 3), (NULL, 'd', 4), (NULL, 'e', 5), (NULL, 'f', 6), (NULL, 'g', 7), (NULL, 'h', 8), (NULL, 'i', 9);
insert into t2 values (1, 100), (1, 101), (1, 102), (2, 100), (2, 103), (2, 104), (3, 101), (3, 102), (3, 105);
SELECT STRAIGHT_JOIN d.pla_id, m2.mat_id FROM t1 m2 INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;
pla_id	mat_id
100	1
101	1
102	1
103	2
104	2
105	3
SELECT STRAIGHT_JOIN d.pla_id, m2.test FROM t1 m2  INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;
pla_id	test
100	1
101	1
102	1
103	2
104	2
105	3
explain SELECT STRAIGHT_JOIN d.pla_id, m2.mat_id FROM t1 m2 INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	m2	ALL	NULL	NULL	NULL	NULL	9	
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	9	Using where; Using join buffer (flat, BNL join)
2	DERIVED	mp	ALL	NULL	NULL	NULL	NULL	9	Using temporary; Using filesort
2	DERIVED	m1	eq_ref	PRIMARY	PRIMARY	3	test.mp.mat_id	1	
explain SELECT STRAIGHT_JOIN d.pla_id, m2.test FROM t1 m2  INNER JOIN (SELECT mp.pla_id, MIN(m1.matintnum) AS matintnum FROM t2 mp INNER JOIN t1 m1 ON mp.mat_id=m1.mat_id GROUP BY mp.pla_id) d ON d.matintnum=m2.matintnum;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	m2	ALL	NULL	NULL	NULL	NULL	9	
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	9	Using where; Using join buffer (flat, BNL join)
2	DERIVED	mp	ALL	NULL	NULL	NULL	NULL	9	Using temporary; Using filesort
2	DERIVED	m1	eq_ref	PRIMARY	PRIMARY	3	test.mp.mat_id	1	
drop table t1,t2;
SELECT a.x FROM (SELECT 1 AS x) AS a HAVING a.x = 1;
x
1
create user mysqltest_1;
grant all on test.* to mysqltest_1;
create table t1 select 1 as a;
connect  con1,localhost,mysqltest_1,,*NO-ONE*,$MASTER_MYPORT,$MASTER_MYSOCK;
connection con1;
set optimizer_switch='derived_merge=off,derived_with_keys=off';
select 2 as a from (select * from t1) b;
ERROR 3D000: No database selected
use test;
select 2 as a from (select * from t1) b;
a
2
drop table t1;
select mail_id,  if(folder.f_description!='', folder.f_description, folder.f_name) as folder_name,  date, address_id, phrase, address,  subject from folder, (select  mail.mail_id as mail_id,  date_format(mail.h_date, '%b %e, %Y %h:%i') as date,  mail.folder_id,  sender.address_id as address_id,  sender.phrase as phrase, sender.address as address,    mail.h_subject as subject from    mail left join mxa as mxa_sender on mail.mail_id=mxa_sender.mail_id and mxa_sender.type='from' left join address as sender on mxa_sender.address_id=sender.address_id  mxa as mxa_recipient,   address as recipient, where 1     and mail.mail_id=mxa_recipient.mail_id   and mxa_recipient.address_id=recipient.address_id   and mxa_recipient.type='to'  and  match(sender.phrase, sender.address, sender.comment) against ('jeremy' in boolean mode)   and  match(recipient.phrase, recipient.address, recipient.comment) against ('monty' in boolean mode) order by mail.h_date desc limit 0, 25 ) as query where query.folder_id=folder.folder_id;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'mxa as mxa_recipient,   address as recipient, where 1     and mail.mail_id=mx...' at line 1
create table t1 (a int);
insert into t1 values (1),(2),(3);
update (select * from t1) as t1 set a = 5;
ERROR HY000: The target table t1 of the UPDATE is not updatable
delete from (select * from t1);
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '(select * from t1)' at line 1
insert into  (select * from t1) values (5);
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '(select * from t1) values (5)' at line 1
drop table t1;
create table t1 (E1 INTEGER UNSIGNED NOT NULL, E2 INTEGER UNSIGNED NOT NULL, E3 INTEGER UNSIGNED NOT NULL, PRIMARY KEY(E1)
);
insert into t1 VALUES(1,1,1), (2,2,1);
select count(*) from t1 INNER JOIN (SELECT A.E1, A.E2, A.E3 FROM t1 AS A WHERE A.E3 = (SELECT MAX(B.E3) FROM t1 AS B WHERE A.E2 = B.E2)) AS THEMAX ON t1.E1 = THEMAX.E2 AND t1.E1 = t1.E2;
count(*)
2
explain select count(*) from t1 INNER JOIN (SELECT A.E1, A.E2, A.E3 FROM t1 AS A WHERE A.E3 = (SELECT MAX(B.E3) FROM t1 AS B WHERE A.E2 = B.E2)) AS THEMAX ON t1.E1 = THEMAX.E2 AND t1.E1 = t1.E2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	2	
1	PRIMARY	t1	eq_ref	PRIMARY	PRIMARY	4	THEMAX.E2	1	Using where
2	DERIVED	A	ALL	NULL	NULL	NULL	NULL	2	Using where
3	DEPENDENT SUBQUERY	B	ALL	NULL	NULL	NULL	NULL	2	Using where
drop table t1;
create table t1 (a int);
insert into t1 values (1),(2);
select * from ( select * from t1 union select * from t1) a,(select * from t1 union select * from t1) b;
a	a
1	1
2	1
1	2
2	2
explain select * from ( select * from t1 union select * from t1) a,(select * from t1 union select * from t1) b;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	4	
1	PRIMARY	<derived4>	ALL	NULL	NULL	NULL	NULL	4	Using join buffer (flat, BNL join)
4	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	2	
5	UNION	t1	ALL	NULL	NULL	NULL	NULL	2	
NULL	UNION RESULT	<union4,5>	ALL	NULL	NULL	NULL	NULL	NULL	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	2	
3	UNION	t1	ALL	NULL	NULL	NULL	NULL	2	
NULL	UNION RESULT	<union2,3>	ALL	NULL	NULL	NULL	NULL	NULL	
drop table t1;
CREATE TABLE `t1` (
`N` int(11) unsigned NOT NULL default '0',
`M` tinyint(1) default '0'
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO `t1` (N, M) VALUES (1, 0),(1, 0),(1, 0),(2, 0),(2, 0),(3, 0);
UPDATE `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2;
select * from t1;
N	M
1	2
1	2
1	2
2	2
2	2
3	0
UPDATE `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2, P2.N = 2;
ERROR HY000: The target table P2 of the UPDATE is not updatable
UPDATE `t1` AS P1 INNER JOIN (SELECT aaaa FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N SET P1.M = 2;
ERROR 42S22: Unknown column 'aaaa' in 'SELECT'
delete P1.* from `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N;
select * from t1;
N	M
3	0
delete P1.*,p2.* from `t1` AS P1 INNER JOIN (SELECT N FROM `t1` GROUP BY N HAVING Count(M) > 1) AS p2 ON P1.N = p2.N;
ERROR HY000: The target table p2 of the DELETE is not updatable
delete P1.* from `t1` AS P1 INNER JOIN (SELECT aaa FROM `t1` GROUP BY N HAVING Count(M) > 1) AS P2 ON P1.N = P2.N;
ERROR 42S22: Unknown column 'aaa' in 'SELECT'
drop table t1;
CREATE TABLE t1 (
OBJECTID int(11) NOT NULL default '0',
SORTORDER int(11) NOT NULL auto_increment,
KEY t1_SortIndex (SORTORDER),
KEY t1_IdIndex (OBJECTID)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
CREATE TABLE t2 (
ID int(11) default NULL,
PARID int(11) default NULL,
UNIQUE KEY t2_ID_IDX (ID),
KEY t2_PARID_IDX (PARID)
) engine=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO t2 VALUES (1000,0),(1001,0),(1002,0),(1003,0),(1008,1),(1009,1),(1010,1),(1011,1),(1016,2);
CREATE TABLE t3 (
ID int(11) default NULL,
DATA decimal(10,2) default NULL,
UNIQUE KEY t3_ID_IDX (ID)
) engine=MyISAM DEFAULT CHARSET=latin1;
INSERT INTO t3 VALUES (1000,0.00),(1001,0.25),(1002,0.50),(1003,0.75),(1008,1.00),(1009,1.25),(1010,1.50),(1011,1.75);
select 497, TMP.ID, NULL from (select 497 as ID, MAX(t3.DATA) as DATA      from t1 join t2 on (t1.ObjectID = t2.ID) join t3 on (t1.ObjectID = t3.ID) group by t2.ParID order by DATA DESC) as TMP;
497	ID	NULL
drop table t1, t2, t3;
CREATE TABLE t1 (name char(1) default NULL, val int(5) default NULL);
INSERT INTO t1 VALUES ('a',1),  ('a',2),  ('a',2),  ('a',2),  ('a',3),  ('a',6), ('a',7), ('a',11), ('a',11), ('a',12), ('a',13), ('a',13), ('a',20), ('b',2), ('b',3), ('b',4), ('b',5);
SELECT s.name, AVG(s.val) AS median FROM (SELECT x.name, x.val FROM t1 x, t1 y WHERE x.name=y.name GROUP BY x.name, x.val HAVING SUM(y.val <= x.val) >= COUNT(*)/2 AND SUM(y.val >= x.val) >= COUNT(*)/2) AS s GROUP BY s.name;
name	median
a	7.0000
b	3.5000
explain SELECT s.name, AVG(s.val) AS median FROM (SELECT x.name, x.val FROM t1 x, t1 y WHERE x.name=y.name GROUP BY x.name, x.val HAVING SUM(y.val <= x.val) >= COUNT(*)/2 AND SUM(y.val >= x.val) >= COUNT(*)/2) AS s GROUP BY s.name;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	17	Using temporary; Using filesort
2	DERIVED	x	ALL	NULL	NULL	NULL	NULL	17	Using temporary; Using filesort
2	DERIVED	y	ALL	NULL	NULL	NULL	NULL	17	Using where; Using join buffer (flat, BNL join)
drop table t1;
create table t2 (a int, b int, primary key (a));
insert into t2 values (1,7),(2,7);
explain select a from t2 where a>1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t2	range	PRIMARY	PRIMARY	4	NULL	1	Using where; Using index
explain select a from (select a from t2 where a>1) tt;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	2	
2	DERIVED	t2	range	PRIMARY	PRIMARY	4	NULL	1	Using where; Using index
drop table t2;
CREATE TABLE `t1` ( `itemid` int(11) NOT NULL default '0', `grpid` varchar(15) NOT NULL default '', `vendor` int(11) NOT NULL default '0', `date_` date NOT NULL default '0000-00-00', `price` decimal(12,2) NOT NULL default '0.00', PRIMARY KEY  (`itemid`,`grpid`,`vendor`,`date_`), KEY `itemid` (`itemid`,`vendor`), KEY `itemid_2` (`itemid`,`date_`));
insert into t1 values (128, 'rozn', 2, curdate(), 10),
(128, 'rozn', 1, curdate(), 10);
SELECT MIN(price) min, MAX(price) max, AVG(price) avg FROM (SELECT SUBSTRING( MAX(concat(date_,";",price)), 12) price FROM t1 WHERE itemid=128 AND  grpid='rozn' GROUP BY itemid, grpid, vendor) lastprices;
min	max	avg
10.00	10.00	10
DROP TABLE t1;
create table t1 (a integer, b integer);
insert into t1 values (1,4), (2,2),(2,2), (4,1),(4,1),(4,1),(4,1);
select distinct sum(b) from t1 group by a;
sum(b)
4
select distinct sum(b) from (select a,b from t1) y group by a;
sum(b)
4
drop table t1;
CREATE TABLE t1 (a char(10), b char(10));
INSERT INTO t1 VALUES ('root','localhost'), ('root','%');
SELECT * FROM (SELECT (SELECT a.a FROM t1 AS a WHERE a.a = b.a) FROM t1 AS b) AS c;
ERROR 21000: Subquery returns more than 1 row
DROP TABLE t1;
create table t1(a int);
create table t2(a int);
create table t3(a int);
insert into t1 values(1),(1);
insert into t2 values(2),(2);
insert into t3 values(3),(3);
select * from t1 union distinct select * from t2 union all select * from t3;
a
1
2
3
3
select * from (select * from t1 union distinct select * from t2 union all select * from t3) X;
a
1
2
3
3
set @save2_derived_optimizer_switch_bug=@@optimizer_switch;
set @@optimizer_switch=default;
select * from (select * from t1 union distinct select * from t2 union all select * from t3) X;
a
1
2
3
3
set @@optimizer_switch=@save2_derived_optimizer_switch_bug;
drop table t1, t2, t3;
create table t1 (a int);
create table t2 (a int);
select * from (select * from t1,t2) foo;
ERROR 42S21: Duplicate column name 'a'
drop table t1,t2;
create table t1 (ID int unsigned not null auto_increment,
DATA varchar(5) not null, primary key (ID));
create table t2 (ID int unsigned not null auto_increment,
DATA varchar(5) not null, FID int unsigned not null,
primary key (ID));
select A.* from (t1 inner join (select * from t2) as A on t1.ID = A.FID);
ID	DATA	FID
select t2.* from ((select * from t1) as A inner join t2 on A.ID = t2.FID);
ID	DATA	FID
select t2.* from (select * from t1) as A inner join t2 on A.ID = t2.FID;
ID	DATA	FID
drop table t1, t2;
connection con1;
disconnect con1;
connection default;
drop user mysqltest_1;
# End of 4.1 tests
SELECT 0 FROM
(SELECT 0) t01, (SELECT 0) t02, (SELECT 0) t03, (SELECT 0) t04, (SELECT 0) t05,
(SELECT 0) t06, (SELECT 0) t07, (SELECT 0) t08, (SELECT 0) t09, (SELECT 0) t10,
(SELECT 0) t11, (SELECT 0) t12, (SELECT 0) t13, (SELECT 0) t14, (SELECT 0) t15,
(SELECT 0) t16, (SELECT 0) t17, (SELECT 0) t18, (SELECT 0) t19, (SELECT 0) t20,
(SELECT 0) t21, (SELECT 0) t22, (SELECT 0) t23, (SELECT 0) t24, (SELECT 0) t25,
(SELECT 0) t26, (SELECT 0) t27, (SELECT 0) t28, (SELECT 0) t29, (SELECT 0) t30,
(SELECT 0) t31, (SELECT 0) t32, (SELECT 0) t33, (SELECT 0) t34, (SELECT 0) t35,
(SELECT 0) t36, (SELECT 0) t37, (SELECT 0) t38, (SELECT 0) t39, (SELECT 0) t40,
(SELECT 0) t41, (SELECT 0) t42, (SELECT 0) t43, (SELECT 0) t44, (SELECT 0) t45,
(SELECT 0) t46, (SELECT 0) t47, (SELECT 0) t48, (SELECT 0) t49, (SELECT 0) t50,
(SELECT 0) t51, (SELECT 0) t52, (SELECT 0) t53, (SELECT 0) t54, (SELECT 0) t55,
(SELECT 0) t56, (SELECT 0) t57, (SELECT 0) t58, (SELECT 0) t59, (SELECT 0) t60,
(SELECT 0) t61;
0
0
#
#  A nested materialized derived table is used before being populated.
#  (addon for bug#19077)
#
CREATE TABLE t1 (i INT, j BIGINT);
INSERT INTO t1 VALUES (1, 2), (2, 2), (3, 2);
SELECT * FROM (SELECT MIN(i) FROM t1
WHERE j = SUBSTRING('12', (SELECT * FROM (SELECT MIN(j) FROM t1) t2))) t3;
MIN(i)
1
DROP TABLE t1;
# End of 5.0 tests
#
# MDEV-5005: Subquery in Procedure somehow affecting temporary table
#
create temporary table if not exists t1 (id int not null);
select A.* from ( select tt.* from t1 tt ) A;
id
prepare stmt from "select A.* from ( select tt.* from t1 tt ) A ";
execute stmt;
id
deallocate prepare stmt;
drop temporary table t1;
CREATE PROCEDURE p ()
BEGIN
select A.* from ( select tt.* from t1 tt ) A ;
END |
create temporary table if not exists t1 (id int not null);
CALL p();
id
CALL p();
id
drop procedure p;
drop temporary table t1;
#
# MDEV-5143: update of a joined table with a nested subquery with 
# a syntax error crashes mysqld with signal 11
#
create table t1 (id int(11) not null auto_increment, val varchar(100) null,primary key (id));
create table t2 (id int(11) not null auto_increment, val varchar(100) null,primary key (id));
insert into t1 (val) values('a');
insert into t2 (val) values('1');
update 
(
select 
val
from
(
select 
v.val
from 
t2 wrong_table_alias
) t4
) t3
inner join t1 on 
t1.id=t3.val
set 
t1.val=t3.val
;
ERROR 42S22: Unknown column 'v.val' in 'SELECT'
drop table t1, t2;
#
# MDEV-5353: server crash on subselect if WHERE applied to some
# result field
#
SELECT * FROM 
( SELECT 100 a, subsel.b FROM ( SELECT 200 b ) subsel ) tmp
WHERE tmp.b;
a	b
100	200
SELECT * FROM 
( SELECT 100 a, subsel.b FROM ( SELECT 200 b ) subsel ) tmp
WHERE tmp.a;
a	b
100	200
#
# MDEV-5356: Server crashes in Item_equal::contains on 2nd
# execution of a PS
#
CREATE TABLE t1 (a INT, b INT);
INSERT INTO t1 VALUES (1,2),(3,4);
CREATE TABLE t2 (c INT);
INSERT INTO t2 VALUES (5),(6);
CREATE TABLE t3 (d INT);
INSERT INTO t3 VALUES (7),(8);
CREATE PROCEDURE pr()
UPDATE t3,
(SELECT c FROM
(SELECT 1 FROM t1 WHERE a=72 AND NOT b) sq, 
t2
) sq2
SET d=sq2.c;
CALL pr();
CALL pr();
CALL pr();
drop procedure pr;
drop table t1,t2,t3;
# End of 5.3 tests
#
# Bug#58730 Assertion failed: table->key_read == 0 in close_thread_table,
#           temptable views
#
CREATE TABLE t1 (a INT);
CREATE TABLE t2 (b INT, KEY (b));
INSERT INTO t1 VALUES (1),(1);
INSERT INTO t2 VALUES (1),(1);
CREATE algorithm=temptable VIEW v1 AS
SELECT 1 FROM t1 LEFT JOIN t1 t3 ON 1 > (SELECT 1 FROM t1);
CREATE algorithm=temptable VIEW v2 AS SELECT 1 FROM t2;
EXPLAIN SELECT 1 FROM t1 JOIN v1 ON 1 > (SELECT 1 FROM v2);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	2	
1	PRIMARY	<derived3>	ALL	NULL	NULL	NULL	NULL	4	Using join buffer (flat, BNL join)
3	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	2	
3	DERIVED	t3	ALL	NULL	NULL	NULL	NULL	2	Using where; Using join buffer (flat, BNL join)
4	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	2	
2	SUBQUERY	<derived5>	ALL	NULL	NULL	NULL	NULL	2	
5	DERIVED	t2	index	NULL	b	5	NULL	2	Using index
SELECT 1 FROM t1 JOIN v1 ON 1 > (SELECT 1 FROM v2);
ERROR 21000: Subquery returns more than 1 row
DROP TABLE t1, t2;
DROP VIEW v1, v2;
create table t1 (n bigint(20) unsigned, d1 datetime, d2 datetime, key (d1));
insert t1 values (2085,'2012-01-01 00:00:00','2013-01-01 00:00:00');
insert t1 values (2084,'2012-02-01 00:00:00','2013-01-01 00:00:00');
insert t1 values (2088,'2012-03-01 00:00:00','2013-01-01 00:00:00');
select * from (
select n, d1, d2, @result := 0 as result
from t1
where d1 < '2012-12-12 12:12:12' and n in (2085, 2084) order by d2 asc
) as calculated_result;
n	d1	d2	result
2085	2012-01-01 00:00:00	2013-01-01 00:00:00	0
2084	2012-02-01 00:00:00	2013-01-01 00:00:00	0
drop table t1;
set @save_derived_optimizer_switch_bug=@@optimizer_switch;
SET optimizer_switch = 'derived_merge=on,derived_with_keys=on,in_to_exists=on';
CREATE TABLE t1 (a INT) ENGINE=MyISAM;
INSERT INTO t1 VALUES (8);
CREATE TABLE t2 (b INT) ENGINE=MyISAM;
INSERT INTO t2 VALUES (1),(7);
EXPLAIN SELECT * FROM (SELECT * FROM t1) AS table1,
(SELECT DISTINCT * FROM t2) AS table2 WHERE b = a AND a <> ANY (SELECT 9);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	system	NULL	NULL	NULL	NULL	1	
1	PRIMARY	<derived3>	ref	key0	key0	5	const	0	
3	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	2	Using where; Using temporary
Warnings:
Note	1249	Select 4 was reduced during optimization
DROP TABLE t1, t2;
set optimizer_switch=@save_derived_optimizer_switch_bug;
#
# MDEV-6163: Error while executing an update query that has the
# same table in a sub-query
#
set @save_derived_optimizer_switch_bug=@@optimizer_switch;
SET optimizer_switch = 'derived_merge=on';
create table t1 (balance float, accountId varchar(64), primary key (accountId));
insert into t1 (accountId,balance) values 
('dealer-1',199354.0),('dealer-2',0),('dealer-3',0),('dealer-5',0),('FINANCE',-200000),('OPERATOR',0);
update t1 set balance=(select sum(balance) from (SELECT balance FROM t1 where accountId like 'dealer%') AS copied) where accountId = 'OPERATOR';
set optimizer_switch=@save_derived_optimizer_switch_bug;
drop table t1;
#
# MDEV-6219:Server crashes in Bitmap<64u>::merge
# (this=0x180, map2=...) on 2nd execution of PS with INSERT .. SELECT,
# derived_merge
#
CREATE TABLE t1 (a VARCHAR(8)) ENGINE=MyISAM;
INSERT INTO t1 VALUES ('foo'),('bar');
create procedure p1()
INSERT INTO t1 SELECT * FROM ( 
SELECT * FROM t1
) AS sq
WHERE sq.a IN ( SELECT 'baz' FROM DUAL );
call p1();
call p1();
drop procedure p1;
PREPARE stmt FROM "
  INSERT INTO t1 SELECT * FROM ( 
    SELECT * FROM t1
  ) AS sq
  WHERE sq.a IN ( SELECT 'baz' FROM DUAL ) 
";
EXECUTE stmt;
EXECUTE stmt;
deallocate prepare stmt;
drop table t1;
#
# MDEV-6892: WHERE does not apply
#
create table t1 (id int);
create table t2 (id int);
insert into t1 values(1),(2),(3);
insert into t2 values(4),(5),(6);
select x.id, message from (select id from t1) x left join
(select id, 1 as message from t2) y on x.id=y.id
where coalesce(message,0) <> 0;
id	message
explain extended
select x.id, message from (select id from t1) x left join
(select id, 1 as message from t2) y on x.id=y.id
where message <> 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	3	100.00	
1	PRIMARY	<derived3>	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where; Using join buffer (flat, BNL join)
3	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	3	100.00	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	3	100.00	
Warnings:
Note	1003	/* select#1 */ select `x`.`id` AS `id`,`y`.`message` AS `message` from (/* select#2 */ select `test`.`t1`.`id` AS `id` from `test`.`t1`) `x` join (/* select#3 */ select `test`.`t2`.`id` AS `id`,1 AS `message` from `test`.`t2`) `y` where `y`.`id` = `x`.`id` and `y`.`message` <> 0
drop table t1,t2;
#
# MDEV-7827: Assertion `!table || (!table->read_set ||
# bitmap_is_set(table->read_set, field_index))' failed
# in Field_long::val_str on EXPLAIN EXTENDED
#
CREATE TABLE t1 (f1 INT, f2 INT, KEY(f2)) ENGINE=MyISAM;
INSERT INTO t1 VALUES (6,9);
CREATE TABLE t2 (f3 INT) ENGINE=MyISAM;
INSERT INTO t2 VALUES (2),(0);
EXPLAIN EXTENDED
SELECT f1 FROM ( SELECT * FROM t1 ) AS sq
WHERE f1 IN (
SELECT f3 FROM t2 WHERE f2 IN (
SELECT f3 FROM t2 HAVING f3 >= 8
)
);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	<derived2>	system	NULL	NULL	NULL	NULL	1	100.00	
1	PRIMARY	<subquery4>	eq_ref	distinct_key	distinct_key	4	const	1	100.00	
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	2	50.00	Using where; FirstMatch(<subquery4>); Using join buffer (flat, BNL join)
4	MATERIALIZED	t2	ALL	NULL	NULL	NULL	NULL	2	100.00	
2	DERIVED	t1	system	NULL	NULL	NULL	NULL	1	100.00	
Warnings:
Note	1276	Field or reference 'sq.f2' of SELECT #3 was resolved in SELECT #1
Note	1003	/* select#1 */ select 6 AS `f1` from  <materialize> (/* select#4 */ select `test`.`t2`.`f3` from `test`.`t2` having `test`.`t2`.`f3` >= 8) semi join (`test`.`t2`) where `<subquery4>`.`f3` = 9 and `test`.`t2`.`f3` = 6
DROP TABLE t2,t1;
#
# MDEV-9462: Out of memory using explain on 2 empty tables 
#
CREATE TABLE `t1` (
`REC_GROUP` char(2) DEFAULT NULL,
`CLIENT_INFO` text CHARACTER SET utf8,
`NAME` text,
`PHONE_NUMBER` text,
`ATTENTION_NAME` text,
`PAYMENT_TERM` text CHARACTER SET utf8,
`CREDIT_LIMIT` decimal(12,2) DEFAULT NULL,
`LAST_PAY_DATE` text CHARACTER SET utf8,
`TOTAL` double DEFAULT NULL,
`TOTAL_MCL` double DEFAULT NULL,
`TOTAL_MFS` double DEFAULT NULL,
`TOTAL_MIS` double DEFAULT NULL,
`BEFORE_DUE_7_MCL` double DEFAULT NULL,
`BEFORE_DUE_7_MFS` double DEFAULT NULL,
`BEFORE_DUE_7_MIS` double DEFAULT NULL,
`PER1_MCL` double DEFAULT NULL,
`PER1_MFS` double DEFAULT NULL,
`PER1_MIS` double DEFAULT NULL,
`PER2_MCL` double DEFAULT NULL,
`PER2_MFS` double DEFAULT NULL,
`PER2_MIS` double DEFAULT NULL,
`PER3_MCL` double DEFAULT NULL,
`PER3_MFS` double DEFAULT NULL,
`PER3_MIS` double DEFAULT NULL,
`PER4_MCL` double DEFAULT NULL,
`PER4_MFS` double DEFAULT NULL,
`PER4_MIS` double DEFAULT NULL,
`PER5_MCL` double DEFAULT NULL,
`PER5_MFS` double DEFAULT NULL,
`PER5_MIS` double DEFAULT NULL,
`PER6_MCL` double DEFAULT NULL,
`PER6_MFS` double DEFAULT NULL,
`PER6_MIS` double DEFAULT NULL,
`PER7_MCL` double DEFAULT NULL,
`PER7_MFS` double DEFAULT NULL,
`PER7_MIS` double DEFAULT NULL,
`BEFORE_DUE_7` double DEFAULT NULL,
`PER1` double DEFAULT NULL,
`PER2` double DEFAULT NULL,
`PER3` double DEFAULT NULL,
`PER4` double DEFAULT NULL,
`PER5` double DEFAULT NULL,
`PER6` double DEFAULT NULL,
`PER7` double DEFAULT NULL,
`REF` varchar(30) DEFAULT NULL,
`TYPE` varchar(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL
);
CREATE TABLE `t2` (
`RECEIVABLE_GROUP` char(2) DEFAULT NULL,
`CLIENT_NUMBER` varchar(35) DEFAULT NULL,
`CLIENT_NAME` varchar(73) DEFAULT NULL,
`PHONE_NUMBER` char(12) DEFAULT NULL,
`ATTENTION_NAME` char(26) DEFAULT NULL,
`PAYMENT_TERM` varchar(26) CHARACTER SET utf8 DEFAULT NULL,
`CREDIT_LIMIT` decimal(12,2) DEFAULT NULL,
`LAST_PAY_DATE` varchar(42) CHARACTER SET utf8 DEFAULT NULL,
`TOTAL` decimal(12,2) DEFAULT NULL,
`BEFORE_DUE_7` decimal(12,2) DEFAULT NULL,
`PER1` decimal(12,2) DEFAULT NULL,
`PER2` decimal(12,2) DEFAULT NULL,
`PER3` decimal(12,2) DEFAULT NULL,
`PER4` decimal(12,2) DEFAULT NULL,
`PER5` decimal(12,2) DEFAULT NULL,
`PER6` decimal(12,2) DEFAULT NULL,
`PER7` decimal(12,2) DEFAULT NULL,
`DIVISION` varchar(3) CHARACTER SET utf8 NOT NULL,
`CLIENT_INFO` varchar(294) CHARACTER SET utf8 DEFAULT NULL,
`EXCHANGE_RATE` double NOT NULL,
`REF` varchar(30) DEFAULT NULL
);
explain
SELECT A.RECEIVABLE_GROUP,A.CLIENT_INFO,A.CLIENT_NAME,A.PHONE_NUMBER,A.ATTENTION_NAME,A.PAYMENT_TERM,A.CREDIT_LIMIT,A.LAST_PAY_DATE,A.TOTAL,
COALESCE(B.TOTAL_MCL,0) AS TOTAL_MCL,
COALESCE(C.TOTAL_MFS,0) AS TOTAL_MFS,
COALESCE(D.TOTAL_MIS,0) AS TOTAL_MIS,
COALESCE(F.BEFORE_DUE_7_MCL,0) AS BEFORE_DUE_7_MCL,
COALESCE(G.BEFORE_DUE_7_MFS,0) AS BEFORE_DUE_7_MFS,
COALESCE(H.BEFORE_DUE_7_MIS,0) AS BEFORE_DUE_7_MIS,
COALESCE(I.PER1_MCL,0) AS PER1_MCL,
COALESCE(J.PER1_MFS,0) AS PER1_MFS,
COALESCE(K.PER1_MIS,0) AS PER1_MIS,
COALESCE(L.PER2_MCL,0) AS PER2_MCL,
COALESCE(M.PER2_MFS,0) AS PER2_MFS,
COALESCE(N.PER2_MIS,0) AS PER2_MIS,
COALESCE(O.PER3_MCL,0) AS PER3_MCL,
COALESCE(P.PER3_MFS,0) AS PER3_MFS,
COALESCE(R.PER3_MIS,0) AS PER3_MIS,
COALESCE(S.PER4_MCL,0) AS PER4_MCL,
COALESCE(T.PER4_MFS,0) AS PER4_MFS,
COALESCE(U.PER4_MIS,0) AS PER4_MIS,
COALESCE(V.PER5_MCL,0) AS PER5_MCL,
COALESCE(X.PER5_MFS,0) AS PER5_MFS,
COALESCE(Z.PER5_MIS,0) AS PER5_MIS,
COALESCE(Q.PER6_MCL,0) AS PER6_MCL,
COALESCE(Y.PER6_MFS,0) AS PER6_MFS,
COALESCE(W.PER6_MIS,0) AS PER6_MIS,
COALESCE(A1.PER7_MCL,0) AS PER7_MCL,
COALESCE(B1.PER7_MFS,0) AS PER7_MFS,
COALESCE(C1.PER7_MIS,0) AS PER7_MIS,
A.BEFORE_DUE_7,A.PER1,A.PER2,A.PER3,A.PER4,A.PER5,A.PER6,A.PER7,
CONCAT(A.DIVISION,'-',A.CLIENT_NUMBER) AS REF,"2" AS TYPE FROM
(SELECT RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,
GROUP_CONCAT(DISTINCT CLIENT_INFO SEPARATOR '<br>') AS CLIENT_INFO,
GROUP_CONCAT(DISTINCT CLIENT_NAME SEPARATOR '<br>') AS CLIENT_NAME, 
GROUP_CONCAT( DISTINCT `PHONE_NUMBER` SEPARATOR '<br>' ) AS PHONE_NUMBER , 
GROUP_CONCAT( DISTINCT `ATTENTION_NAME` SEPARATOR '<br>' )  AS ATTENTION_NAME, 
GROUP_CONCAT( DISTINCT `PAYMENT_TERM` SEPARATOR '<br>' ) AS PAYMENT_TERM, 
CREDIT_LIMIT , 
GROUP_CONCAT( `LAST_PAY_DATE` SEPARATOR '<br>' ) AS LAST_PAY_DATE, 
SUM( `TOTAL`*EXCHANGE_RATE ) AS TOTAL, 
SUM( `BEFORE_DUE_7`*EXCHANGE_RATE ) AS BEFORE_DUE_7, 
SUM( `PER1`*EXCHANGE_RATE ) AS PER1, 
SUM( `PER2`*EXCHANGE_RATE ) AS PER2, 
SUM( `PER3`*EXCHANGE_RATE ) AS PER3, 
SUM( `PER4`*EXCHANGE_RATE ) AS PER4, 
SUM( `PER5`*EXCHANGE_RATE ) AS PER5, 
SUM( `PER6`*EXCHANGE_RATE ) AS PER6, 
SUM( `PER7`*EXCHANGE_RATE ) AS PER7
FROM `t2`
WHERE REF IS NULL GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS A 
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( `TOTAL`*EXCHANGE_RATE ) AS TOTAL_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS B ON A.CLIENT_NUMBER=B.CLIENT_NUMBER AND 
A.DIVISION=B.DIVISION AND A.RECEIVABLE_GROUP=B.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=B.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( `TOTAL`*EXCHANGE_RATE ) AS TOTAL_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS C ON A.CLIENT_NUMBER=C.CLIENT_NUMBER 
AND 
A.DIVISION=C.DIVISION AND A.RECEIVABLE_GROUP=C.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=C.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( `TOTAL`*EXCHANGE_RATE ) AS TOTAL_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS D ON A.CLIENT_NUMBER=D.CLIENT_NUMBER AND 
A.DIVISION=D.DIVISION AND A.RECEIVABLE_GROUP=D.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=D.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( BEFORE_DUE_7*EXCHANGE_RATE ) AS BEFORE_DUE_7_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS F ON A.CLIENT_NUMBER=F.CLIENT_NUMBER AND 
A.DIVISION=F.DIVISION AND A.RECEIVABLE_GROUP=F.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=F.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( BEFORE_DUE_7*EXCHANGE_RATE ) AS BEFORE_DUE_7_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS G ON A.CLIENT_NUMBER=G.CLIENT_NUMBER AND 
A.DIVISION=G.DIVISION AND A.RECEIVABLE_GROUP=G.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=G.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( BEFORE_DUE_7*EXCHANGE_RATE ) AS BEFORE_DUE_7_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS H ON A.CLIENT_NUMBER=H.CLIENT_NUMBER AND 
A.DIVISION=H.DIVISION AND A.RECEIVABLE_GROUP=H.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=H.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER1*EXCHANGE_RATE ) AS PER1_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS I ON A.CLIENT_NUMBER=I.CLIENT_NUMBER  AND 
A.DIVISION=I.DIVISION AND A.RECEIVABLE_GROUP=I.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=I.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER1*EXCHANGE_RATE ) AS PER1_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS J ON A.CLIENT_NUMBER=J.CLIENT_NUMBER AND 
A.DIVISION=J.DIVISION AND A.RECEIVABLE_GROUP=J.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=J.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER1*EXCHANGE_RATE ) AS PER1_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS K ON A.CLIENT_NUMBER=K.CLIENT_NUMBER AND 
A.DIVISION=K.DIVISION AND A.RECEIVABLE_GROUP=K.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=K.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER2*EXCHANGE_RATE ) AS PER2_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS L ON A.CLIENT_NUMBER=L.CLIENT_NUMBER AND 
A.DIVISION=L.DIVISION AND A.RECEIVABLE_GROUP=L.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=L.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER2*EXCHANGE_RATE ) AS PER2_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS M ON A.CLIENT_NUMBER=M.CLIENT_NUMBER AND 
A.DIVISION=M.DIVISION AND A.RECEIVABLE_GROUP=M.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=M.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER2*EXCHANGE_RATE ) AS PER2_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS N ON A.CLIENT_NUMBER=N.CLIENT_NUMBER AND 
A.DIVISION=N.DIVISION AND A.RECEIVABLE_GROUP=N.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=N.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER3*EXCHANGE_RATE ) AS PER3_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS O ON A.CLIENT_NUMBER=O.CLIENT_NUMBER AND 
A.DIVISION=O.DIVISION AND A.RECEIVABLE_GROUP=O.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=O.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER3*EXCHANGE_RATE ) AS PER3_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS P ON A.CLIENT_NUMBER=P.CLIENT_NUMBER AND 
A.DIVISION=P.DIVISION AND A.RECEIVABLE_GROUP=P.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=P.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER3*EXCHANGE_RATE ) AS PER3_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS R ON A.CLIENT_NUMBER=R.CLIENT_NUMBER AND 
A.DIVISION=R.DIVISION AND A.RECEIVABLE_GROUP=R.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=R.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER4*EXCHANGE_RATE ) AS PER4_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS S ON A.CLIENT_NUMBER=S.CLIENT_NUMBER AND 
A.DIVISION=S.DIVISION AND A.RECEIVABLE_GROUP=S.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=S.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER4*EXCHANGE_RATE ) AS PER4_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS T ON A.CLIENT_NUMBER=T.CLIENT_NUMBER AND 
A.DIVISION=T.DIVISION AND A.RECEIVABLE_GROUP=T.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=T.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER4*EXCHANGE_RATE ) AS PER4_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS U ON A.CLIENT_NUMBER=U.CLIENT_NUMBER AND 
A.DIVISION=U.DIVISION AND A.RECEIVABLE_GROUP=U.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=U.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER5*EXCHANGE_RATE ) AS PER5_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS V ON A.CLIENT_NUMBER=V.CLIENT_NUMBER AND 
A.DIVISION=V.DIVISION AND A.RECEIVABLE_GROUP=V.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=V.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER5*EXCHANGE_RATE ) AS PER5_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS X ON A.CLIENT_NUMBER=X.CLIENT_NUMBER AND 
A.DIVISION=X.DIVISION AND A.RECEIVABLE_GROUP=X.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=X.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER5*EXCHANGE_RATE ) AS PER5_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS Z ON A.CLIENT_NUMBER=Z.CLIENT_NUMBER AND 
A.DIVISION=Z.DIVISION AND A.RECEIVABLE_GROUP=Z.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=Z.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER6*EXCHANGE_RATE ) AS PER6_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS Q ON A.CLIENT_NUMBER=Q.CLIENT_NUMBER AND 
A.DIVISION=Q.DIVISION AND A.RECEIVABLE_GROUP=Q.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=Q.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER6*EXCHANGE_RATE ) AS PER6_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS Y ON A.CLIENT_NUMBER=Y.CLIENT_NUMBER AND 
A.DIVISION=Y.DIVISION AND A.RECEIVABLE_GROUP=Y.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=Y.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER6*EXCHANGE_RATE ) AS PER6_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS W ON A.CLIENT_NUMBER=W.CLIENT_NUMBER AND 
A.DIVISION=W.DIVISION AND A.RECEIVABLE_GROUP=W.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=W.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER7*EXCHANGE_RATE ) AS PER7_MCL
FROM `t2`
WHERE REF IS NULL AND DIVISION="MCL" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS A1 ON A.CLIENT_NUMBER=A1.CLIENT_NUMBER AND 
A.DIVISION=A1.DIVISION AND A.RECEIVABLE_GROUP=A1.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=A1.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER7*EXCHANGE_RATE ) AS PER7_MFS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MFS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS B1 ON A.CLIENT_NUMBER=B1.CLIENT_NUMBER AND 
A.DIVISION=B1.DIVISION AND A.RECEIVABLE_GROUP=B1.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=B1.CREDIT_LIMIT
LEFT JOIN
(SELECT  RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT,SUM( PER7*EXCHANGE_RATE ) AS PER7_MIS
FROM `t2`
WHERE REF IS NULL AND DIVISION="MIS" GROUP BY RECEIVABLE_GROUP,DIVISION,CLIENT_NUMBER,CREDIT_LIMIT) AS C1 ON A.CLIENT_NUMBER=C1.CLIENT_NUMBER AND 
A.DIVISION=C1.DIVISION AND A.RECEIVABLE_GROUP=C1.RECEIVABLE_GROUP AND A.CREDIT_LIMIT=C1.CREDIT_LIMIT
ORDER BY TOTAL DESC;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived3>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived4>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived5>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived6>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived7>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived8>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived9>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived10>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived11>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived12>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived13>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived14>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived15>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived16>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived17>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived18>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived19>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived20>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived21>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived22>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived23>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived24>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived25>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived26>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived27>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived28>	system	NULL	NULL	NULL	NULL	0	Const row not found
1	PRIMARY	<derived29>	system	NULL	NULL	NULL	NULL	0	Const row not found
29	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
28	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
27	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
26	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
25	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
24	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
23	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
22	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
21	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
20	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
19	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
18	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
17	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
16	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
15	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
14	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
13	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
12	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
11	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
10	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
9	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
8	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
7	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
6	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
5	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
4	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
3	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
2	DERIVED	NULL	NULL	NULL	NULL	NULL	NULL	NULL	no matching row in const table
DROP TABLES t1,t2;
set optimizer_switch=@save_derived_optimizer_switch;
#
# MDEV-10663: Use of Inline table columns in HAVING clause
# throws 1463 Error
#
set @save_sql_mode = @@sql_mode;
set sql_mode='ONLY_FULL_GROUP_BY,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';
CREATE TABLE `example1463` (
`Customer` varchar(255) NOT NULL,
`DeliveryStatus` varchar(255) NOT NULL,
`OrderSize` int(11) NOT NULL
);
INSERT INTO example1463 VALUES ('Charlie', 'Success', 100);
INSERT INTO example1463 VALUES ('David', 'Success', 110);
INSERT INTO example1463 VALUES ('Charlie', 'Failed', 200);
INSERT INTO example1463 VALUES ('David', 'Success', 100);
INSERT INTO example1463 VALUES ('David', 'Unknown', 100);
INSERT INTO example1463 VALUES ('Edward', 'Success', 150);
INSERT INTO example1463 VALUES ('Edward', 'Pending', 150);
SELECT Customer, Success, SUM(OrderSize)
FROM (SELECT Customer,
CASE WHEN DeliveryStatus='Success' THEN 'Yes' ELSE 'No' END AS Success,
OrderSize
FROM example1463) as subQ
GROUP BY Success, Customer
WITH ROLLUP;
Customer	Success	SUM(OrderSize)
Charlie	No	200
David	No	100
Edward	No	150
NULL	No	450
Charlie	Yes	100
David	Yes	210
Edward	Yes	150
NULL	Yes	460
NULL	NULL	910
SELECT Customer, Success, SUM(OrderSize)
FROM (SELECT Customer,
CASE WHEN DeliveryStatus='Success' THEN 'Yes' ELSE 'No' END AS Success,
OrderSize
FROM example1463) as subQ
GROUP BY Success, Customer;
Customer	Success	SUM(OrderSize)
Charlie	No	200
David	No	100
Edward	No	150
Charlie	Yes	100
David	Yes	210
Edward	Yes	150
SELECT Customer, Success, SUM(OrderSize)
FROM (SELECT Customer,
CASE WHEN DeliveryStatus='Success' THEN 'Yes' ELSE 'No' END AS Success,
OrderSize
FROM example1463) as subQ
GROUP BY Success, Customer
HAVING Success IS NOT NULL;
Customer	Success	SUM(OrderSize)
Charlie	No	200
David	No	100
Edward	No	150
Charlie	Yes	100
David	Yes	210
Edward	Yes	150
DROP TABLE example1463;
set sql_mode= @save_sql_mode;
#
# MDEV-9028: SELECT DISTINCT constant column of  derived  table
#            used as the second operand of LEFT JOIN
#
create table t1 (id int, data varchar(255));
insert into t1 values (1,'yes'),(2,'yes');
select distinct t1.id, tt.id, tt.data
from t1
left join
(select t1.id, 'yes' as data from t1) as tt
on t1.id = tt.id;
id	id	data
1	1	yes
2	2	yes
select distinct t1.id, tt.id, tt.data
from t1
left join
(select t1.id, 'yes' as data from t1 where id > 1) as tt
on t1.id = tt.id;
id	id	data
2	2	yes
1	NULL	NULL
drop table t1;
#
# MDEV-14241: Server crash in key_copy / get_matching_chain_by_join_key
# or valgrind warnings
#
CREATE TABLE t1 (a VARCHAR(10)) ENGINE=MyISAM;
CREATE OR REPLACE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM t1;
INSERT INTO t1 VALUES ('foo'),('bar');
CREATE TABLE t2 (b integer auto_increment primary key) ENGINE=MyISAM;
INSERT INTO t2 VALUES (NULL),(NULL);
CREATE TABLE t3 (c VARCHAR(1024) CHARACTER SET utf8, d INT) ENGINE=MyISAM;
CREATE OR REPLACE ALGORITHM=TEMPTABLE VIEW v3 AS SELECT * FROM t3;
INSERT INTO t3 VALUES ('abc',NULL),('def',4);
INSERT INTO t1 select seq from seq_1_to_1000;
INSERT INTO t2 select seq+1000 from seq_1_to_1000;
INSERT INTO t3 select 'qqq',seq+2000 from seq_1_to_1000;
set @save_join_cache_level= @@join_cache_level;
SET join_cache_level= 8;
explain
SELECT * FROM v1, t2, v3 WHERE a = c AND b = d;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	1002	
1	PRIMARY	<derived3>	hash_ALL	NULL	#hash#$hj	3075	func	1002	Using where; Using join buffer (flat, BNLH join)
1	PRIMARY	t2	eq_ref	PRIMARY	PRIMARY	4	v3.d	1	Using index
3	DERIVED	t3	ALL	NULL	NULL	NULL	NULL	1002	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	1002	
SELECT * FROM v1, t2, v3 WHERE a = c AND b = d;
a	b	c	d
DROP VIEW v1, v3;
DROP TABLE t1, t2, t3;
#
# MDEV-14786: Server crashes in Item_cond::transform on 2nd
# execution of SP querying from a view
#
create table t1 (i int, row_start timestamp(6) not null default now(),
row_end timestamp(6) not null default '2030-01-01 0:0:0');
create view v1 as select i from t1 where i < 5 and (row_end =
TIMESTAMP'2030-01-01 0:0:0' or row_end is null);
create procedure pr(x int) select i from v1;
call pr(1);
i
call pr(2);
i
drop procedure pr;
drop view v1;
drop table t1;
set @@join_cache_level= @save_join_cache_level;
#
# MDEV-16307: Incorrect results when using BNLH join instead of BNL join with views
#
CREATE TABLE t1 (c1 text, c2 int);
INSERT INTO t1 VALUES ('a',1), ('c',3), ('g',7), ('d',4), ('c',3);
CREATE TABLE t2 (c1 text, c2 int);
INSERT INTO t2 VALUES ('b',2), ('c',3);
CREATE ALGORITHM=TEMPTABLE VIEW v1 AS SELECT * FROM t1;
explain SELECT v1.c1, v1.c2, t2.c1, t2.c2 FROM v1, t2 WHERE v1.c1=t2.c1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	2	
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	5	Using where; Using join buffer (flat, BNL join)
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	5	
SELECT v1.c1, v1.c2, t2.c1, t2.c2 FROM v1, t2 WHERE v1.c1=t2.c1;
c1	c2	c1	c2
c	3	c	3
c	3	c	3
set @save_join_cache_level= @@join_cache_level;
set @@join_cache_level=4;
explain SELECT v1.c1, v1.c2, t2.c1, t2.c2 FROM v1, t2 WHERE v1.c1=t2.c1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t2	ALL	NULL	NULL	NULL	NULL	2	Using where
1	PRIMARY	<derived2>	hash_ALL	NULL	#hash#$hj	3	test.t2.c1	5	Using where; Using join buffer (flat, BNLH join)
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	5	
SELECT v1.c1, v1.c2, t2.c1, t2.c2 FROM v1, t2 WHERE v1.c1=t2.c1;
c1	c2	c1	c2
c	3	c	3
c	3	c	3
drop table t1,t2;
drop view v1;
set @@join_cache_level= @save_join_cache_level;
# end of 5.5
#
# Start of 10.1 tests
#
#
# MDEV-8747 Wrong result for SELECT..WHERE derived_table_column='a' AND derived_table_column<>_latin1'A' COLLATE latin1_bin
#
CREATE TABLE t1 (a VARCHAR(10));
INSERT INTO t1 VALUES ('a'),('A');
SELECT * FROM t1 WHERE a='a' AND a <> _latin1'A' COLLATE latin1_bin;
a
a
SELECT * FROM (SELECT * FROM t1) AS table1 WHERE a='a' AND a <> _latin1'A' COLLATE latin1_bin;
a
a
DROP TABLE t1;
CREATE TABLE t1 (a ENUM('5','6'));
INSERT INTO t1 VALUES ('5'),('6');
SELECT * FROM (SELECT * FROM t1) AS table1 WHERE a='5';
a
5
SELECT * FROM (SELECT * FROM t1) AS table1 WHERE a=1;
a
5
SELECT * FROM (SELECT * FROM t1) AS table1 WHERE a='5' AND a=1;
a
5
DROP TABLE t1;
#
# MDEV-8749 Wrong result for SELECT..WHERE derived_table_enum_column='number' AND derived_table_enum_column OP number2
#
CREATE TABLE t1 (a ENUM('5','6'));
INSERT INTO t1 VALUES ('5'),('6');
SELECT * FROM (SELECT * FROM t1) AS table1 WHERE a='5';
a
5
SELECT * FROM (SELECT * FROM t1) AS table1 WHERE a=1;
a
5
SELECT * FROM (SELECT * FROM t1) AS table1 WHERE a='5' AND a=1;
a
5
DROP TABLE t1;
#
# End of 10.1 tests
#
#
# MDEV-10554: Assertion `!derived->first_select()->
# exclude_from_table_unique_test || derived->outer_select()->
# exclude_from_table_unique_test'
# failed in TABLE_LIST::set_check_merged()
#
CREATE TABLE t1 (f INT);
CREATE ALGORITHM = TEMPTABLE VIEW v1 AS SELECT * FROM ( SELECT * FROM t1 ) AS sq;
PREPARE stmt FROM 'SELECT * FROM v1';
EXECUTE stmt;
f
EXECUTE stmt;
f
drop view v1;
drop table t1;
#
# MDEV-11363: Assertion `!derived->first_sel ect()->first_inner_unit() ||
# derived->first_select()->first_inner_unit()->first_select()->
# exclude_from_table_unique_test' failed in
# TABLE_LIST::set_check_materialized()
#
CREATE TABLE t1 (f1 INT);
CREATE TABLE t2 (f2 INT);
CREATE TABLE t3 (f3 INT);
CREATE VIEW v1 AS ( SELECT f1 AS f FROM t1 ) UNION ( SELECT f2 AS f FROM t2 );
CREATE VIEW v2 AS SELECT f3 AS f FROM t3;
CREATE VIEW v3 AS SELECT f FROM ( SELECT f3 AS f FROM v1, t3 ) AS sq;
CREATE VIEW v4 AS SELECT COUNT(*) as f FROM v3;
REPLACE INTO v2 ( SELECT * FROM v4 ) UNION ( SELECT f FROM v2 );
drop view v1,v2,v3,v4;
drop table t1,t2,t3;
#
# MDEV-20325: Assertion `outer_context || !*from_field || *from_field == not_found_field' failed in Item_field::fix_outer_field | `!derived->is_excluded()' failed in TABLE_LIST::set_check_materialized | SIGEGV in st_select_lex::mark_as_dependent (optimized builds)
#
CREATE TABLE t1 (a INT);
# Check that re-execution of a stored routine containing
# a query with subquery in the FROM clause doesn't result in
# assert failure in case the 'derived_merge' optimizer option
# has been turned on/off
CREATE PROCEDURE sp() SELECT * FROM (SELECT a FROM t1) tb;
CALL sp();
a
SET optimizer_switch='derived_merge=off';
# Without the patch the following statement would result in assert
# failure
CALL sp();
a
# Check the same test case for Prepared Statement
SET optimizer_switch='derived_merge=on';
PREPARE stmt FROM "SELECT * FROM (SELECT a FROM t1) tb";
EXECUTE stmt;
a
SET optimizer_switch='derived_merge=off';
# Without the patch the following statement would result in assert
# failure
EXECUTE stmt;
a
DEALLOCATE PREPARE stmt;
# Here check the reverse test case - first turn off the 'derived_merge'
# optimizer option, run the stored routine containing a query with
# subquery in the FROM clause, then turn on the 'derived_merge'
# optimizer option and re-execute the same stored routine to check that
# the routine is finished successfully.
CREATE PROCEDURE sp1() SELECT * FROM (SELECT a FROM t1) tb;
SET optimizer_switch='derived_merge=off';
CALL sp1();
a
SET optimizer_switch='derived_merge=on';
CALL sp1();
a
# Check the same test case for Prepared Statement
SET optimizer_switch='derived_merge=off';
PREPARE stmt FROM "SELECT * FROM (SELECT a FROM t1) tb";
EXECUTE stmt;
a
SET optimizer_switch='derived_merge=on';
# Without the patch the following statement would result in assert
# failure
EXECUTE stmt;
a
DEALLOCATE PREPARE stmt;
DROP PROCEDURE sp;
DROP PROCEDURE sp1;
DROP TABLE t1;
#
# End of 10.2 tests
#
#
# MDEV-9959: A serious MariaDB server performance bug
#
create table t1(a int);
insert into t1 values (1),(2),(3),(4),(5),(6);
create table t2(a int, b int,c int);
insert into t2(a,b,c) values (1,1,2),(2,2,3),(3,1,4),(4,2,2),(5,1,1),(6,2,5);
create table t3(a int, b int);
insert into t3(a,b) values (1,1),(2,2),(2,1),(1,2),(5,1),(9,2);
table "<derived2>" should have type=ref and rows=1
one select in derived table
with distinct
analyze select * from t1 , ((select distinct t2.a from t2 order by c))q  where t1.a=q.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	r_rows	filtered	r_filtered	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	Using where
1	PRIMARY	<derived2>	ref	key0	key0	5	test.t1.a	1	1.00	100.00	100.00	
2	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	Using temporary; Using filesort
analyze select * from t1 , ((select distinct t2.a, t2.b from t2 order by c))q  where t1.a=q.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	r_rows	filtered	r_filtered	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	Using where
1	PRIMARY	<derived2>	ref	key0	key0	5	test.t1.a	1	1.00	100.00	100.00	
2	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	Using temporary; Using filesort
# multiple selects in derived table
# NO UNION ALL
analyze select * from t1 , ( (select t2.a from t2 order by c) union  (select t2.a from t2 order by c))q  where t1.a=q.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	r_rows	filtered	r_filtered	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	Using where
1	PRIMARY	<derived2>	eq_ref	distinct_key	distinct_key	5	test.t1.a	1	1.00	100.00	100.00	
2	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
3	UNION	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
NULL	UNION RESULT	<union2,3>	ALL	NULL	NULL	NULL	NULL	NULL	6.00	NULL	NULL	
select * from t1 , ( (select t2.a from t2 order by c) union  (select t2.a from t2 order by c))q  where t1.a=q.a;
a	a
1	1
2	2
3	3
4	4
5	5
6	6
# UNION ALL and EXCEPT
analyze select * from t1 , ( (select t2.a from t2 order by c) union all (select  t2.a from t2 order by c) except(select t3.a from t3 order by b))q  where t1.a=q.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	r_rows	filtered	r_filtered	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	Using where
1	PRIMARY	<derived2>	eq_ref	distinct_key	distinct_key	5	test.t1.a	1	0.50	100.00	100.00	
2	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
3	UNION	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
4	EXCEPT	t3	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
NULL	UNIT RESULT	<unit2,3,4>	ALL	NULL	NULL	NULL	NULL	NULL	3.00	NULL	NULL	
select * from t1 , ( (select t2.a from t2 order by c) union all (select  t2.a from t2 order by c) except(select t3.a from t3 order by b))q  where t1.a=q.a;
a	a
3	3
4	4
6	6
analyze select * from t1 , ( (select t2.a from t2 order by c) union all (select  t2.a from t2 order by c) except ALL (select t3.a from t3 order by b))q  where t1.a=q.a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	r_rows	filtered	r_filtered	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	Using where
1	PRIMARY	<derived2>	ref	key0	key0	5	test.t1.a	1	1.17	100.00	100.00	
2	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
3	UNION	t2	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
4	EXCEPT	t3	ALL	NULL	NULL	NULL	NULL	6	6.00	100.00	100.00	
NULL	UNIT RESULT	<unit2,3,4>	ALL	NULL	NULL	NULL	NULL	NULL	7.00	NULL	NULL	
select * from t1 , ( (select t2.a from t2 order by c) union all (select  t2.a from t2 order by c) except ALL (select t3.a from t3 order by b))q  where t1.a=q.a;
a	a
3	3
3	3
4	4
4	4
5	5
6	6
6	6
drop table t1,t2,t3;
#
# MDEV-16549: Server crashes in Item_field::fix_fields on query with
# view and subquery, Assertion `context' failed, Assertion `field' failed
#
CREATE TABLE t1 (a DECIMAL, b INT);
INSERT INTO t1 VALUES (1,1),(2,2);
CREATE VIEW v1 AS SELECT * FROM ( SELECT * FROM t1 WHERE a <> RAND() ) sq;
SELECT * FROM v1 WHERE b > 0;
a	b
1	1
2	2
DROP VIEW v1;
DROP TABLE t1;
#
# MDEV-28616: derived table over union with order by clause that
#             contains subquery with unresolvable column reference
#
SELECT 1 FROM (
SELECT 1 UNION SELECT 2 ORDER BY  (SELECT 1 FROM DUAL WHERE xxx = 0)
) dt;
ERROR 42S22: Unknown column 'xxx' in 'WHERE'
create table t1 (a int, b int);
insert into t1 values (3,8), (7,2), (1,4), (5,9);
create table t2 (a int, b int);
insert into t2 values (9,1), (7,3), (2,6);
create table t3 (c int, d int);
insert into t3 values (7,8), (1,2), (3,8);
select * from
(
select a,b from t1 where t1.a > 3
union
select a,b from t2 where t2.b < 6
order by (a - b / (select a + max(c) from t3  where d = x))
) dt;
ERROR 42S22: Unknown column 'x' in 'WHERE'
drop table t1,t2,t3;
#
# End of 10.3 tests
#
#
# MDEV-24588: Fix crash with unnamed column in derived table.
# Assertion `item->name.str && item->name.str[0]` in
# `TABLE_LIST::create_field_translation` fails when a SELECT
# query includes a derived table containing unnamed column
# (eg: `SELECT '' from t`).
#
# Tests from the bug report
CREATE TABLE t (pk INT PRIMARY KEY);
INSERT INTO t VALUES (1), (2), (3);
SELECT SHA(pk) IN (SELECT * FROM (SELECT '' FROM t) AS a) FROM t;
SHA(pk) IN (SELECT * FROM (SELECT '' FROM t) AS a)
0
0
0
SET sql_mode='';
PREPARE p FROM 'SELECT SHA(pk) IN (SELECT * FROM (SELECT \'\' FROM t) AS a) FROM t;';
EXECUTE p;
SHA(pk) IN (SELECT * FROM (SELECT '' FROM t) AS a)
0
0
0
EXECUTE p;
SHA(pk) IN (SELECT * FROM (SELECT '' FROM t) AS a)
0
0
0
DEALLOCATE PREPARE p;
# Tests on derived tables
SELECT * FROM (SELECT 1, '' FROM t) AS a;
1	
1	
1	
1	
SELECT * FROM (SELECT '', 1 FROM t) AS a;
	1
	1
	1
	1
SELECT * FROM (SELECT 1, 2, '' FROM t) AS a;
1	2	
1	2	
1	2	
1	2	
SELECT * FROM (SELECT pk, '' FROM t) AS a;
pk	
1	
2	
3	
SELECT '/', '/';
/	/
/	/
SELECT * FROM (SELECT pk, '', '' as c1 FROM t) AS a;
pk		c1
1		
2		
3		
SELECT * FROM (SELECT '', '' from t) AS a;
ERROR 42S21: Duplicate column name ''
SELECT * FROM (SELECT '/', '/' FROM t) AS a;
ERROR 42S21: Duplicate column name '/'
SELECT * FROM (SELECT '/', '/') AS a;
ERROR 42S21: Duplicate column name '/'
DROP TABLE t;
# Tests on views
CREATE TABLE t (pk INT PRIMARY KEY);
INSERT INTO t VALUES (1), (2), (3);
CREATE VIEW v_t AS SELECT * FROM t;
SHOW CREATE VIEW v_t;
View	Create View	character_set_client	collation_connection
v_t	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v_t` AS select `t`.`pk` AS `pk` from `t`	latin1	latin1_swedish_ci
SELECT SHA(pk) IN (SELECT * FROM (SELECT '' FROM v_t) AS a) FROM v_t;
SHA(pk) IN (SELECT * FROM (SELECT '' FROM v_t) AS a)
0
0
0
SELECT * FROM (SELECT pk, '', '' as c1 FROM v_t) AS a;
pk		c1
1		
2		
3		
SELECT * FROM (SELECT '', '' from v_t) AS a;
ERROR 42S21: Duplicate column name ''
SELECT * FROM (SELECT '/', '/' from v_t) AS a;
ERROR 42S21: Duplicate column name '/'
CREATE VIEW v1 AS SELECT '/', '/';
SHOW CREATE VIEW v1;
View	Create View	character_set_client	collation_connection
v1	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1` AS select '/' AS `/`,'/' AS `My_exp_/`	latin1	latin1_swedish_ci
DROP VIEW v_t, v1;
DROP TABLE t;
# Tests on views created using SELECT statements that contain derived columns
CREATE TABLE t (pk INT PRIMARY KEY);
INSERT INTO t VALUES (1), (2), (3);
CREATE VIEW v1_t AS SELECT '' FROM t;
SHOW CREATE VIEW v1_t;
View	Create View	character_set_client	collation_connection
v1_t	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v1_t` AS select '' AS `Name_exp_1` from `t`	latin1	latin1_swedish_ci
SELECT * FROM v1_t;
Name_exp_1



CREATE VIEW v2_t AS SELECT * FROM (SELECT '' FROM t) AS a;
SHOW CREATE VIEW v2_t;
View	Create View	character_set_client	collation_connection
v2_t	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v2_t` AS select `tmp_field` AS `Name_exp_1` from (select '' from `t`) `a`	latin1	latin1_swedish_ci
Warnings:
Warning	1356	View 'test.v2_t' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
SELECT * FROM v2_t;
ERROR HY000: View 'test.v2_t' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
CREATE VIEW v3_t AS SELECT * FROM (SELECT '' as c1 FROM t) AS a;
SHOW CREATE VIEW v3_t;
View	Create View	character_set_client	collation_connection
v3_t	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v3_t` AS select `a`.`c1` AS `c1` from (select '' AS `c1` from `t`) `a`	latin1	latin1_swedish_ci
SELECT * FROM v3_t;
c1



CREATE VIEW v4_t AS SELECT * FROM (SELECT 1, '' FROM t) AS a;
SHOW CREATE VIEW v4_t;
View	Create View	character_set_client	collation_connection
v4_t	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v4_t` AS select `a`.`1` AS `1`,`tmp_field` AS `Name_exp_2` from (select 1 AS `1`,'' from `t`) `a`	latin1	latin1_swedish_ci
Warnings:
Warning	1356	View 'test.v4_t' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
SELECT * from v4_t;
ERROR HY000: View 'test.v4_t' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
CREATE VIEW v5_t AS SELECT '';
SHOW CREATE VIEW v5_t;
View	Create View	character_set_client	collation_connection
v5_t	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v5_t` AS select '' AS `Name_exp_1`	latin1	latin1_swedish_ci
SELECT * FROM v5_t;
Name_exp_1

CREATE VIEW v6_t AS SELECT * FROM (SELECT '') AS a;
SHOW CREATE VIEW v6_t;
View	Create View	character_set_client	collation_connection
v6_t	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v6_t` AS select `tmp_field` AS `Name_exp_1` from (select '') `a`	latin1	latin1_swedish_ci
Warnings:
Warning	1356	View 'test.v6_t' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
SELECT * FROM v6_t;
ERROR HY000: View 'test.v6_t' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
DROP VIEW v1_t, v2_t, v3_t, v4_t, v5_t, v6_t;
DROP TABLE t;
# End of 10.11 tests
#
# Test of "Derived tables and union can now create distinct keys"
#
create table t1 (a int);
insert into t1 values (100),(100),(100),(100),(100),(100),(100),(100),(100),(100);
create table duplicates_tbl (a int);
insert into duplicates_tbl select seq/100 from seq_1_to_10000;
explain
select
t1.a IN ( SELECT COUNT(*)
from (select a
from duplicates_tbl
limit 10000
) T
where T.a=5
) as 'A'
from t1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
2	MATERIALIZED	<derived3>	ALL	NULL	NULL	NULL	NULL	10000	Using where
3	DERIVED	duplicates_tbl	ALL	NULL	NULL	NULL	NULL	10000	
select
t1.a IN ( SELECT COUNT(*)
from (select a
from duplicates_tbl
limit 10000
) T
where T.a=5
) as 'A'
from t1;
A
1
1
1
1
1
1
1
1
1
1
explain
select
t1.a = all ( SELECT COUNT(*)
from (select a
from duplicates_tbl
limit 10000
) T
where T.a=5
) as 'A'
from t1;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	10	
2	DEPENDENT SUBQUERY	<derived3>	ALL	NULL	NULL	NULL	NULL	10000	Using where
3	DERIVED	duplicates_tbl	ALL	NULL	NULL	NULL	NULL	10000	
select
t1.a = all ( SELECT COUNT(*)
from (select a
from duplicates_tbl
limit 10000
) T
where T.a=5
) as 'A'
from t1;
A
1
1
1
1
1
1
1
1
1
1
drop table t1, duplicates_tbl;
#
# MDEV-30310
# Assertion failure in best_access_path upon IN exceeding
# IN_PREDICATE_CONVERSION_THRESHOLD, derived_with_keys=off
#
CREATE TABLE t1 (l_orderkey int);
INSERT INTO t1 VALUES (1),(2);
CREATE TABLE t2 (o_orderkey int);
INSERT INTO t2 VALUES (3),(4);
SET IN_PREDICATE_CONVERSION_THRESHOLD= 2;
SET OPTIMIZER_SWITCH='derived_with_keys=on';
SELECT * FROM t1 JOIN t2 ON (l_orderkey = o_orderkey) WHERE l_orderkey IN (1, 2, 3);
l_orderkey	o_orderkey
SET OPTIMIZER_SWITCH='derived_with_keys=off';
SELECT * FROM t1 JOIN t2 ON (l_orderkey = o_orderkey) WHERE l_orderkey IN (1, 2, 3);
l_orderkey	o_orderkey
SET @@IN_PREDICATE_CONVERSION_THRESHOLD=@@global.IN_PREDICATE_CONVERSION_THRESHOLD;
SET @@OPTIMIZER_SWITCH=@@global.OPTIMIZER_SWITCH;
DROP TABLE t1, t2;
#
# MDEV-30540 Wrong result with IN list length reaching
# IN_PREDICATE_CONVERSION_THRESHOLD
#
CREATE TABLE t1 (a INT PRIMARY KEY);
INSERT INTO t1 SELECT seq FROM seq_1_to_30;
ANALYZE TABLE t1 PERSISTENT FOR ALL;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Engine-independent statistics collected
test.t1	analyze	status	OK
SET IN_PREDICATE_CONVERSION_THRESHOLD=4;
SELECT a FROM t1 WHERE a IN ( 1, 1, 2, 194 );
a
1
2
SET IN_PREDICATE_CONVERSION_THRESHOLD=100;
SELECT a FROM t1 WHERE a IN ( 1, 1, 2, 194 );
a
1
2
drop table t1;
#
# MDEV-31022: SIGSEGV in maria_create from create_internal_tmp_table
# keydef incorrectly allocated on the stack in create_internal_tmp_table()
#
CREATE TABLE t1 (c CHAR(1) NULL) ENGINE=MyISAM;
INSERT INTO t1 (c) VALUES (1);
SET statement
optimizer_where_cost=1,
tmp_memory_table_size=0,
in_predicate_conversion_threshold=2
FOR
SELECT * FROM t1 WHERE c IN ('','');
c
SET statement
optimizer_where_cost=1,
tmp_memory_table_size=0,
in_predicate_conversion_threshold=2,
sql_mode=''
FOR
SELECT * FROM t1 WHERE c IN ('','');
c
DROP TABLE t1;
#
# End of 11.0 tests
#
#
# MDEV-28883: single/multi-table UPDATE/DELETE whose WHERE condition
#             contains subquery from mergeable derived table
#             that uses the updated/deleted table
#
create table t1 (pk int, a int);
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
explain update t1 set a = 10
where a = ( select * from (select a from t1) dt where dt.a > 7);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
2	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
update t1 set a = 10
where a = ( select * from (select a from t1) dt where dt.a > 7);
select * from t1;
pk	a
1	3
2	7
3	1
4	10
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
prepare stmt from "update t1 set a = 10
where a = ( select * from (select a from t1) dt where dt.a > 7)";
execute stmt;
select * from t1;
pk	a
1	3
2	7
3	1
4	10
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
select * from t1;
pk	a
4	10
3	1
1	3
deallocate prepare stmt;
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
explain update t1 set a = 10
where a <> ( select * from (select a from t1) dt where dt.a > 7)
order by a limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where; Using filesort
2	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
update t1 set a = 10
where a <> ( select * from (select a from t1) dt where dt.a > 7)
order by a limit 2;
select * from t1;
pk	a
4	9
3	10
1	10
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
prepare stmt from "update t1 set a = 10
where a <> ( select * from (select a from t1) dt where dt.a > 7)
order by a limit 2";
execute stmt;
select * from t1;
pk	a
4	9
3	10
1	10
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
select * from t1;
pk	a
4	9
3	10
1	10
deallocate prepare stmt;
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
explain delete from t1
where a = ( select * from (select a from t1) dt where dt.a > 7);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
2	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
delete from t1
where a = ( select * from (select a from t1) dt where dt.a > 7);
select * from t1;
pk	a
1	3
2	7
3	1
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
prepare stmt from "delete from t1
where a = ( select * from (select a from t1) dt where dt.a > 7)";
execute stmt;
select * from t1;
pk	a
1	3
2	7
3	1
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
select * from t1;
pk	a
3	1
1	3
deallocate prepare stmt;
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
explain delete from t1
where a = ( select * from (select a from t1) dt where dt.a > 5)
returning pk, a;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
2	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	3	Using where
delete from t1
where a = ( select * from (select a from t1) dt where dt.a > 5)
returning pk, a;
pk	a
4	9
select * from t1;
pk	a
3	1
1	3
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
prepare stmt from "delete from t1
where a = ( select * from (select a from t1) dt where dt.a > 5)
returning pk, a";
execute stmt;
pk	a
4	9
select * from t1;
pk	a
3	1
1	3
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
pk	a
4	9
select * from t1;
pk	a
3	1
1	3
deallocate prepare stmt;
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
explain delete from t1
where a <> ( select * from (select a from t1) dt where dt.a > 7)
order by a limit 2;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where; Using filesort
2	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
delete from t1
where a <> ( select * from (select a from t1) dt where dt.a > 7)
order by a limit 2;
select * from t1;
pk	a
2	7
4	9
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
prepare stmt from "delete from t1
where a <> ( select * from (select a from t1) dt where dt.a > 7)
order by a limit 2";
execute stmt;
select * from t1;
pk	a
2	7
4	9
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
execute stmt;
select * from t1;
pk	a
2	7
4	9
deallocate prepare stmt;
create table t2 (pk int, a int);
insert into t2 values (1,3), (2, 7), (3,1), (4,9);
create table t3 (a int);
insert into t3 VALUES (0),(1);
explain update t1,t3 set t1.a = 1
where t1.a=t3.a and
t1.a = ( select * from (select a from t1) dt where dt.a > 7);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	2	Using where
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	2	Using where
2	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	2	Using where
update t1,t3 set t1.a = 1
where t1.a=t3.a and
t1.a = ( select * from (select a from t1) dt where dt.a > 7);
select * from t1;
pk	a
2	7
4	9
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
prepare stmt from "update t1,t3 set t1.a = 1
where t1.a=t3.a and
t1.a = ( select * from (select a from t1) dt where dt.a > 7)";
execute stmt;
select * from t1;
pk	a
1	3
2	7
3	1
4	9
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
select * from t1;
pk	a
4	9
3	1
1	3
deallocate prepare stmt;
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
explain update t1,t3 set t1.a = 1
where t1.a=t3.a and
t1.a = ( select * from (select a from t2) dt where dt.a > 7);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	2	Using where
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
2	SUBQUERY	t2	ALL	NULL	NULL	NULL	NULL	4	Using where
update t1,t3 set t1.a = 1
where t1.a=t3.a and
t1.a = ( select * from (select a from t2) dt where dt.a > 7);
select * from t1;
pk	a
1	3
2	7
3	1
4	9
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
prepare stmt from "update t1,t3 set t1.a = 1
where t1.a=t3.a and
t1.a = ( select * from (select a from t2) dt where dt.a > 7)";
execute stmt;
select * from t1;
pk	a
1	3
2	7
3	1
4	9
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
select * from t1;
pk	a
4	9
3	1
1	3
deallocate prepare stmt;
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
insert into t3 values (9), (10), (7);
explain delete from t1 using t1,t3
where t1.a=t3.a and
t1.a = ( select * from (select a from t1) dt where dt.a > 7);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	5	Using where
2	SUBQUERY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
delete from t1 using t1,t3
where t1.a=t3.a and
t1.a = ( select * from (select a from t1) dt where dt.a > 7);
select * from t1;
pk	a
1	3
2	7
3	1
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
prepare stmt from "delete from t1 using t1,t3
where t1.a=t3.a and
t1.a = ( select * from (select a from t1) dt where dt.a > 7)";
execute stmt;
select * from t1;
pk	a
1	3
2	7
3	1
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
select * from t1;
pk	a
3	1
1	3
deallocate prepare stmt;
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
explain delete from t1 using t1,t3
where t1.a=t3.a and
t1.a = ( select * from (select a from t2) dt where dt.a > 7);
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	t1	ALL	NULL	NULL	NULL	NULL	4	Using where
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	5	Using where
2	SUBQUERY	t2	ALL	NULL	NULL	NULL	NULL	4	Using where
delete from t1 using t1,t3
where t1.a=t3.a and
t1.a = ( select * from (select a from t2) dt where dt.a > 7);
select * from t1;
pk	a
1	3
2	7
3	1
delete from t1;
insert into t1 values (1,3), (2, 7), (3,1), (4,9);
prepare stmt from "delete from t1 using t1,t3
where t1.a=t3.a and
t1.a = ( select * from (select a from t2) dt where dt.a > 7)";
execute stmt;
select * from t1;
pk	a
1	3
2	7
3	1
delete from t1;
insert into t1 value (4,9), (3,1), (1,3);
execute stmt;
select * from t1;
pk	a
3	1
1	3
deallocate prepare stmt;
drop table t1,t2,t3;
# End of MariaDB 11.1 tests
#
# MDEV-34880: Incorrect result for query with derived table having TEXT field
#
CREATE TABLE t1 (id int NOT NULL  PRIMARY KEY, notes TEXT NOT NULL);
INSERT INTO t1 VALUES (1, 'test1'), (2, 'test2');
SELECT dt.* FROM (SELECT * FROM t1 UNION SELECT * FROM t1) dt WHERE id = 1;
id	notes
1	test1
SELECT dt.* FROM (SELECT * FROM t1 UNION SELECT * FROM t1) dt WHERE id = 1 AND
notes = 'test1';
id	notes
1	test1
DROP TABLE t1;
#
# End of 11.2 tests
#
#
# MDEV-31466 Add optional correlation column list for derived tables
#
# simple examples of renaming a TVC
select *, c1 from (values (3,4),(5,6)) as tvc(c1, c2);
c1	c2	c1
3	4	3
5	6	5
# multibyte chars as names
select * from (values (3,4),(5,6)) as tvc(c1, ``);
c1	
3	4
5	6
# illustrate column name at each level
select outmost from
(
select outercol1, outercol2 from
(
select concat(innercol1, innercol2), 1 from
(
values (3,4),(5,6),(7,8)
)
as tvc(innercol1, innercol2)
)
as derived (outercol1, outercol2)
)
derived2 (outmost, outmost1);
outmost
34
56
78
create table t1 (c1 int, c2 int, c3 int);
insert into t1 values (1,2,3),(4,5,6);
create table t2 like t1;
insert into t2 values (7,8,9),(10,11,12);
create table t3 like t1;
insert into t3 values (10,11,12),(13,14,15);
# nested mergeable derived tables
select * from
(
select ic1, ic2, ic3 from
(
select c1, c2, c3 from t1
) dt2 (ic1, ic2, ic3)
) dt1 (oc1, oc2, oc3)
join t2 on t2.c1 = dt1.oc1+6;
oc1	oc2	oc3	c1	c2	c3
1	2	3	7	8	9
4	5	6	10	11	12
select * from
(
select ic1, ic2, ic3 from
(
select c1, c2, c3 from t1
) dt2 (ic1, ic2, ic3)
join t2 on t2.c1 = dt2.ic1+6
) dt1 (oc1, oc2, oc3);
oc1	oc2	oc3
1	2	3
4	5	6
select * from
(
select ic1, ic2, ic3 from
(
select t1.c1, t1.c2, t1.c3 from t1
join t2 on t2.c1 = t1.c1+6
) dt2 (ic1, ic2, ic3)
) dt1 (oc1, oc2, oc3);
oc1	oc2	oc3
1	2	3
4	5	6
select * from
(
select ic1, ic2, ic3 from
(
select c1, c2, c3 from t1
) dt2 (ic1, ic2, ic3)
join t2 on t2.c1 = dt2.ic1+6
) dt1 (oc1, oc2, oc3)
join t3 on t3.c1 = dt1.oc1+9;
oc1	oc2	oc3	c1	c2	c3
1	2	3	10	11	12
4	5	6	13	14	15
explain select * from
(
select ic1, ic2, ic3 from
(
select c1, c2, c3 from t1
) dt2 (ic1, ic2, ic3)
join t2 on t2.c1 = dt2.ic1+6
) dt1 (oc1, oc2, oc3)
join t3 on t3.c1 = dt1.oc1+9;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	ALL	NULL	NULL	NULL	NULL	2	
1	SIMPLE	t2	ALL	NULL	NULL	NULL	NULL	2	Using where; Using join buffer (flat, BNL join)
1	SIMPLE	t3	ALL	NULL	NULL	NULL	NULL	2	Using where; Using join buffer (incremental, BNL join)
select * from
(
select ic1, ic2, ic3 from
(
select c1, c2, c3 from t1 group by c1
) dt2 (ic1, ic2, ic3)
join t2 on t2.c1 = dt2.ic1+6
group by ic1
) dt1 (oc1, oc2, oc3)
join t3 on t3.c1 = dt1.oc1+9;
oc1	oc2	oc3	c1	c2	c3
1	2	3	10	11	12
4	5	6	13	14	15
explain select * from
(
select ic1, ic2, ic3 from
(
select c1, c2, c3 from t1 group by c1
) dt2 (ic1, ic2, ic3)
join t2 on t2.c1 = dt2.ic1+6
group by ic1
) dt1 (oc1, oc2, oc3)
join t3 on t3.c1 = dt1.oc1+9;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	2	
1	PRIMARY	t3	ALL	NULL	NULL	NULL	NULL	2	Using where; Using join buffer (flat, BNL join)
2	DERIVED	<derived3>	ALL	NULL	NULL	NULL	NULL	2	Using temporary; Using filesort
2	DERIVED	t2	ALL	NULL	NULL	NULL	NULL	2	Using where; Using join buffer (flat, BNL join)
3	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	2	Using temporary; Using filesort
# test natural join on renamed columns
select * from
(
select join_col, ic2, ic3, jc2, jc3 from
(
select c1+7, c2+1, c3+1 from t1
) dt2 (join_col, ic2, ic3)
natural join
(
select c1+1, c2+1, c3+1 from t2
) dt3 (join_col, jc2, jc3)
) dt1 (oc1, oc2, oc3, c3, oc5)
natural join t3;
c3	oc1	oc2	oc3	oc5	c1	c2
12	11	6	7	13	10	11
explain format=json select * from
(
select join_col, ic2, ic3, jc2, jc3 from
(
select c1+7, c2+1, c3+1 from t1
) dt2 (join_col, ic2, ic3)
natural join
(
select c1+1, c2+1, c3+1 from t2
) dt3 (join_col, jc2, jc3)
) dt1 (oc1, oc2, oc3, c3, oc5)
natural join t3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "loops": 2,
            "rows": 2,
            "cost": "COST_REPLACED",
            "filtered": 100
          },
          "buffer_type": "flat",
          "buffer_size": "173",
          "join_type": "BNL",
          "attached_condition": "t1.c1 + 7 = t2.c1 + 1"
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "t3",
            "access_type": "ALL",
            "loops": 4,
            "rows": 2,
            "cost": "COST_REPLACED",
            "filtered": 100
          },
          "buffer_type": "incremental",
          "buffer_size": "217",
          "join_type": "BNL",
          "attached_condition": "t2.c2 + 1 = t3.c3"
        }
      }
    ]
  }
}
# create views with alternate syntax
create view v1 as select * from
(select * from t1) as d1 (a1, a2, a3);
create view v2 as select * from
(select c1, c2, sum(c3) from t2 group by c1, c2)
as d2 (b1, b2, b3);
create view v3 as select * from (select * from t3 where c1=10)
as d3 (d1, d2, d3);
create view v4 as select * from
(select c1, c2, sum(c3) as s from t1 group by c1, c2 having s > 2)
as d2 (e1, e2, e3);
create view v5 as select * from
(
select c1, c2, sum(c3) as s from t1 group by c1, c2 having s > 2
union
select c1, c2, sum(c3) as s from t2 group by c1, c2 having s > 3
)
as d2 (f1, f2, f3);
create view v6 as select a1 from
(
select * from t1 union select * from t2 order by c1
) as d3 (a1, a2, a3);
create view v7 (b1) as select a1 from (select c1 from t1) dt (a1);
create view v8 (b1, b2, b3) as select a1, a2, a3 from
(
select * from t1 union select * from t2 order by c1
) as d3 (a1, a2, a3);
# test parent query mergability
explain format=json select a1 from v1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100
        }
      }
    ]
  }
}
select a1 from v1;
a1
1
4
select a1, a2 from v1;
a1	a2
1	2
4	5
select * from v1;
a1	a2	a3
1	2	3
4	5	6
select b1 from v2;
b1
7
10
select b1, b2 from v2;
b1	b2
7	8
10	11
select * from v2;
b1	b2	b3
7	8	9
10	11	12
select a1 from v1 union select b1 from v2;
a1
1
4
7
10
select a1, a2 from v1 union select b1, b2 from v2;
a1	a2
1	2
4	5
7	8
10	11
select * from v1 union select * from v2;
a1	a2	a3
1	2	3
4	5	6
7	8	9
10	11	12
select * from v3 intersect select * from v2 union select * from v1;
d1	d2	d3
10	11	12
1	2	3
4	5	6
select * from v4 where e3 < 10;
e1	e2	e3
1	2	3
4	5	6
select * from v6;
a1
1
4
7
10
show create view v6;
View	Create View	character_set_client	collation_connection
v6	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v6` AS select `d3`.`a1` AS `a1` from (select `t1`.`c1` AS `a1`,`t1`.`c2` AS `a2`,`t1`.`c3` AS `a3` from `t1` union select `t2`.`c1` AS `c1`,`t2`.`c2` AS `c2`,`t2`.`c3` AS `c3` from `t2` order by `c1`) `d3`(`a1`,`a2`,`a3`)	latin1	latin1_swedish_ci
select * from v7;
b1
1
4
show create view v7;
View	Create View	character_set_client	collation_connection
v7	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v7` AS select `dt`.`a1` AS `b1` from (select `t1`.`c1` AS `a1` from `t1`) `dt`(`a1`)	latin1	latin1_swedish_ci
select * from v8;
b1	b2	b3
1	2	3
4	5	6
7	8	9
10	11	12
show create view v8;
View	Create View	character_set_client	collation_connection
v8	CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v8` AS select `d3`.`a1` AS `b1`,`d3`.`a2` AS `b2`,`d3`.`a3` AS `b3` from (select `t1`.`c1` AS `a1`,`t1`.`c2` AS `a2`,`t1`.`c3` AS `a3` from `t1` union select `t2`.`c1` AS `c1`,`t2`.`c2` AS `c2`,`t2`.`c3` AS `c3` from `t2` order by `c1`) `d3`(`a1`,`a2`,`a3`)	latin1	latin1_swedish_ci
# show materialization and condition pushdown into having
explain format=json select * from v4 where e3 < 10;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived3>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.e3 < 10",
          "materialized": {
            "query_block": {
              "select_id": 3,
              "cost": "COST_REPLACED",
              "having_condition": "e3 > 2 and e3 < 10",
              "filesort": {
                "sort_key": "t1.c1, t1.c2",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    ]
  }
}
# these views embedded in a CTE
with cte (c1, c2, c3 )
as (select * from v3 intersect select * from v2 union select * from v1)
select * from cte where c1 = 1;
c1	c2	c3
1	2	3
# and executed as a prepared query
prepare stmt from "with cte (c1, c2, c3 )
as (select * from v3 intersect select * from v2 union select * from v1)
select * from cte where c1 = 1";
execute stmt;
c1	c2	c3
1	2	3
execute stmt;
c1	c2	c3
1	2	3
deallocate prepare stmt;
prepare stmt from
"select * from (select * from t1) as d1 (a1, a2, a3)";
execute stmt;
a1	a2	a3
1	2	3
4	5	6
execute stmt;
a1	a2	a3
1	2	3
4	5	6
deallocate prepare stmt;
prepare stmt from
"select * from (select * from t1) as d1 (a1, a2, a3) union select * from "
"(select * from t1) as d1 (na1, na2, na3)";
execute stmt;
a1	a2	a3
1	2	3
4	5	6
execute stmt;
a1	a2	a3
1	2	3
4	5	6
deallocate prepare stmt;
# as well as a stored procedure
create procedure p1(a int)
with cte (ct1)
as (select d1 from v3 intersect select b1 from v2 union select a1 from v1)
select ct1 from cte where ct1 = a;
call p1(1);
ct1
1
call p1(1);
ct1
1
call p1(4);
ct1
4
call p1(7);
ct1
drop procedure p1;
create procedure p1(a int)
with cte (ct1, ct2, ct3)
as (select * from v3 intersect select * from v2 union select * from v1)
select * from cte where ct1 = a;
call p1(1);
ct1	ct2	ct3
1	2	3
call p1(1);
ct1	ct2	ct3
1	2	3
call p1(4);
ct1	ct2	ct3
4	5	6
call p1(7);
ct1	ct2	ct3
drop procedure p1;
# name resolution in the select list and in the where condition
select *, a2 from
(select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
where a1 = 1;
a1	a2	a3	a2
1	2	3	2
# and elsewhere
select a1, sum(a3) from
(select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
where a2 = 1
group by a1
order by a1 desc;
a1	sum(a3)
# creation of a having condition in materialized subquery
select * from
(select c1, sum(c2), sum(c3) from t1 where c1 = 1
group by c1 order by c1 desc) as d1 (a1, a2, a3)
where a3=3;
a1	a2	a3
1	2	3
explain format=json select * from
(select c1, sum(c2), sum(c3) from t1 where c1 = 1
group by c1 order by c1 desc) as d1 (a1, a2, a3)
where a3=3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d1.a3 = 3",
          "materialized": {
            "query_block": {
              "select_id": 2,
              "cost": "COST_REPLACED",
              "having_condition": "a3 = 3",
              "nested_loop": [
                {
                  "table": {
                    "table_name": "t1",
                    "access_type": "ALL",
                    "loops": 1,
                    "rows": 2,
                    "cost": "COST_REPLACED",
                    "filtered": 100,
                    "attached_condition": "t1.c1 = 1"
                  }
                }
              ]
            }
          }
        }
      }
    ]
  }
}
# and augmentation
select * from
(select c1, c2, max(c3) as m, avg(c3) from t1
group by c1, c2 having m < 7) dt (d1, d2, d3, d4),
t2 where (dt.d1 = t2.c1) and (dt.d3 > 3);
d1	d2	d3	d4	c1	c2	c3
explain format=json select * from
(select c1, c2, max(c3) as m, avg(c3) from t1
group by c1, c2 having m < 7) dt (d1, d2, d3, d4),
t2 where (dt.d1 = t2.c1) and (dt.d3 > 3);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t2",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t2.c1 is not null"
        }
      },
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ref",
          "possible_keys": ["key0"],
          "key": "key0",
          "key_length": "5",
          "used_key_parts": ["d1"],
          "ref": ["test.t2.c1"],
          "loops": 2,
          "rows": 1,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "dt.d3 > 3",
          "materialized": {
            "query_block": {
              "select_id": 2,
              "cost": "COST_REPLACED",
              "having_condition": "d3 < 7 and d3 > 3",
              "filesort": {
                "sort_key": "t1.c1, t1.c2",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    ]
  }
}
# pushing subformula into where condition for join to t2 (t2.c1 = 7)
# and translating v4.e1=1 into condition t1.c1 = 1 for t1
select * from v4,t2 where (t2.c1=v4.e1+6) and (v4.e2+6=t2.c2) and (v4.e1=1);
e1	e2	e3	c1	c2	c3
1	2	3	7	8	9
explain format=json select * from v4,t2 where (t2.c1=v4.e1+6) and (v4.e2+6=t2.c2) and (v4.e1=1);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": 0.020930975,
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived3>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": 0.010089369,
          "filtered": 100,
          "attached_condition": "d2.e1 = 1",
          "materialized": {
            "query_block": {
              "select_id": 3,
              "cost": 0.011611947,
              "having_condition": "e3 > 2",
              "filesort": {
                "sort_key": "t1.c1, t1.c2",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": 0.01034841,
                        "filtered": 100,
                        "attached_condition": "t1.c1 = 1"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "loops": 2,
            "rows": 2,
            "cost": 0.010841606,
            "filtered": 100,
            "attached_condition": "t2.c1 = 7"
          },
          "buffer_type": "flat",
          "buffer_size": "294",
          "join_type": "BNL",
          "attached_condition": "d2.e2 + 6 = t2.c2"
        }
      }
    ]
  }
}
# calculated result pushed into condition for t1 (t1.c1 = 4)
select * from v4,t2 where (v4.e1=t2.c1-6) and (v4.e2+6=t2.c2) and (t2.c1=10);
e1	e2	e3	c1	c2	c3
4	5	6	10	11	12
explain format=json select * from v4,t2 where (v4.e1=t2.c1-6) and (v4.e2+6=t2.c2) and (t2.c1=10);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived3>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.e1 = 4",
          "materialized": {
            "query_block": {
              "select_id": 3,
              "cost": "COST_REPLACED",
              "having_condition": "e3 > 2",
              "filesort": {
                "sort_key": "t1.c1, t1.c2",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100,
                        "attached_condition": "t1.c1 = 4"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "loops": 2,
            "rows": 2,
            "cost": "COST_REPLACED",
            "filtered": 100,
            "attached_condition": "t2.c1 = 10"
          },
          "buffer_type": "flat",
          "buffer_size": "294",
          "join_type": "BNL",
          "attached_condition": "d2.e2 + 6 = t2.c2"
        }
      }
    ]
  }
}
# pushing into HAVING using equalities e3 > 2
select * from v4,t2
where ((t2.c1<4) and (v4.e1=t2.c1)) or ((t2.c3>10) and (v4.e3=t2.c3));
e1	e2	e3	c1	c2	c3
explain format=json select * from v4,t2
where ((t2.c1<4) and (v4.e1=t2.c1)) or ((t2.c3>10) and (v4.e3=t2.c3));
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived3>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "select_id": 3,
              "cost": "COST_REPLACED",
              "having_condition": "e3 > 2",
              "filesort": {
                "sort_key": "t1.c1, t1.c2",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "loops": 2,
            "rows": 2,
            "cost": "COST_REPLACED",
            "filtered": 100
          },
          "buffer_type": "flat",
          "buffer_size": "294",
          "join_type": "BNL",
          "attached_condition": "t2.c1 = d2.e1 and d2.e1 < 4 or t2.c3 > 10 and d2.e3 = t2.c3"
        }
      }
    ]
  }
}
# pushing into multiple places
select * from v1,v5,t2 where ((v1.a1=v5.f1) or (v1.a1=t2.c1)) and
((v5.f2<50) or (v5.f2=19)) and (v1.a3<300);
a1	a2	a3	f1	f2	f3	c1	c2	c3
1	2	3	1	2	3	7	8	9
1	2	3	1	2	3	10	11	12
4	5	6	4	5	6	7	8	9
4	5	6	4	5	6	10	11	12
explain format=json select * from v1,v5,t2 where ((v1.a1=v5.f1) or (v1.a1=t2.c1)) and
((v5.f2<50) or (v5.f2=19)) and (v1.a3<300);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t1.c3 < 300"
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "t2",
            "access_type": "ALL",
            "loops": 2,
            "rows": 2,
            "cost": "COST_REPLACED",
            "filtered": 100
          },
          "buffer_type": "flat",
          "buffer_size": "173",
          "join_type": "BNL"
        }
      },
      {
        "block-nl-join": {
          "table": {
            "table_name": "<derived5>",
            "access_type": "ALL",
            "loops": 4,
            "rows": 4,
            "cost": "COST_REPLACED",
            "filtered": 100,
            "attached_condition": "d2.f2 < 50 or d2.f2 = 19"
          },
          "buffer_type": "incremental",
          "buffer_size": "217",
          "join_type": "BNL",
          "attached_condition": "(d2.f1 = t1.c1 or t2.c1 = t1.c1) and (d2.f2 < 50 or d2.f2 = 19)",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union5,6>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 5,
                      "cost": "COST_REPLACED",
                      "having_condition": "f3 > 2",
                      "filesort": {
                        "sort_key": "t1.c1, t1.c2",
                        "temporary_table": {
                          "nested_loop": [
                            {
                              "table": {
                                "table_name": "t1",
                                "access_type": "ALL",
                                "loops": 1,
                                "rows": 2,
                                "cost": "COST_REPLACED",
                                "filtered": 100,
                                "attached_condition": "t1.c2 < 50 or t1.c2 = 19"
                              }
                            }
                          ]
                        }
                      }
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 6,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "having_condition": "f3 > 3",
                      "filesort": {
                        "sort_key": "t2.c1, t2.c2",
                        "temporary_table": {
                          "nested_loop": [
                            {
                              "table": {
                                "table_name": "t2",
                                "access_type": "ALL",
                                "loops": 1,
                                "rows": 2,
                                "cost": "COST_REPLACED",
                                "filtered": 100,
                                "attached_condition": "t2.c2 < 50 or t2.c2 = 19"
                              }
                            }
                          ]
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
# pushing into multiple places, inline subquery definition of forced
# materialization
SELECT * FROM
(
SELECT a1 FROM v1
WHERE 1 IN (0,v1.a1)
GROUP BY v1.a1
) AS dt1 (a)
JOIN
(
SELECT v5.f1 FROM v5
WHERE 1 IN (0,v5.f1)
) AS dt2 (b)
ON dt1.a = dt2.b;
a	b
1	1
explain format=json SELECT * FROM
(
SELECT a1 FROM v1
WHERE 1 IN (0,v1.a1)
GROUP BY v1.a1
) AS dt1 (a)
JOIN
(
SELECT v5.f1 FROM v5
WHERE 1 IN (0,v5.f1)
) AS dt2 (b)
ON dt1.a = dt2.b;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "1 in (0,dt1.a) and dt1.a is not null",
          "materialized": {
            "query_block": {
              "select_id": 2,
              "cost": "COST_REPLACED",
              "filesort": {
                "sort_key": "t1.c1",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100,
                        "attached_condition": "1 in (0,t1.c1) and 1 in (0,t1.c1)"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      },
      {
        "table": {
          "table_name": "<derived7>",
          "access_type": "ref",
          "possible_keys": ["key1", "distinct_key"],
          "key": "key1",
          "key_length": "5",
          "used_key_parts": ["f1"],
          "ref": ["dt1.a"],
          "loops": 2,
          "rows": 1,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union7,8>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 7,
                      "cost": "COST_REPLACED",
                      "having_condition": "f3 > 2",
                      "filesort": {
                        "sort_key": "t1.c1, t1.c2",
                        "temporary_table": {
                          "nested_loop": [
                            {
                              "table": {
                                "table_name": "t1",
                                "access_type": "ALL",
                                "loops": 1,
                                "rows": 2,
                                "cost": "COST_REPLACED",
                                "filtered": 100,
                                "attached_condition": "1 in (0,t1.c1)"
                              }
                            }
                          ]
                        }
                      }
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 8,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "having_condition": "f3 > 3",
                      "filesort": {
                        "sort_key": "t2.c1, t2.c2",
                        "temporary_table": {
                          "nested_loop": [
                            {
                              "table": {
                                "table_name": "t2",
                                "access_type": "ALL",
                                "loops": 1,
                                "rows": 2,
                                "cost": "COST_REPLACED",
                                "filtered": 100,
                                "attached_condition": "1 in (0,t2.c1)"
                              }
                            }
                          ]
                        }
                      }
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
# pushdown with update statement (t1.c1 >= 3)
explain format=json update t2,
(select c1, count(*) from t1 group by c1) t (a, c)
set t2.c1=t.c+10
where t2.c1 = t.c and t.a >= 3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t2",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t2.c1 is not null"
        }
      },
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ref",
          "possible_keys": ["key0"],
          "key": "key0",
          "key_length": "8",
          "used_key_parts": ["c"],
          "ref": ["test.t2.c1"],
          "loops": 2,
          "rows": 1,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t2.c1 = t.c and t.a >= 3",
          "materialized": {
            "query_block": {
              "select_id": 2,
              "cost": "COST_REPLACED",
              "filesort": {
                "sort_key": "t1.c1",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100,
                        "attached_condition": "t1.c1 >= 3"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    ]
  }
}
# pushdown with delete statement (t1.c1 >= 3)
explain format=json delete t2 from t2,
(select c1, count(*) from t1 group by c1) t (a, c)
where t2.c1 = t.c and t.a >= 3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t2",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t2.c1 is not null"
        }
      },
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ref",
          "possible_keys": ["key0"],
          "key": "key0",
          "key_length": "8",
          "used_key_parts": ["c"],
          "ref": ["test.t2.c1"],
          "loops": 2,
          "rows": 1,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t2.c1 = t.c and t.a >= 3",
          "materialized": {
            "query_block": {
              "select_id": 2,
              "cost": "COST_REPLACED",
              "filesort": {
                "sort_key": "t1.c1",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100,
                        "attached_condition": "t1.c1 >= 3"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    ]
  }
}
# pushdown with insert statement (t1.c1 >= 3)
explain format=json insert into t3  select t2.* from t2,
(select c1, count(*) from t1 group by c1) t (a, c)
where t2.c1 = t.c and t.a >= 3;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t2",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t2.c1 is not null"
        }
      },
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ref",
          "possible_keys": ["key0"],
          "key": "key0",
          "key_length": "8",
          "used_key_parts": ["c"],
          "ref": ["test.t2.c1"],
          "loops": 2,
          "rows": 1,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t2.c1 = t.c and t.a >= 3",
          "materialized": {
            "query_block": {
              "select_id": 2,
              "cost": "COST_REPLACED",
              "filesort": {
                "sort_key": "t1.c1",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": "COST_REPLACED",
                        "filtered": 100,
                        "attached_condition": "t1.c1 >= 3"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    ]
  }
}
# pushdown into union with different column names
explain format=json
select * from (select min(c1) from t1 union all select max(c1) from t1) t (x)
where x > 0;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "t.x > 0",
          "materialized": {
            "query_block": {
              "union_result": {
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "having_condition": "x > 0",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 3,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "having_condition": "x > 0",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
# complex conditions
explain format=json select * from v1 where if( a1 regexp 'def', 'foo', a2 )
in ('abc', a3);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "t1",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "if(t1.c1 regexp 'def','foo',t1.c2) in ('abc',t1.c3)"
        }
      }
    ]
  }
}
# pushdown through GROUP BY
create function f1(a int) returns int DETERMINISTIC return (a+1);
create view v9 as select * from
(select c1, f1(c2), sum(c3) from t1 group by c1, f1(c2)) as f (c1, c2, c3);
explain format=json select * from v9 where (c3+1) > 10 and c1 > 1 and c2 > 123;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": 0.010089369,
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived3>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": 0.010089369,
          "filtered": 100,
          "attached_condition": "f.c3 + 1 > 10 and f.c1 > 1 and f.c2 > 123",
          "materialized": {
            "query_block": {
              "select_id": 3,
              "cost": 0.011611947,
              "having_condition": "c3 + 1 > 10 and c2 > 123",
              "filesort": {
                "sort_key": "t1.c1, f1(t1.c2)",
                "temporary_table": {
                  "nested_loop": [
                    {
                      "table": {
                        "table_name": "t1",
                        "access_type": "ALL",
                        "loops": 1,
                        "rows": 2,
                        "cost": 0.01034841,
                        "filtered": 100,
                        "attached_condition": "t1.c1 > 1"
                      }
                    }
                  ]
                }
              }
            }
          }
        }
      }
    ]
  }
}
drop function f1;
# name resolution for multi select units
select a1 from
(select * from t1 union select * from t2 order by c1) as d3 (a1, a2, a3);
a1
1
4
7
10
select a1, a2 from
(select * from t1 union select * from t2 order by c1) as d3 (a1, a2, a3);
a1	a2
1	2
4	5
7	8
10	11
# wildcard expansion for multi select units
select * from
(select * from t1 union select * from t2 order by c1) as d3 (a1, a2, a3);
a1	a2	a3
1	2	3
4	5	6
7	8	9
10	11	12
# name resolution in where/group by etc
select a1, count(*) from
( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
group by a1 order by a1;
a1	count(*)
1	1
4	1
select a1, count(*) from
( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
where a1 in (select c1 from t2);
a1	count(*)
NULL	0
select a1, count(*) from
( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
where exists (select c1 from t2 where c1 = a1);
a1	count(*)
NULL	0
select *, a1 from
( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
join t2 on a1=c1;
a1	a2	a3	c1	c2	c3	a1
select *, a1 from
( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
join (values (1, 2, 3), (4, 5, 6)) as d2 (b1, b2, b3)
on a1=b1;
a1	a2	a3	b1	b2	b3	a1
1	2	3	1	2	3	1
4	5	6	4	5	6	4
# some error checking, more elsewhere
--error ER_NONUNIQ_TABLE
select * from
( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
join (values (1, 2, 3), (4, 5, 6)) as d1 (b1, b2, b3)
on a1=b1
select * from (values (3,4),(5,6)) as foo(Col1, Col1);
ERROR 42S21: Duplicate column name 'Col1'
select * from ( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3) where c1 = 1;
ERROR 42S22: Unknown column 'c1' in 'WHERE'
select * from ( select c1, c2, c3 from t1 ) as d1 (a1, a2) where c1 = 1;
ERROR HY000: Incorrect column name count for derived table
select * from ( select c1, c2 from t1 union select c1, c2 from t1) as d1 (a1);
ERROR HY000: Incorrect column name count for derived table
select * from ( select * from t1 union select * from t1) as d1 (a1, a2);
ERROR HY000: Incorrect column name count for derived table
select * from ( select c1, c2, c3 from t1 ) as d1 () where c1 = 1;
ERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ') where c1 = 1' at line 1
select * from ( select c1, c2, c3 from t1 ) as d1 (a1, a2, a3)
join ( select c1, c2, c3 from t1 ) as d2 (a1, a2, a3)
where d1.a1=a1;
ERROR 23000: Column 'a1' in WHERE is ambiguous
# We expect to see the results of the 1st select in the union as names
# check wildcard expansion and name resolution in the outer select list
select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2;
a1	a2	a3	a1
4	5	6	4
7	8	9	1
10	11	12	1
select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2 order by a2;
a1	a2	a3	a1
4	5	6	4
7	8	9	1
10	11	12	1
select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) where a1=a2+1 union select *, 1 as c4 from t2 order by a2;
a1	a2	a3	a1
7	8	9	1
10	11	12	1
select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2;
a1	a2	a3	a1
4	5	6	4
7	8	9	1
10	11	12	1
select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 order by a2;
a1	a2	a3	a1
4	5	6	4
7	8	9	1
10	11	12	1
explain format=json select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2;
EXPLAIN
{
  "query_block": {
    "union_result": {
      "table_name": "<union1,3>",
      "access_type": "ALL",
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t1",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100,
                  "attached_condition": "t1.c1 > 1"
                }
              }
            ]
          }
        },
        {
          "query_block": {
            "select_id": 3,
            "operation": "UNION",
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t2",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100
                }
              }
            ]
          }
        }
      ]
    }
  }
}
explain format=json select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2 order by a2;
EXPLAIN
{
  "query_block": {
    "union_result": {
      "table_name": "<union1,3>",
      "access_type": "ALL",
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t1",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100,
                  "attached_condition": "t1.c1 > 1"
                }
              }
            ]
          }
        },
        {
          "query_block": {
            "select_id": 3,
            "operation": "UNION",
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t2",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100
                }
              }
            ]
          }
        }
      ]
    }
  }
}
explain format=json select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) where a1=a2+1 union select *, 1 as c4 from t2 order by a2;
EXPLAIN
{
  "query_block": {
    "union_result": {
      "table_name": "<union1,3>",
      "access_type": "ALL",
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t1",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100,
                  "attached_condition": "t1.c1 = t1.c2 + 1 and t1.c1 > 1"
                }
              }
            ]
          }
        },
        {
          "query_block": {
            "select_id": 3,
            "operation": "UNION",
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t2",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100
                }
              }
            ]
          }
        }
      ]
    }
  }
}
explain format=json select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2;
EXPLAIN
{
  "query_block": {
    "union_result": {
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t1",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100,
                  "attached_condition": "t1.c1 > 1"
                }
              }
            ]
          }
        },
        {
          "query_block": {
            "select_id": 3,
            "operation": "UNION",
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t2",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100
                }
              }
            ]
          }
        }
      ]
    }
  }
}
explain format=json select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 order by a2;
EXPLAIN
{
  "query_block": {
    "union_result": {
      "table_name": "<union1,3>",
      "access_type": "ALL",
      "query_specifications": [
        {
          "query_block": {
            "select_id": 1,
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t1",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100,
                  "attached_condition": "t1.c1 > 1"
                }
              }
            ]
          }
        },
        {
          "query_block": {
            "select_id": 3,
            "operation": "UNION",
            "cost": "COST_REPLACED",
            "nested_loop": [
              {
                "table": {
                  "table_name": "t2",
                  "access_type": "ALL",
                  "loops": 1,
                  "rows": 2,
                  "cost": "COST_REPLACED",
                  "filtered": 100
                }
              }
            ]
          }
        }
      ]
    }
  }
}
# Internally, we cannot have 2 column names the same (a1 from select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3))
select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2) d2;
ERROR 42S21: Duplicate column name 'a1'
select *, o4 from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2) d2 (o1, o2, o3, o4) where o2=o3+1;
o1	o2	o3	o4	o4
select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2 order by a2) d2 (o1, o2, o3, o4);
o1	o2	o3	o4
4	5	6	4
7	8	9	1
10	11	12	1
select *, o4 from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2) d2 (o1, o2, o3, o4) where o2=o3+1;
o1	o2	o3	o4	o4
select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 order by a2) d2 (o1, o2, o3, o4);
o1	o2	o3	o4
4	5	6	4
7	8	9	1
10	11	12	1
# different query result set operations (union etc)
explain format=json select *, o4 from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2) d2 (o1, o2, o3, o4)
where o2=o3+1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o2 = d2.o3 + 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1 and t1.c2 = t1.c3 + 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t2.c2 = t2.c3 + 1"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select *, o4 from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2)
d2 (o1, o2, o3, o4) where o2=o3+1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o2 = d2.o3 + 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1 and t1.c2 = t1.c3 + 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t2.c2 = t2.c3 + 1"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) intersect select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<intersect2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "INTERSECT",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) intersect all select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<intersect2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "INTERSECT",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) except select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<except2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "EXCEPT",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) except all select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 2,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<except2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "EXCEPT",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (values (1, 2, 4, 7) union select *, 1 as c4 from t2 order by 1)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 3,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,3>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "table": {
                        "message": "No tables used"
                      }
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 3,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (values (1, 2, 4, 7) union all select *, 1 as c4 from t2 order by 1)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 3,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,3>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "table": {
                        "message": "No tables used"
                      }
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 3,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (values (1, 2, 4, 7) union all select *, 1 as c4 from t2 order by 1)
d2 (o1, o2, o3, o4) where o1=1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 3,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o1 = 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,3>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "table": {
                        "message": "No tables used"
                      }
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 3,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t2.c1 = 1"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select * from (values (1, 2, 4, 7)) as d2 (a1, a2, a3, a4) union select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "<derived3>",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "materialized": {
                              "query_block": {
                                "union_result": {
                                  "query_specifications": [
                                    {
                                      "query_block": {
                                        "select_id": 3,
                                        "table": {
                                          "message": "No tables used"
                                        }
                                      }
                                    }
                                  ]
                                }
                              }
                            }
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select * from (values (1, 2, 4, 7)) as d2 (a1, a2, a3, a4) union all select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4);
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "<derived3>",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "materialized": {
                              "query_block": {
                                "union_result": {
                                  "query_specifications": [
                                    {
                                      "query_block": {
                                        "select_id": 3,
                                        "table": {
                                          "message": "No tables used"
                                        }
                                      }
                                    }
                                  ]
                                }
                              }
                            }
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from (select * from (values (1, 2, 4, 7)) as d2 (a1, a2, a3, a4) union all select *, 1 as c4 from t2 order by a2)
d2 (o1, o2, o3, o4) where o1=1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o1 = 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "<derived3>",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "d2.a1 = 1",
                            "materialized": {
                              "query_block": {
                                "union_result": {
                                  "query_specifications": [
                                    {
                                      "query_block": {
                                        "select_id": 3,
                                        "table": {
                                          "message": "No tables used"
                                        }
                                      }
                                    }
                                  ]
                                }
                              }
                            }
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t2.c1 = 1"
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from
(select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 union all select * from (values (1, 2, 4, 7)) as d2 (a1, a2, a3, a4) order by a2) d2 (o1, o2, o3, o4) where o1=1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o1 = 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4,5>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "table": {
                        "message": "Impossible WHERE"
                      }
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t2.c1 = 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 5,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "<derived6>",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "d2.a1 = 1",
                            "materialized": {
                              "query_block": {
                                "union_result": {
                                  "query_specifications": [
                                    {
                                      "query_block": {
                                        "select_id": 6,
                                        "table": {
                                          "message": "No tables used"
                                        }
                                      }
                                    }
                                  ]
                                }
                              }
                            }
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from
(select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 union all select * from (values (1, 2, 4, 7)) as d2 (a1, a2, a3, a4) order by a2 limit 1)
as d2 (o1, o2, o3, o4) where o1=1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 6,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o1 = 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4,5>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 5,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "<derived6>",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "materialized": {
                              "query_block": {
                                "union_result": {
                                  "query_specifications": [
                                    {
                                      "query_block": {
                                        "select_id": 6,
                                        "table": {
                                          "message": "No tables used"
                                        }
                                      }
                                    }
                                  ]
                                }
                              }
                            }
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from
(select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 union all select * from (values (1, 2, 4, 7)) as d2 (a1, a2, a3, a4) order by a2)
as d2 (o1, o2, o3, o4) where o1=1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 4,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o1 = 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4,5>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "table": {
                        "message": "Impossible WHERE"
                      }
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t2.c1 = 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 5,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "<derived6>",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "d2.a1 = 1",
                            "materialized": {
                              "query_block": {
                                "union_result": {
                                  "query_specifications": [
                                    {
                                      "query_block": {
                                        "select_id": 6,
                                        "table": {
                                          "message": "No tables used"
                                        }
                                      }
                                    }
                                  ]
                                }
                              }
                            }
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
explain format=json select * from
(select *, a1 from
(select c1, c2, c3 from t1 where c1 > 1)
as d1 (a1, a2, a3) union all select *, 1 as c4 from t2 union all select * from (values (1, 2, 4, 7)) as d2 (a1, a2, a3, a4) order by a2, a3 limit 1)
as d2 (o1, o2, o3, o4) where o1=1;
EXPLAIN
{
  "query_block": {
    "select_id": 1,
    "cost": "COST_REPLACED",
    "nested_loop": [
      {
        "table": {
          "table_name": "<derived2>",
          "access_type": "ALL",
          "loops": 1,
          "rows": 6,
          "cost": "COST_REPLACED",
          "filtered": 100,
          "attached_condition": "d2.o1 = 1",
          "materialized": {
            "query_block": {
              "union_result": {
                "table_name": "<union2,4,5>",
                "access_type": "ALL",
                "query_specifications": [
                  {
                    "query_block": {
                      "select_id": 2,
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t1",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "attached_condition": "t1.c1 > 1"
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 4,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "t2",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100
                          }
                        }
                      ]
                    }
                  },
                  {
                    "query_block": {
                      "select_id": 5,
                      "operation": "UNION",
                      "cost": "COST_REPLACED",
                      "nested_loop": [
                        {
                          "table": {
                            "table_name": "<derived6>",
                            "access_type": "ALL",
                            "loops": 1,
                            "rows": 2,
                            "cost": "COST_REPLACED",
                            "filtered": 100,
                            "materialized": {
                              "query_block": {
                                "union_result": {
                                  "query_specifications": [
                                    {
                                      "query_block": {
                                        "select_id": 6,
                                        "table": {
                                          "message": "No tables used"
                                        }
                                      }
                                    }
                                  ]
                                }
                              }
                            }
                          }
                        }
                      ]
                    }
                  }
                ]
              }
            }
          }
        }
      }
    ]
  }
}
# both group by references should work
select c1 as col, sum(c2) as s from t1 group by c1;
col	s
1	2
4	5
select c1 as col, sum(c2) as s from t1 group by col;
col	s
1	2
4	5
select d1 from
(select c1 as col, sum(c2) as s from t1 group by c1) as dt (d1,d2);
d1
1
4
select * from
(select c1 as col, sum(c2) as s from t1 group by c1) as dt (d1,d2);
d1	d2
1	2
4	5
select d1 from
(select c1 as col, sum(c2) as s from t1 group by col) as dt (d1,d2);
d1
1
4
select * from
(select c1 as col, sum(c2) as s from t1 group by col) as dt (d1,d2);
d1	d2
1	2
4	5
# name resolution again at a different lexical depth
select *, e1 from
(select d2 from (select * from t1 where c1 < 7) tt (d1, d2, d3)
where d1 > 2 group by d1) td (e1);
e1	e1
5	5
# check resolution in grouping operations
select * from
(select * from (select * from t1 where c1 < 7) tt (d1, d2, d3)
where d1 > 2 group by d1 having sum(d3) > 4 order by d2) td (e1, e2, e3);
e1	e2	e3
4	5	6
select * from
(select * from (select * from t1 where c1 < 7) tt (d1, d2, d3)
where d1 > 2 group by d1 having sum(d3) > 4 order by d2) td (e1, e2, e3)
where e3 < 5;
e1	e2	e3
select d1, row_number() over (partition by d1 order by d2)
from (select * from t1) dt (d1, d2, d3);
d1	row_number() over (partition by d1 order by d2)
1	1
4	1
select
d1, d2,
count(*) over w1 as dc1,
count(*) over w2 as dc2,
count(*) over w3 as dc3
from (select * from t1)  dt (d1, d2, d3)
window
w1 as (partition by d2),
w2 as (w1 order by d1),
w3 as (w2 rows between 2 preceding and 2 following);
d1	d2	dc1	dc2	dc3
1	2	1	1	1
4	5	1	1	1
with
cte1 as
(select * from (select * from t1 group by c1)
as dt2 (d1,d2,d3)),
cte as
(select cte1.d1, sum(cte1.d2) over (partition by cte1.d1 order by cte1.d1)
as k from cte1)
select * from cte;
d1	k
1	2
4	5
# check non select queries
update t1, (select * from t2) as dt (d1,d2,d3)
set c1=c1+1 where d1= c1+6;
delete t1 from t1, (select * from t2) as dt (d1,d2,d3) where d1= c1+5;
insert into t1 values (1,2,3),(4,5,6);
delete from t1 using t1, (select * from t2) as dt (d1,d2,d3) where d1= c1+6;
insert into t1 select * from (select c1-6, c2-6, c3-6 from t2) as dt (d1,d2,d3);
replace into t1 select * from (select c1-6, c2-6, c3-6 from t2) as dt (d1,d2,d3)
returning c1, (select c1 from (select * from t1) as dt (d4,d5,d6)
where c1=d1 limit 1);
c1	(select c1 from (select * from t1) as dt (d4,d5,d6)
where c1=d1 limit 1)
1	1
4	4
replace into t1 select * from (select c1-6, c2-6, c3-6 from t2) as dt (d1,d2,d3)
returning c1, (select c1 from (select * from t1) as dt (d4,d5,d6)
where c1=d2 limit 1);
c1	(select c1 from (select * from t1) as dt (d4,d5,d6)
where c1=d2 limit 1)
1	NULL
4	NULL
alter table t1 rename column c1 to cc1;
select * from v1;
ERROR HY000: View 'test.v1' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them
drop view v1, v2, v3, v4, v5, v6, v7, v8, v9;
drop table t1, t2, t3;
create table t10 (a int);
create table t20 (b int);
insert into t10 values (1),(2);
insert into t20 values (1),(3);
create view v10 as select *, 'U' as u from t10
left join (select 'Y' as y, t20.b from t20) dt1 (y, b1) on t10.a= dt1.b1
limit 3;
create view v11 as select b1, 'U' as u from t10
left join (select 'Y' as y, t20.b from t20) dt1 (y, b1) on t10.a= dt1.b1
limit 3;
create table t30 (c int);
insert into t30 values (1),(3);
create view v20 as select * from t30
left join (select 'X' as x, v10.u, v10.y, v10.b1 from v10) dt2 (x, u1, y1, b2)
on t30.c=dt2.b2 limit 6;
create view v21 as select * from t30
left join (select 'X' as x, v11.u, v11.b1 from v11) dt2 (x, u1, b1)
on t30.c=dt2.b1 order by x;
select * from v20;
c	x	u1	y1	b2
1	X	U	Y	1
3	NULL	NULL	NULL	NULL
select * from v20  order by c limit 9;
c	x	u1	y1	b2
1	X	U	Y	1
3	NULL	NULL	NULL	NULL
select * from v21 order by c;
c	x	u1	b1
1	X	U	1
3	NULL	NULL	NULL
drop view v10, v20, v11, v21;
drop table t10, t20, t30;
#
# End of 11.7 tests
#
#
# MDEV-37044 derived_wth_keys optimization not applied where it should
#
# MI_MAX_KEY_LENGTH < key length < tmp_table_max_key_length()
# must use <derived2>, <derived3> with ref access (not ALL)
create table t1
(
`CTC_DATABASE` varchar(128) NOT NULL,
`CTC_TABLE` varchar(256) DEFAULT NULL,
`CTC_PARTITION` varchar(767) DEFAULT NULL
) DEFAULT CHARSET=latin1 COLLATE=latin1_swedish_ci;
insert into t1
select
concat('db-', seq),
concat('tbl-', seq),
concat('part-', seq)
from
seq_1_to_100;
explain select * from
(select * from t1 limit 100) A,
(select * from t1 limit 101) B
where
A.ctc_database=B.ctc_database and
A.ctc_table=B.ctc_table and
A.ctc_partition=B.ctc_partition;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	100	Using where
1	PRIMARY	<derived3>	ref	key0	key0	1159	A.CTC_DATABASE,A.CTC_TABLE,A.CTC_PARTITION	10	
3	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	100	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	100	
# key length > tmp_table_max_key_length()
# This uses <derived2>, <derived3> with type=ALL as index on temp table
# would be too long
alter table t1 CONVERT TO CHARACTER SET utf8;
explain select * from
(select * from t1 limit 100) A,
(select * from t1 limit 101) B
where
A.ctc_database=B.ctc_database and
A.ctc_table=B.ctc_table and
A.ctc_partition=B.ctc_partition;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	100	
1	PRIMARY	<derived3>	ALL	NULL	NULL	NULL	NULL	100	Using where; Using join buffer (flat, BNL join)
3	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	100	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	100	
drop table t1;
# number of key parts > tmp_table_max_key_parts()
# This uses <derived2>, <derived3> with type=ALL as index on temp table
# would have too many parts
create table t1
(
c0  varchar(10) NOT NULL,
c1  varchar(10),
c2  varchar(10),
c3  varchar(10),
c4  varchar(10),
c5  varchar(10),
c6  varchar(10),
c7  varchar(10),
c8  varchar(10),
c9  varchar(10),
c10  varchar(10),
c11  varchar(10),
c12  varchar(10),
c13  varchar(10),
c14  varchar(10),
c15  varchar(10),
c16  varchar(10),
c17  varchar(10),
c18  varchar(10),
c19  varchar(10),
c20  varchar(10),
c21  varchar(10),
c22  varchar(10),
c23  varchar(10),
c24  varchar(10),
c25  varchar(10),
c26  varchar(10),
c27  varchar(10),
c28  varchar(10),
c29  varchar(10),
c30  varchar(10),
c31  varchar(10),
c32  varchar(10),
c33  varchar(10)
);
insert into t1
select
seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq,
seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq, seq,
seq, seq, seq, seq
from
seq_1_to_100;
explain select * from
(select * from t1 limit 100) A,
(select * from t1 limit 101) B
where
A.c0 = B.c0 and A.c1 = B.c1 and A.c2 = B.c2 and A.c3 = B.c3 and
A.c4 = B.c4 and A.c5 = B.c5 and A.c6 = B.c6 and A.c7 = B.c7 and
A.c8 = B.c8 and A.c9 = B.c9 and A.c10 = B.c10 and A.c11 = B.c11 and
A.c12 = B.c12 and A.c13 = B.c13 and A.c14 = B.c14 and A.c15 = B.c15 and
A.c16 = B.c16 and A.c17 = B.c17 and A.c18 = B.c18 and A.c19 = B.c19 and
A.c20 = B.c20 and A.c21 = B.c21 and A.c22 = B.c22 and A.c23 = B.c23 and
A.c24 = B.c24 and A.c25 = B.c25 and A.c26 = B.c26 and A.c27 = B.c27 and
A.c28 = B.c28 and A.c29 = B.c29 and A.c30 = B.c30 and A.c31 = B.c31 and
A.c32 = B.c32 and A.c33 = B.c33;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	PRIMARY	<derived2>	ALL	NULL	NULL	NULL	NULL	100	
1	PRIMARY	<derived3>	ALL	NULL	NULL	NULL	NULL	100	Using where; Using join buffer (flat, BNL join)
3	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	100	
2	DERIVED	t1	ALL	NULL	NULL	NULL	NULL	100	
drop table t1;
#
# End of 12.0 tests
#
ALTER DATABASE test CHARACTER SET utf8mb4 COLLATE utf8mb4_uca1400_ai_ci;
