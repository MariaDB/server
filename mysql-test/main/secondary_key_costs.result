create table t1 (
pk int primary key auto_increment,
nm varchar(32),
fl1 tinyint default 0,
fl2 tinyint default 0,
index idx1(nm, fl1),
index idx2(fl2)
) engine=myisam;
create table name (
pk int primary key auto_increment,
nm bigint
) engine=myisam;
create table flag2 (
pk int primary key auto_increment,
fl2 tinyint
) engine=myisam;
insert into name(nm) select seq from seq_1_to_1000 order by rand(17);
insert into flag2(fl2) select seq mod 2 from seq_1_to_1000 order by rand(19);
insert into t1(nm,fl2)
select nm, fl2 from name, flag2 where name.pk = flag2.pk;
analyze table t1 persistent for all;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	Engine-independent statistics collected
test.t1	analyze	status	Table is already up to date
set optimizer_trace="enabled=on";
set optimizer_switch='rowid_filter=on';
set statement optimizer_adjust_secondary_key_costs=0 for
explain select * from t1  where nm like '500%' AND fl2 = 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx1,idx2	idx1	35	NULL	1	Using index condition; Using where
set @trace=(select trace from information_schema.optimizer_trace);
select json_detailed(json_extract(@trace, '$**.considered_access_paths'));
json_detailed(json_extract(@trace, '$**.considered_access_paths'))
[
    [
        {
            "access_type": "ref",
            "index": "idx2",
            "used_range_estimates": true,
            "rowid_filter_skipped": "worst/max seeks clipping",
            "rows": 492,
            "cost": 492.3171406,
            "chosen": true
        },
        {
            "access_type": "range",
            "resulting_rows": 0.492,
            "cost": 1.448699097,
            "chosen": true
        }
    ]
]

The following trace should have a different rowid_filter_key cost

set statement optimizer_adjust_secondary_key_costs=2 for
explain select * from t1  where nm like '500%' AND fl2 = 0;
id	select_type	table	type	possible_keys	key	key_len	ref	rows	Extra
1	SIMPLE	t1	range	idx1,idx2	idx1	35	NULL	1	Using index condition; Using where
set @trace=(select trace from information_schema.optimizer_trace);
select json_detailed(json_extract(@trace, '$**.considered_access_paths'));
json_detailed(json_extract(@trace, '$**.considered_access_paths'))
[
    [
        {
            "access_type": "ref",
            "index": "idx2",
            "used_range_estimates": true,
            "rowid_filter_key": "idx1",
            "rows": 492,
            "cost": 3.814364688,
            "chosen": true
        },
        {
            "access_type": "range",
            "resulting_rows": 0.492,
            "cost": 1.448699097,
            "chosen": true
        }
    ]
]
drop table t1, name, flag2;
