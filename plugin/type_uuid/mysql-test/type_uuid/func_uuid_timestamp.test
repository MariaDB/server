# MDEV-33710: UUID_TIMESTAMP() extracts timestamp from UUIDv1 and UUIDv7

# Use UTC for consistent results across timezones
SET time_zone='+00:00';

# Test UUIDv7 with known values
# 0x018d17f3e9a3 = 1705522477475 ms
SELECT UUID_TIMESTAMP('018d17f3-e9a3-7000-8000-000000000000');

# 0x0188b5b88000 = 1686687547520 ms
SELECT UUID_TIMESTAMP('0188b5b8-8000-7000-8000-000000000000');

# Test UUIDv1 with known value
SELECT UUID_TIMESTAMP('1ee81f00-a8a8-11ee-8000-000000000000') IS NOT NULL AS has_timestamp;

# Test dynamic UUID generation
# UUID() and UUID_V7() use my_interval_timer() (real system time), not session
# timestamp, so we cannot use SET timestamp to fix the time. We use a tolerance
# of 120 seconds (same as update_time.test) to handle slow/loaded machines.
SELECT TIMESTAMPDIFF(SECOND, UUID_TIMESTAMP(UUID()), NOW(6)) < 120 AS v1_time_ok;
SELECT TIMESTAMPDIFF(SECOND, UUID_TIMESTAMP(UUID_V7()), NOW(6)) < 120 AS v7_time_ok;

# Test UUIDv4 returns NULL (random UUID, no timestamp)
SELECT UUID_TIMESTAMP(UUID_V4()) IS NULL AS v4_returns_null;
SELECT UUID_TIMESTAMP('a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11') IS NULL AS v4_string_returns_null;

# Test NULL and invalid input
SELECT UUID_TIMESTAMP(NULL) IS NULL AS null_input;
SELECT UUID_TIMESTAMP('not-a-valid-uuid');

# Test with native UUID type
SELECT UUID_TIMESTAMP(CAST('018d17f3-e9a3-7000-8000-000000000000' AS UUID));

# Test return type is TIMESTAMP(6)
CREATE TABLE t1 AS SELECT UUID_TIMESTAMP(UUID()) AS ts;
SHOW CREATE TABLE t1;
DROP TABLE t1;

# Edge case: UUIDv1 before Unix epoch returns NULL
SELECT UUID_TIMESTAMP('00000000-0000-1000-8000-000000000000') IS NULL AS before_unix_epoch;

# Edge case: UUIDv7 at Unix epoch (timestamp = 0)
SELECT UUID_TIMESTAMP('00000000-0000-7000-8000-000000000000');

# Test UUIDv1 and UUIDv7 generated together should be within 2 minutes
SET @u1= UUID();
SET @u7= UUID_V7();
SELECT ABS(TIMESTAMPDIFF(SECOND, UUID_TIMESTAMP(@u1), UUID_TIMESTAMP(@u7))) < 120 AS same_timeframe;

SET time_zone=DEFAULT;
