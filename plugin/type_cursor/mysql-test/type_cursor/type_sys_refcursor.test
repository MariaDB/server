--source include/have_sequence.inc
--disable_query_log
--source include/dbms_output.inc
--source include/bool_to_char.inc
--enable_query_log

#
# Basic SYS_REFCURSOR functionality
#

--echo #
--echo # MDEV-20034 Add support for the pre-defined weak SYS_REFCURSOR
--echo #


--echo #
--echo # Error: SYS_REFCURSOR is not allowed in a table column
--echo #

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
CREATE TABLE t1 (a SYS_REFCURSOR);

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  CREATE TABLE t1 AS SELECT c0;
  SHOW CREATE TABLE t1;
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  DECLARE c1 SYS_REFCURSOR;
  SELECT c0 UNION SELECT c1;
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  DECLARE c1 SYS_REFCURSOR;
  VALUES (c0), (c1);
END;
$$
DELIMITER ;$$

DELIMITER $$;
CREATE FUNCTION f1() RETURNS SYS_REFCURSOR
BEGIN
  DECLARE c0 SYS_REFCURSOR;
  OPEN c0 FOR SELECT 1 AS c;
  RETURN c0;
END;
$$
DELIMITER ;$$
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT * FROM (SELECT COALESCE(f1()) FROM seq_1_to_5) dt1;
DROP FUNCTION f1;

--echo #
--echo # ORDER BY, GROUP BY, DISTINCT
--echo #

DELIMITER $$;
CREATE FUNCTION f1() RETURNS SYS_REFCURSOR
BEGIN
  DECLARE c0 SYS_REFCURSOR;
  OPEN c0 FOR SELECT 1 AS c;
  RETURN c0;
END;
$$
DELIMITER ;$$

# ORDER BY

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT f1() FROM seq_1_to_5 ORDER BY f1();

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT f1() FROM seq_1_to_5 ORDER BY COALESCE(f1());

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT COALESCE(f1()) FROM seq_1_to_5 ORDER BY f1();

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT COALESCE(f1()) FROM seq_1_to_5 ORDER BY COALESCE(f1());

# GROUP BY

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT f1() FROM seq_1_to_5 GROUP BY f1();

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT f1() FROM seq_1_to_5 GROUP BY COALESCE(f1());

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT COALESCE(f1()) FROM seq_1_to_5 GROUP BY f1();

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT COALESCE(f1()) FROM seq_1_to_5 GROUP BY COALESCE(f1());

# The SELECT below tries to create Item_copy
CREATE TABLE t1 (a INT, b TIMESTAMP);
INSERT INTO t1 VALUES (1,'2018-06-19 00:00:00');
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT f1() AS f, MAX(a) FROM t1 GROUP BY f;
DROP TABLE t1;

# DISTINCT

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT DISTINCT f1() FROM seq_1_to_5;

--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SELECT DISTINCT COALESCE(f1()) FROM seq_1_to_5;

DROP FUNCTION f1;


--echo #
--echo # Although SYS_REFCURSOR in a <select list> is not allowed in Oracle,
--echo # let's allow it in MariaDB. It's convenient for debug purposes.
--echo #

DELIMITER $$;
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  SELECT c0;
  OPEN c0 FOR SELECT 1;
  SELECT c0;
END;
$$
DELIMITER ;$$


--echo #
--echo # Storing SYS_REFCURSOR expressions into user variables is not allowed
--echo #

DELIMITER /;
CREATE FUNCTION f0() RETURNS SYS_REFCURSOR
BEGIN
  DECLARE f0c0 SYS_REFCURSOR;
  OPEN f0c0 FOR SELECT 1;
  RETURN f0c0;
END;
/
DELIMITER ;/
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
SET @a=f0();
DROP FUNCTION f0;


DELIMITER /;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE f0c0 SYS_REFCURSOR;
  SET @a= f0c0;
END;
/
DELIMITER ;/

DELIMITER /;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE f0c0 SYS_REFCURSOR;
  SELECT @a:= f0c0;
END;
/
DELIMITER ;/


--echo #
--echo # OUTFILE
--echo #

DELIMITER $$;
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  DECLARE c1 SYS_REFCURSOR;
  OPEN c0 FOR SELECT 1;
  OPEN c1 FOR SELECT 2;
  SELECT c0, c1 INTO OUTFILE "../../tmp/file1.txt";
END;
$$
DELIMITER ;$$
--cat_file $MYSQLTEST_VARDIR/tmp/file1.txt
--remove_file $MYSQLTEST_VARDIR/tmp/file1.txt


--echo #
--echo # SYS_REFCURSOR is not allowed when Item_cache is needed.
--echo #

DELIMITER /;
CREATE PROCEDURE p2()
BEGIN
  DECLARE c0 SYS_REFCURSOR;
  OPEN c0 FOR SELECT 1;

  SELECT seq, c0 FROM seq_0_to_3
    WHERE (SELECT CASE WHEN c0 IS NOT NULL THEN c0 ELSE NULL END
           FROM seq_0_to_3 WHERE c0 IS NOT NULL) IS NOT NULL;
  SHOW WARNINGS;
END;
/
DELIMITER ;/
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
CALL p2;
DROP PROCEDURE p2;


--echo #
--echo # Error: Unknown cursors
--echo #

DELIMITER $$;
--error ER_SP_UNDECLARED_VAR
BEGIN NOT ATOMIC
  OPEN c FOR SELECT 1;
END;
$$
DELIMITER ;$$


DELIMITER $$;
--error ER_SP_CURSOR_MISMATCH
BEGIN NOT ATOMIC
  CLOSE c;
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_SP_CURSOR_MISMATCH
BEGIN NOT ATOMIC
  DECLARE v INT;
  CLOSE c INTO v;
END;
$$
DELIMITER ;$$


--echo #
--echo # Error: Closing a not open cursor
--echo #

DELIMITER $$;
--error ER_SP_CURSOR_NOT_OPEN
BEGIN NOT ATOMIC
  DECLARE c SYS_REFCURSOR;
  CLOSE c;
END;
$$
DELIMITER ;$$

--echo #
--echo # Error: Fetching from a not open cursor
--echo #

DELIMITER $$;
--error ER_SP_CURSOR_NOT_OPEN
BEGIN NOT ATOMIC
  DECLARE a INT;
  DECLARE c SYS_REFCURSOR;
  FETCH c INTO a;
END;
$$
DELIMITER ;$$


--echo #
--echo # Error: fetching beyond the available number of records
--echo #

DELIMITER $$;
--error ER_SP_FETCH_NO_DATA
BEGIN NOT ATOMIC
  DECLARE a INT;
  DECLARE c SYS_REFCURSOR;
  OPEN c FOR SELECT 1;
  FETCH c INTO a;
  FETCH c INTO a;
END;
$$
DELIMITER ;$$


--echo #
--echo # sql_mode=ORACLE: fetching beyond the available number of records
--echo # sets the %NOTFOUND attribute.
--echo #

SET sql_mode=ORACLE;
DELIMITER $$;
DECLARE
  a INT;
  c SYS_REFCURSOR;
BEGIN
  OPEN c FOR SELECT 1;
  FETCH c INTO a;
  SELECT a, c%NOTFOUND;
  FETCH c INTO a;
  SELECT a, c%NOTFOUND;
END;
$$
DELIMITER ;$$
SET sql_mode=DEFAULT;


--echo #
--echo # Store assignment
--echo #

DELIMITER $$;
--error ER_CANNOT_CAST_ON_IDENT1_ASSIGNMENT_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c SYS_REFCURSOR;
  SET c=1;
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_CANNOT_CAST_ON_IDENT1_ASSIGNMENT_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c SYS_REFCURSOR;
  DECLARE i INT;
  SET c=i;
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPES2_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c SYS_REFCURSOR;
  DECLARE i INT;
  SET i=c;
END;
$$
DELIMITER ;$$


--echo #
--echo # FETCH using a SYS_REFCURSOR as a *target* variable
--echo #

DELIMITER /;
CREATE PROCEDURE p1()
BEGIN
  DECLARE p1c0 SYS_REFCURSOR;
  DECLARE p1c1 SYS_REFCURSOR;
  OPEN p1c0 FOR SELECT 0;
  OPEN p1c1 FOR SELECT 1;
  FETCH p1c0 INTO p1c1;
END;
/
DELIMITER ;/
--error ER_CANNOT_CAST_ON_IDENT1_ASSIGNMENT_FOR_OPERATION
CALL p1;
DROP PROCEDURE p1;


DELIMITER /;
CREATE PROCEDURE p1()
BEGIN
  DECLARE p1c0 SYS_REFCURSOR;
  DECLARE p1c1 SYS_REFCURSOR;
  OPEN p1c0 FOR SELECT 1;
  FETCH p1c0 INTO p1c1;
END;
/
DELIMITER ;/
--error ER_CANNOT_CAST_ON_IDENT1_ASSIGNMENT_FOR_OPERATION
CALL p1;
DROP PROCEDURE p1;


DELIMITER /;
CREATE PROCEDURE p1()
BEGIN
  DECLARE p1c0 SYS_REFCURSOR;
  DECLARE p1c1 SYS_REFCURSOR;
  DECLARE p1c2 SYS_REFCURSOR;
  OPEN p1c0 FOR SELECT 1;
  OPEN p1c1 FOR SELECT p1c0;
  FETCH p1c1 INTO p1c2;
END;
/
DELIMITER ;/
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
CALL p1;
DROP PROCEDURE p1;


--echo #
--echo # Aggregate functions
--echo #

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  SELECT MAX(c0);
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  SELECT MIN(c0);
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  SELECT SUM(c0);
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  SELECT AVG(c0);
END;
$$
DELIMITER ;$$

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  SELECT VARIANCE(c0);
END;
$$
DELIMITER ;$$

--echo #
--echo # Window functions
--echo #

DELIMITER $$;
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
BEGIN NOT ATOMIC
  DECLARE c0 SYS_REFCURSOR;
  OPEN c0 FOR SELECT 1;
  SELECT seq, FIRST_VALUE(c0) OVER (ORDER BY seq) AS fl FROM seq_1_to_5;
END;
$$
DELIMITER ;$$


--echo #
--echo # OPEN is not allowed for IN SYS_REFCURSOR parameters
--echo #

SET sql_mode=ORACLE;
DELIMITER /;
--error ER_NOT_SUPPORTED_YET
CREATE PROCEDURE p1(p1c0 IN SYS_REFCURSOR) AS
BEGIN
  OPEN p1c0 FOR SELECT 11 FROM DUAL UNION SELECT 12 FROM DUAL;
END;
/
DELIMITER ;/
SET sql_mode=DEFAULT;


--echo #
--echo # FETCH and CLOSE are allowed for IN SYS_REFCURSOR parameters
--echo #

SET sql_mode=ORACLE;
DELIMITER /;
CREATE PROCEDURE p1(p1c0 IN SYS_REFCURSOR) AS
  p1c1 SYS_REFCURSOR DEFAULT p1c0;
  v0 INT;
  v1 INT;
BEGIN
  FETCH p1c1 INTO v0;
  OPEN p1c1 FOR SELECT 11 FROM DUAL UNION SELECT 12 FROM DUAL;
  FETCH p1c1 INTO v1;
  DBMS_OUTPUT.PUT_LINE(v0 || ' ' || v1);
  CLOSE p1c0;
END;
/
CREATE PROCEDURE p2 AS
  p2c0 SYS_REFCURSOR;
BEGIN
  OPEN p2c0 FOR SELECT 21 FROM DUAL UNION SELECT 22 FROM DUAL;
  p1(p2c0);
  DBMS_OUTPUT.PUT_LINE('p2c0%ISOPEN' ||'='|| bool_to_char(p2c0%ISOPEN));
END;
/
DELIMITER ;/
CALL p2;

DROP PROCEDURE p1;
DROP PROCEDURE p2;
SET sql_mode=DEFAULT;


--echo #
--echo # OPEN is allowed for an IN parameter alias
--echo #

SET sql_mode=ORACLE;
DELIMITER /;
CREATE PROCEDURE p1(p1c0 IN SYS_REFCURSOR) AS
  p1c1 SYS_REFCURSOR DEFAULT p1c0;
  v0 INT;
  v1 INT;
BEGIN
  FETCH p1c1 INTO v0;
  OPEN p1c1 FOR SELECT 11 FROM DUAL UNION SELECT 12 FROM DUAL;
  FETCH p1c1 INTO v1;
  DBMS_OUTPUT.PUT_LINE(v0 || ' ' || v1);
  CLOSE p1c0;
END;
/
CREATE PROCEDURE p2 AS
  p2c0 SYS_REFCURSOR;
BEGIN
  OPEN p2c0 FOR SELECT 21 FROM DUAL UNION SELECT 22 FROM DUAL;
  p1(p2c0);
  DBMS_OUTPUT.PUT_LINE('p2c0%ISOPEN' ||'='|| bool_to_char(p2c0%ISOPEN));
END;
/
DELIMITER ;/
CALL p2;
DROP PROCEDURE p1;
DROP PROCEDURE p2;
SET sql_mode=DEFAULT;


--echo #
--echo # SYS_REFCURSOR SP variables are not constants. Expressions
--echo # with SYS_REFCURSOR variables in WHERE condition do not get cached.
--echo # 'WHERE c0 IS NOT NULL' is not replaced to 'WHERE 1'
--echo #

DELIMITER /;
CREATE PROCEDURE p2()
BEGIN
  DECLARE c0 SYS_REFCURSOR;
  OPEN c0 FOR SELECT 1;

  EXPLAIN EXTENDED
  SELECT seq, c0 FROM seq_0_to_3 WHERE c0 IS NOT NULL;
  SHOW WARNINGS;

  SELECT seq, c0 FROM seq_0_to_3 WHERE c0 IS NOT NULL;
END;
/
DELIMITER ;/
CALL p2;
DROP PROCEDURE p2;

--echo #
--echo # MDEV-36409 Server crashes when creating a table using function with a return type sys_refcursor
--echo #

DELIMITER /;
CREATE FUNCTION f1() RETURNS SYS_REFCURSOR 
BEGIN 
  DECLARE c SYS_REFCURSOR;
  OPEN c FOR SELECT 1;
  RETURN c;
END;
/
DELIMITER ;/
--error ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION
CREATE TABLE t1 AS SELECT f1();
DROP FUNCTION f1;


--echo #
--echo # MDEV-36377 Assertion `thd->lex == sp_instr_lex' failed in LEX *sp_lex_instr::parse_expr(THD *, sp_head *, LEX *)
--echo #

CREATE TABLE t1 (a INT);
--delimiter $
CREATE PROCEDURE p1() 
BEGIN 
  DECLARE c1 SYS_REFCURSOR; 
  OPEN c1 FOR SELECT * FROM t1; 
  END;
$
--delimiter ;
CALL p1;
CREATE OR REPLACE TABLE t1(a INT);
CALL p1;
CALL p1;
CALL p1;
DROP PROCEDURE p1;
DROP TABLE t1;


CREATE TABLE t (a INT);
--delimiter $
CREATE PROCEDURE p1 (OUT c sys_refcursor) 
BEGIN 
  OPEN c FOR SELECT a FROM t ;
END; 
$
CREATE PROCEDURE p2() 
BEGIN 
  DECLARE c sys_refcursor;
  DECLARE v INT;
  EXECUTE IMMEDIATE 'CALL p1 (?)' USING c;
  FETCH c INTO v;
  SELECT c,v;
END; 
$
--delimiter ;
--error ER_SP_FETCH_NO_DATA
CALL p2;
CREATE OR REPLACE TABLE t (a INT);
--error ER_SP_FETCH_NO_DATA
CALL p2;
--error ER_SP_FETCH_NO_DATA
CALL p2;
--error ER_SP_WRONG_NO_OF_ARGS
CALL p1;
DROP PROCEDURE p2;
DROP PROCEDURE p1;
DROP TABLE t;


#
# Cleanup
#

DROP PACKAGE dbms_output;
DROP FUNCTION bool_to_char;
