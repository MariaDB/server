#
# MDEV-20034 Add support for the pre-defined weak SYS_REFCURSOR
#
#
# ROWs with SYS_REFCURSOR fields
#
CREATE PROCEDURE p1(p1r0 ROW(c0 SYS_REFCURSOR, c1 SYS_REFCURSOR))
BEGIN
DECLARE c0 SYS_REFCURSOR DEFAULT p1r0.c0;
DECLARE c1 SYS_REFCURSOR DEFAULT p1r0.c1;
DECLARE v0 INT;
DECLARE v1 INT;
FETCH c0 INTO v0;
FETCH c1 INTO v1;
SELECT v0, v1;
END
/
CREATE PROCEDURE p2()
BEGIN
DECLARE c0 SYS_REFCURSOR;
DECLARE c1 SYS_REFCURSOR;
OPEN c0 FOR SELECT 10;
OPEN c1 FOR SELECT 11;
CALL p1(ROW(c0, c1));
END;
/
CALL p2;
v0	v1
10	11
DROP PROCEDURE p2;
DROP PROCEDURE p1;
#
# Fetching from a SYS_REFCURSOR variable to an explicit ROW
#
CREATE PROCEDURE p1()
BEGIN
DECLARE c0 SYS_REFCURSOR;
DECLARE r0 ROW (a INT, b VARCHAR(10));
OPEN c0 FOR SELECT 1, 'b1';
FETCH c0 INTO r0;
SELECT r0.a, r0.b;
END;
/
CALL p1;
r0.a	r0.b
1	b1
DROP PROCEDURE p1;
#
# Fetching from a SYS_REFCURSOR variable to an anchored ROW
#
CREATE TABLE t1 (a INT, b VARCHAR(10));
INSERT INTO t1 VALUES (1,'b1');
CREATE PROCEDURE p1()
BEGIN
DECLARE c0 SYS_REFCURSOR;
DECLARE r0 ROW TYPE OF t1;
OPEN c0 FOR SELECT * FROM t1;
FETCH c0 INTO r0;
SELECT r0.a, r0.b;
END;
/
CALL p1;
r0.a	r0.b
1	b1
DROP PROCEDURE p1;
DROP TABLE t1;
#
# Make sure a ROW variable with SYS_REFCURSOR members destructs
# its members properly when leaving a BEGIN..END block.
#
CREATE PROCEDURE p1()
BEGIN
BEGIN
DECLARE r0 ROW(m0 SYS_REFCURSOR, m1 SYS_REFCURSOR);
BEGIN
DECLARE c0 SYS_REFCURSOR;
DECLARE c1 SYS_REFCURSOR;
OPEN c0 FOR SELECT 10;
OPEN c1 FOR SELECT 11;
SET r0= ROW(c0, c1);
END;
SELECT r0.m0, r0.m1; -- Expect 0, 1
END; -- All SYS_REFCURSORs should be freed here: c0, c1, r0.m0, r0.m1
BEGIN
DECLARE v0 INT;
DECLARE v1 INT;
DECLARE c0 SYS_REFCURSOR;
DECLARE c1 SYS_REFCURSOR;
OPEN c0 FOR SELECT 20; -- Expect to reuse m_statement_cursors.at(0)
OPEN c1 FOR SELECT 21; -- Expect to reuse m_statement_cursors.at(1)
FETCH c0 INTO v0;
FETCH c1 INTO v1;
SELECT c0, c1, v0, v1; -- Expect 0, 1, 20, 21
END;
END;
/
CALL p1;
r0.m0	r0.m1
0	1
c0	c1	v0	v1
0	1	20	21
DROP PROCEDURE p1;
